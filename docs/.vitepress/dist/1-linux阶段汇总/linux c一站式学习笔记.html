<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一 程序的基本概念 | mycpp-note</title>
    <meta name="description" content="xinghuai的学习笔记">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/mycppnoteweb/assets/style.DbrLBEdr.css" as="style">
    <link rel="preload stylesheet" href="/mycppnoteweb/vp-icons.css" as="style">
    
    <script type="module" src="/mycppnoteweb/assets/app.XlNjfzUR.js"></script>
    <link rel="preload" href="/mycppnoteweb/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mycppnoteweb/assets/chunks/theme.BFLFnTQ5.js">
    <link rel="modulepreload" href="/mycppnoteweb/assets/chunks/framework.MzfCtVj-.js">
    <link rel="modulepreload" href="/mycppnoteweb/assets/1-linux阶段汇总_linux c一站式学习笔记.md.D9G_3GLW.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1b770e11><!--[--><!--]--><!--[--><span tabindex="-1" data-v-cc7de52e></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-cc7de52e>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1b770e11 data-v-bbb74e5a><div class="VPNavBar" data-v-bbb74e5a data-v-d05d792e><div class="wrapper" data-v-d05d792e><div class="container" data-v-d05d792e><div class="title" data-v-d05d792e><div class="VPNavBarTitle has-sidebar" data-v-d05d792e data-v-43580379><a class="title" href="/mycppnoteweb/" data-v-43580379><!--[--><!--]--><!----><span data-v-43580379>mycpp-note</span><!--[--><!--]--></a></div></div><div class="content" data-v-d05d792e><div class="content-body" data-v-d05d792e><!--[--><!--]--><div class="VPNavBarSearch search" data-v-d05d792e><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-d05d792e data-v-8d00cc26><span id="main-nav-aria-label" class="visually-hidden" data-v-8d00cc26> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mycppnoteweb/" tabindex="0" data-v-8d00cc26 data-v-5337c0c4><!--[--><span data-v-5337c0c4>home</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-8d00cc26 data-v-3996b80d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3996b80d><span class="text" data-v-3996b80d><!----><span data-v-3996b80d>linux</span><span class="vpi-chevron-down text-icon" data-v-3996b80d></span></span></button><div class="menu" data-v-3996b80d><div class="VPMenu" data-v-3996b80d data-v-f4d7e8ec><div class="items" data-v-f4d7e8ec><!--[--><!--[--><div class="VPMenuGroup" data-v-f4d7e8ec data-v-3254d667><p class="title" data-v-3254d667>系统编程</p><!--[--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/1-%E9%BB%91%E9%A9%AClinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-%E7%BB%93%E5%90%88%E8%AF%BE%E4%BB%B6%E7%9C%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>系统编程-1</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/2-%E9%BB%91%E9%A9%AClinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>系统编程-2</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/3-%E9%BB%91%E9%A9%AClinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>系统编程-3</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-f4d7e8ec data-v-3254d667><p class="title" data-v-3254d667>网络编程</p><!--[--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/4-%E9%BB%91%E9%A9%AClinux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>网络编程-1</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/5-%E9%BB%91%E9%A9%AC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>网络编程-2</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/6-%E9%BB%91%E9%A9%AC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>网络编程-3</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/7-%E9%BB%91%E9%A9%AC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>网络编程-4</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/8-%E7%B3%BB%E7%BB%9F+%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%E6%B1%87%E6%80%BB.html" data-v-623661b5><!--[--><span data-v-623661b5>练习代码</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-8d00cc26 data-v-3996b80d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3996b80d><span class="text" data-v-3996b80d><!----><span data-v-3996b80d>cpp</span><span class="vpi-chevron-down text-icon" data-v-3996b80d></span></span></button><div class="menu" data-v-3996b80d><div class="VPMenu" data-v-3996b80d data-v-f4d7e8ec><div class="items" data-v-f4d7e8ec><!--[--><!--[--><div class="VPMenuGroup" data-v-f4d7e8ec data-v-3254d667><p class="title" data-v-3254d667>cpp中级</p><!--[--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/1-%E4%B8%AD%E7%BA%A7c++%E7%AC%94%E8%AE%B0-1.html" data-v-623661b5><!--[--><span data-v-623661b5>cpp中级-1</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/1-%E4%B8%AD%E7%BA%A7c++%E7%AC%94%E8%AE%B0-2.html" data-v-623661b5><!--[--><span data-v-623661b5>cpp中级-2</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/1-%E4%B8%AD%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html" data-v-623661b5><!--[--><span data-v-623661b5>中级面试</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-f4d7e8ec data-v-3254d667><p class="title" data-v-3254d667>cpp高级</p><!--[--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/2-%E9%AB%98%E7%BA%A7c++%E7%AC%94%E8%AE%B0-1.html" data-v-623661b5><!--[--><span data-v-623661b5>cpp高级-1</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/2-%E9%AB%98%E7%BA%A7c++%E7%AC%94%E8%AE%B0-2.html" data-v-623661b5><!--[--><span data-v-623661b5>cpp高级-2</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html" data-v-623661b5><!--[--><span data-v-623661b5>回调函数</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-3254d667 data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/%E5%9B%9E%E9%A1%BElinux%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" data-v-623661b5><!--[--><span data-v-623661b5>回顾linux的多线程</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-8d00cc26 data-v-3996b80d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3996b80d><span class="text" data-v-3996b80d><!----><span data-v-3996b80d>数据结构</span><span class="vpi-chevron-down text-icon" data-v-3996b80d></span></span></button><div class="menu" data-v-3996b80d><div class="VPMenu" data-v-3996b80d data-v-f4d7e8ec><div class="items" data-v-f4d7e8ec><!--[--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" data-v-623661b5><!--[--><span data-v-623661b5>数据结构-1</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%94%E5%A4%A7%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%8E).html" data-v-623661b5><!--[--><span data-v-623661b5>数据结构-2</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/数据结构/C++版数据结构和算法课程.pdf" data-v-623661b5><!--[--><span data-v-623661b5>老师pdf</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/数据结构/红黑树删除节点 - Hide on bush.pdf" data-v-623661b5><!--[--><span data-v-623661b5>红黑树扩展</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B0%8F%E8%A1%A5%E5%85%85.html" data-v-623661b5><!--[--><span data-v-623661b5>数据结构小补充</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-8d00cc26 data-v-3996b80d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3996b80d><span class="text" data-v-3996b80d><!----><span data-v-3996b80d>项目</span><span class="vpi-chevron-down text-icon" data-v-3996b80d></span></span></button><div class="menu" data-v-3996b80d><div class="VPMenu" data-v-3996b80d data-v-f4d7e8ec><div class="items" data-v-f4d7e8ec><!--[--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/markdown-examples.html" data-v-623661b5><!--[--><span data-v-623661b5>集群聊天服务器</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/api-examples.html" data-v-623661b5><!--[--><span data-v-623661b5>mprpc框架</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-8d00cc26 data-v-3996b80d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3996b80d><span class="text" data-v-3996b80d><!----><span data-v-3996b80d>mysql</span><span class="vpi-chevron-down text-icon" data-v-3996b80d></span></span></button><div class="menu" data-v-3996b80d><div class="VPMenu" data-v-3996b80d data-v-f4d7e8ec><div class="items" data-v-f4d7e8ec><!--[--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E6%96%BD%E7%A3%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%B8%E5%BF%83/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0.html" data-v-623661b5><!--[--><span data-v-623661b5>mysql-1</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f4d7e8ec data-v-623661b5><a class="VPLink link" href="/mycppnoteweb/%E6%96%BD%E7%A3%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%B8%E5%BF%83/2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html" data-v-623661b5><!--[--><span data-v-623661b5>常用命令小总结</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-d05d792e data-v-9cfff6f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-9cfff6f0 data-v-ab887738 data-v-fb8e66d1><span class="check" data-v-fb8e66d1><span class="icon" data-v-fb8e66d1><!--[--><span class="vpi-sun sun" data-v-ab887738></span><span class="vpi-moon moon" data-v-ab887738></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-d05d792e data-v-efb95778 data-v-9092002d><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xinghuaiaaa/mycpp-note" aria-label="github" target="_blank" rel="noopener" data-v-9092002d data-v-4e920967><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-d05d792e data-v-b33bc18e data-v-3996b80d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-3996b80d><span class="vpi-more-horizontal icon" data-v-3996b80d></span></button><div class="menu" data-v-3996b80d><div class="VPMenu" data-v-3996b80d data-v-f4d7e8ec><!----><!--[--><!--[--><!----><div class="group" data-v-b33bc18e><div class="item appearance" data-v-b33bc18e><p class="label" data-v-b33bc18e>Appearance</p><div class="appearance-action" data-v-b33bc18e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-b33bc18e data-v-ab887738 data-v-fb8e66d1><span class="check" data-v-fb8e66d1><span class="icon" data-v-fb8e66d1><!--[--><span class="vpi-sun sun" data-v-ab887738></span><span class="vpi-moon moon" data-v-ab887738></span><!--]--></span></span></button></div></div></div><div class="group" data-v-b33bc18e><div class="item social-links" data-v-b33bc18e><div class="VPSocialLinks social-links-list" data-v-b33bc18e data-v-9092002d><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xinghuaiaaa/mycpp-note" aria-label="github" target="_blank" rel="noopener" data-v-9092002d data-v-4e920967><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-d05d792e data-v-b529eeb3><span class="container" data-v-b529eeb3><span class="top" data-v-b529eeb3></span><span class="middle" data-v-b529eeb3></span><span class="bottom" data-v-b529eeb3></span></span></button></div></div></div></div><div class="divider" data-v-d05d792e><div class="divider-line" data-v-d05d792e></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1b770e11 data-v-b812724c><div class="container" data-v-b812724c><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-b812724c><span class="vpi-align-left menu-icon" data-v-b812724c></span><span class="menu-text" data-v-b812724c>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-b812724c data-v-fb1f2e36><button data-v-fb1f2e36>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-1b770e11 data-v-cebeea32><div class="curtain" data-v-cebeea32></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-cebeea32><span class="visually-hidden" id="sidebar-aria-label" data-v-cebeea32> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-7e8499e1><section class="VPSidebarItem level-0" data-v-7e8499e1 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h2 class="text" data-v-ac921fd9>linux</h2><!----></div><div class="items" data-v-ac921fd9><!--[--><section class="VPSidebarItem level-1 collapsible" data-v-ac921fd9 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h3 class="text" data-v-ac921fd9>系统编程</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-ac921fd9><span class="vpi-chevron-right caret-icon" data-v-ac921fd9></span></div></div><div class="items" data-v-ac921fd9><!--[--><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/1-%E9%BB%91%E9%A9%AClinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-%E7%BB%93%E5%90%88%E8%AF%BE%E4%BB%B6%E7%9C%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>系统编程-1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/2-%E9%BB%91%E9%A9%AClinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>系统编程-2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/3-%E9%BB%91%E9%A9%AClinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>系统编程-3</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible" data-v-ac921fd9 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h3 class="text" data-v-ac921fd9>网络编程</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-ac921fd9><span class="vpi-chevron-right caret-icon" data-v-ac921fd9></span></div></div><div class="items" data-v-ac921fd9><!--[--><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/4-%E9%BB%91%E9%A9%AClinux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>网络编程-1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/5-%E9%BB%91%E9%A9%AC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>网络编程-2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/6-%E9%BB%91%E9%A9%AC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>网络编程-3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/7-%E9%BB%91%E9%A9%AC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>网络编程-4</p><!--]--></a><!----></div><!----></div><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/8-%E7%B3%BB%E7%BB%9F+%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%E6%B1%87%E6%80%BB.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>练习代码</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-7e8499e1><section class="VPSidebarItem level-0" data-v-7e8499e1 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h2 class="text" data-v-ac921fd9>cpp</h2><!----></div><div class="items" data-v-ac921fd9><!--[--><section class="VPSidebarItem level-1 collapsible" data-v-ac921fd9 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h3 class="text" data-v-ac921fd9>cpp中级</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-ac921fd9><span class="vpi-chevron-right caret-icon" data-v-ac921fd9></span></div></div><div class="items" data-v-ac921fd9><!--[--><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/1-%E4%B8%AD%E7%BA%A7c++%E7%AC%94%E8%AE%B0-1.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>cpp中级-1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/1-%E4%B8%AD%E7%BA%A7c++%E7%AC%94%E8%AE%B0-2.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>cpp中级-2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/1-%E4%B8%AD%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>中级面试</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible" data-v-ac921fd9 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h3 class="text" data-v-ac921fd9>cpp高级</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-ac921fd9><span class="vpi-chevron-right caret-icon" data-v-ac921fd9></span></div></div><div class="items" data-v-ac921fd9><!--[--><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/2-%E9%AB%98%E7%BA%A7c++%E7%AC%94%E8%AE%B0-1.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>cpp高级-1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/2-%E9%AB%98%E7%BA%A7c++%E7%AC%94%E8%AE%B0-2.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>cpp高级-2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>回调函数</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E4%B8%AD%E9%AB%98%E7%BA%A7c++%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md/%E5%9B%9E%E9%A1%BElinux%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>回顾linux的多线程</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-7e8499e1><section class="VPSidebarItem level-0" data-v-7e8499e1 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h2 class="text" data-v-ac921fd9>数据结构</h2><!----></div><div class="items" data-v-ac921fd9><!--[--><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>数据结构-1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%94%E5%A4%A7%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%8E).html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>数据结构-2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/数据结构/C++版数据结构和算法课程.pdf" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>老师pdf</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/数据结构/红黑树删除节点 - Hide on bush.pdf" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>红黑树扩展</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B0%8F%E8%A1%A5%E5%85%85.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>数据结构小补充</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-7e8499e1><section class="VPSidebarItem level-0" data-v-7e8499e1 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h2 class="text" data-v-ac921fd9>项目</h2><!----></div><div class="items" data-v-ac921fd9><!--[--><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/markdown-examples.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>集群聊天服务器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/api-examples.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>mprpc框架</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-7e8499e1><section class="VPSidebarItem level-0" data-v-7e8499e1 data-v-ac921fd9><div class="item" role="button" tabindex="0" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><h2 class="text" data-v-ac921fd9>mysql</h2><!----></div><div class="items" data-v-ac921fd9><!--[--><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E6%96%BD%E7%A3%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%B8%E5%BF%83/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>mysql</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ac921fd9 data-v-ac921fd9><div class="item" data-v-ac921fd9><div class="indicator" data-v-ac921fd9></div><a class="VPLink link link" href="/mycppnoteweb/%E6%96%BD%E7%A3%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%B8%E5%BF%83/2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html" data-v-ac921fd9><!--[--><p class="text" data-v-ac921fd9>常用命令小总结</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1b770e11 data-v-50f9c880><div class="VPDoc has-sidebar has-aside" data-v-50f9c880 data-v-37be3093><!--[--><!--]--><div class="container" data-v-37be3093><div class="aside" data-v-37be3093><div class="aside-curtain" data-v-37be3093></div><div class="aside-container" data-v-37be3093><div class="aside-content" data-v-37be3093><div class="VPDocAside" data-v-37be3093 data-v-afd94ee1><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-afd94ee1 data-v-8b2eb27d><div class="content" data-v-8b2eb27d><div class="outline-marker" data-v-8b2eb27d></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-8b2eb27d>On this page</div><ul class="VPDocOutlineItem root" data-v-8b2eb27d data-v-f15281db><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-afd94ee1></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-37be3093><div class="content-container" data-v-37be3093><!--[--><!--]--><main class="main" data-v-37be3093><div style="position:relative;" class="vp-doc _mycppnoteweb_1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB_linux%20c%E4%B8%80%E7%AB%99%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" data-v-37be3093><div><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x86 架构</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者：最早由 Intel 于 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1978</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 年发布，随后 AMD 也推出了兼容的处理器产品。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：x86 是一种CISC（复杂指令集计算机）架构，指令集较为复杂，允许单个指令执行多个操作。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">版本：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">x86</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">位)：早期的 x86 处理器为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位和 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位版本，例如 Intel </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80386</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 和 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80486</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，以及后续的 Pentium 系列。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (AMD64)：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位扩展版本，最早由 AMD 开发并普及。相比 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位 x86，x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 支持更大的内存寻址空间和更多的寄存器。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">寄存器：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位模式：主要寄存器包括 EAX、EBX、ECX、EDX 等，每个寄存器为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位模式：寄存器扩展为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位（如 RAX、RBX 等），增加了 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 个新的通用寄存器，总数达到 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 个。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">指令集扩展：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x86 架构在演进过程中增加了许多指令集扩展，如 SSE（用于多媒体处理）、AVX（用于浮点运算和矢量处理）、AES</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NI（加密指令集）等，增强了处理器在科学计算、数据加密和多媒体处理方面的性能。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">应用：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">台式机和笔记本电脑：绝大部分 Windows 和 Linux 系统使用 x86 或 x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 架构的 CPU。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">服务器：大量服务器使用 x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 架构处理器，如 Intel Xeon 和 AMD EPYC。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">虚拟化：x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 支持硬件虚拟化（Intel VT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x 和 AMD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V），使得其在云计算和虚拟化环境中应用广泛。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">优点：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">丰富的生态系统：由于历史悠久且广泛普及，x86 处理器拥有丰富的软件和硬件生态系统，支持大量的应用程序和操作系统。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">强大的兼容性：x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 向后兼容 x86 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位程序，因此可以运行旧的应用。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">高性能：在频率和指令集优化方面表现良好，尤其适合多媒体、科学计算和加密等任务。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">缺点：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">功耗较高：相比于 RISC 架构（如 ARM），x86 的复杂指令集导致功耗较高，这也是 x86 在移动设备上不如 ARM 普及的原因。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">架构复杂：为了保持向后兼容，x86 架构不断扩展和增加新特性，使得处理器设计和指令解码相对复杂。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">典型处理器：Intel Core 系列、AMD Ryzen 系列（用于个人计算）；Intel Xeon、AMD EPYC 系列（用于服务器）。</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (AMD64)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者：最初由 AMD 开发，后来 Intel 也采用并推广。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：x86</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 是 x86 架构的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位扩展，支持 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位和 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位指令。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">应用：台式机、笔记本、服务器，以及几乎所有的 Windows 和 Linux 系统。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">优点：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">向后兼容 x86，因此可以运行大量旧的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位软件。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">支持更多的寄存器和更大的内存寻址空间（最高可支持 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EB 地址空间）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">拥有丰富的指令集扩展，如 SSE、AVX，用于多媒体和科学计算。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">典型处理器：Intel Core 系列、AMD Ryzen 系列。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ARM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ARMv8)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者：由 ARM Holdings 设计，授权给其他公司制造，如苹果、高通、三星等。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：基于 RISC（精简指令集）架构，拥有较少的指令，执行速度更快且功耗低。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">应用：广泛用于移动设备（智能手机、平板电脑）、嵌入式设备、物联网 (IoT) 设备，最近也用于服务器（如亚马逊 Graviton 芯片）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">优点：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">功耗低，非常适合移动和嵌入式应用。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ARMv8 开始支持 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位指令集（AArch64），并兼容 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">强大的 SIMD 指令集，如 NEON，加速图形和多媒体处理。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">典型处理器：苹果 A 系列和 M 系列芯片、高通 Snapdragon 系列、三星 Exynos 系列。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RISC</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">V</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者：由加州大学伯克利分校设计，现为开源架构。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：完全开源的 RISC 架构，模块化设计，使其易于定制和扩展。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">应用：嵌入式系统、物联网设备、科研项目，逐渐向高性能计算领域扩展。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">优点：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开源，无需支付许可费用，使其非常适合科研和实验。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">模块化设计，用户可以根据需要添加扩展（如浮点、矢量、加密扩展等）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">架构灵活，可以在功耗、性能之间做平衡，广泛适用于多种应用场景。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">典型处理器：SiFive 系列芯片、许多新兴的物联网处理器。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PowerPC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (PPC)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者：IBM、摩托罗拉和苹果公司（早期）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：基于 RISC，设计为高效的计算能力和低功耗的平衡。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">应用：早期应用于苹果的 Macintosh 电脑和游戏主机（如 PlayStation </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、任天堂 Wii），现在用于 IBM 高性能服务器和嵌入式系统。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">优点：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">强大的浮点运算能力，适合科学计算和高性能任务。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">设计灵活，可应用在嵌入式和高性能计算领域。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IBM 的 POWER 系列芯片依旧是服务器领域的重要玩家，适合高吞吐量任务。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">典型处理器：IBM Power 系列，曾经的苹果 G3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G5 处理器。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MIPS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者：由 MIPS Technologies 公司设计，基于 RISC。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：简单而精简的指令集，使其易于实现和扩展。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">应用：主要在嵌入式系统、网络设备（如路由器），过去曾用于工作站和游戏主机（如早期的 PlayStation）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">优点：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">设计简单，功耗低，适合低成本、低功耗的嵌入式设备。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RISC 设计使得 MIPS 执行效率高，适合于实时操作系统。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">易于学习，因此常被用于教育和科研。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">典型处理器：现代嵌入式芯片如一些路由器芯片，早期的 Silicon Graphics 工作站。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IBM </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mainframe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (z</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Architecture)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者：IBM</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：IBM 专有架构，设计用于高可靠性和高吞吐量的任务。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">应用：主要在银行、保险、政府等需要处理大量数据的关键任务领域。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">优点：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">高可靠性和高性能，特别适合大规模数据处理和事务处理。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">强大的虚拟化能力和并行处理能力。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">支持复杂的数据加密和安全功能，确保关键任务数据的安全性。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">典型处理器：IBM Z 系列处理器。</span></span></code></pre></div><h1 id="%E4%B8%80%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" tabindex="-1">一 程序的基本概念 <a class="header-anchor" href="#一 程序的基本概念" aria-label="Permalink to &quot;一 程序的基本概念&quot;">​</a></h1><h2 id="1.%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8" tabindex="-1">1.编译器和解释器 <a class="header-anchor" href="#1.编译器和解释器" aria-label="Permalink to &quot;1.编译器和解释器&quot;">​</a></h2><p>解释器和编译器是两种将高级编程语言转换为机器语言（计算机能够直接执行的二进制代码）的工具，它们的主要区别在于转换和执行的方式。</p><ol><li><strong>编译器</strong>： <ul><li>编译器在程序执行之前，先将整个源代码一次性翻译成机器码（通常是可执行文件）。编译过程完成后，生成的机器码就可以独立运行，不再需要编译器的参与。</li><li>编译器通常进行语法检查、优化代码等过程，以提高程序运行效率。</li><li>优点：由于机器码在运行时不需要进一步翻译，编译后的程序执行速度通常较快。</li><li>缺点：调试比较麻烦，每次修改源代码后需要重新编译。</li><li>示例语言：C、C++、Fortran。</li></ul></li><li><strong>解释器</strong>： <ul><li>解释器逐行翻译和执行源代码，它不生成独立的可执行文件。每次执行时，解释器都会实时将代码翻译成机器码并立即执行。</li><li>解释器直接在运行时处理代码，通常提供更方便的调试和测试体验。</li><li>优点：可以快速测试和调试代码，不需要编译整个程序。</li><li>缺点：因为需要逐行翻译，程序执行速度相对于编译器生成的可执行程序较慢。</li><li>示例语言：Python、JavaScript、Ruby。</li></ul></li></ol><p>总结：编译器将整个程序一次性转换为可执行文件，解释器则逐行解释执行代码。编译器生成的程序执行效率更高，而解释器在开发和调试过程中更加灵活方便。</p><h2 id="2.%E5%85%B3%E4%BA%8EToken%E7%9A%84%E8%A7%84%E5%88%99%E7%A7%B0%E4%B8%BA%E8%AF%8D%E6%B3%95%EF%BC%88Lexical%EF%BC%89%E8%A7%84%E5%88%99%EF%BC%8C%E8%80%8C%E5%85%B3%E4%BA%8E%E7%BB%93%E6%9E%84%E7%9A%84%E8%A7%84%E5%88%99%E7%A7%B0%E4%B8%BA%E8%AF%AD%E6%B3%95%EF%BC%88Grammar%EF%BC%89%E8%A7%84%E5%88%99" tabindex="-1">2.关于Token的规则称为词法（Lexical）规则，而关于结构的规则称为语法（Grammar）规则 <a class="header-anchor" href="#2.关于Token的规则称为词法（Lexical）规则，而关于结构的规则称为语法（Grammar）规则" aria-label="Permalink to &quot;2.关于Token的规则称为词法（Lexical）规则，而关于结构的规则称为语法（Grammar）规则&quot;">​</a></h2><ol><li><p>词法（Lexical）规则</p><p>：</p><ul><li>词法规则是关于如何将输入的字符序列分割成有意义的最小单元（即Token）的规则。Token 是程序中最小的语义单位，比如关键字、标识符、运算符、数字、分隔符等。</li><li>词法分析（Lexical Analysis）是编译器或解释器的第一步，它根据词法规则扫描源代码，将其转换为Token序列。这一步的任务就是识别代码中的不同类型的Token。</li><li>词法规则通常涉及字符集、字符串模式、正则表达式等。</li></ul></li><li><p>语法（Grammar）规则</p><p>：</p><ul><li>语法规则定义了Token如何组合成合法的语句或表达式。它们描述了编程语言的结构，也就是如何组织Token来形成符合语言规范的程序。</li><li>语法分析（Parsing）是编译器的第二步，它根据语法规则检查Token序列的结构，并确定是否符合语言的语法。这一步的结果通常是生成一个语法树（parse tree）或抽象语法树（AST），用于后续的编译或解释过程。</li><li>语法规则常使用上下文无关文法（Context-Free Grammar, CFG）来定义，例如巴科斯范式（BNF）。</li></ul></li></ol><p>简单来说：</p><ul><li><strong>词法规则</strong>处理的是<strong>Token</strong>（即最小的语义单位），它定义了如何识别这些基本元素。</li><li><strong>语法规则</strong>处理的是<strong>Token的组合</strong>，它定义了这些基本元素如何按照正确的顺序构成合法的结构或程序。</li></ul><p>语法（Syntax） 符号（Token） 词法（Lexical） 语法（Grammar） 解析（Parse） 上下文（Context） 语义（Semantic） 歧义性（Ambiguity） 冗余性（Redundancy） 隐喻（Metaphor） 字面（Literal）</p><p>结构很重要，从上到下从左到右读往往不是一个好办法，而应该学会在大脑里解析：识别Token，分解结构。</p><p>Syntax和Grammar通常都翻译成“语法”，这让初学者非常混乱，Syntax的含义其实包含了Lexical和Grammar的规则，还包含一部分语义的规则，例如在C程序中变量应先声明后使用。即使在英文的文献中Syntax和Grammar也常混用，在有些文献中Syntax的含义不包括Lexical规则，只要注意上下文就不会误解。</p><h2 id="3.%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95" tabindex="-1">3.程序的调试 <a class="header-anchor" href="#3.程序的调试" aria-label="Permalink to &quot;3.程序的调试&quot;">​</a></h2><p>臭虫（Bug） 调试（Debug）</p><p>编译时错误</p><p>该错误很容易解决, 大多是语法错误</p><p>运行时错误 (run-time)</p><p>好好区分明白这两种错误</p><p>逻辑错误和语义错误</p><hr><h1 id="%E4%BA%8C%20c%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80" tabindex="-1">二 c语法基础 <a class="header-anchor" href="#二 c语法基础" aria-label="Permalink to &quot;二 c语法基础&quot;">​</a></h1><h2 id="1.c%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2" tabindex="-1">1.c的字符串 <a class="header-anchor" href="#1.c的字符串" aria-label="Permalink to &quot;1.c的字符串&quot;">​</a></h2><p>唯一值得注意的一个东西 %s 打印 字符串形式数组</p><p>&quot;hzh&quot; 是一个字符串 ,但是其本身其实占用了4个字节, 因为有 \0 作为终止条件</p><p>char str[]=&quot;hzh&quot; 最好不要指定长度, 容易漏掉 \0 , 当漏掉了 \0 ,还要用 %s 打印 字符串数组 时, 由于没有终止条件Null字符, 会访问数组越界</p><h2 id="2.%E5%B1%80%E9%83%A8%E8%BE%B9%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98" tabindex="-1">2.局部边量初始化问题 <a class="header-anchor" href="#2.局部边量初始化问题" aria-label="Permalink to &quot;2.局部边量初始化问题&quot;">​</a></h2><p>如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定的。所以，<em>局部变量在使用之前一定要先赋值</em>，如果基于一个不确定的值做后续计算肯定会引入Bug。</p><p>全局变量可以不初始化,但是局部变量必须初始化!!</p><hr><h1 id="%E4%B8%89%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83" tabindex="-1">三 编码规范 <a class="header-anchor" href="#三 编码规范" aria-label="Permalink to &quot;三 编码规范&quot;">​</a></h1><h2 id="1.indent%E5%B7%A5%E5%85%B7" tabindex="-1">1.indent工具 <a class="header-anchor" href="#1.indent工具" aria-label="Permalink to &quot;1.indent工具&quot;">​</a></h2><p>自动格式化代码规范!</p><p>一般 win是 i4 即tab键 代表几个空格 这个是缩进的意思</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>indent -kr -i8  .c  -o  目标   linux多i8,   还可以</span></span></code></pre></div><hr><h1 id="%E5%9B%9B%20gdb%E8%B0%83%E8%AF%95" tabindex="-1">四 gdb调试 <a class="header-anchor" href="#四 gdb调试" aria-label="Permalink to &quot;四 gdb调试&quot;">​</a></h1><p>类似于 python 的 ipdb 或者 pdb 命令很多一样</p><h2 id="1.%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8" tabindex="-1">1.单步执行和跟踪函数调用 <a class="header-anchor" href="#1.单步执行和跟踪函数调用" aria-label="Permalink to &quot;1.单步执行和跟踪函数调用&quot;">​</a></h2><p>首先, 必须在编译时 加入 -g 选项, 生成最终的 可执行文件</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gcc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g test.c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">o testgdb      testgdb  是有 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g 的可执行文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">然后才能 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gdb testgdb  才能调试</span></span></code></pre></div><p>-g 的作用是 在可执行文件中加入源代码的信息, 比如 可执行文件中第几条机器指令对应源代码的第几行 ,但并不是把整个源文件嵌入到可执行文件中 ,所以调试时必须保证gdb能找到源文件</p><p><code>gdb</code>提供一个类似Shell的命令行环境</p><p><code>list 1</code>表示 一次只列出 10行, 再次 <code>list</code>则是列出 11行之后 缩写 l</p><p>还可以 <code>l 函数名</code> 直接列出函数源代码</p><p><code>start</code> 开始执行程序</p><p>next n 下一步</p><p>step s 进入函数</p><p>quit q 退出</p><p><code>backtrace</code> <code>bt</code>可以查看函数调用的栈帧</p><p><code>info</code>命令（简写为<code>i</code>）查看<code>add_range</code>函数局部变量的值</p><p>i locals 显示当前函数所有局部变量的值</p><p><code>main</code>函数当前局部变量的值也可以做到，先用<code>frame</code>命令（简写为<code>f</code>）选择1号栈帧然后再查看局部变量：</p><p><code>print</code>命令（简写为<code>p</code>）打印出变量 的值 还可以修改变量的值, p ..=.. 就可以了</p><p><code>$1</code>表示<code>gdb</code>保存着这些中间结果，$后面的编号会自动增长，在命令中可以用<code>$1</code>、<code>$2</code>、<code>$3</code>等编号代替相应的值</p><p><code>finish</code>命令让程序一直运行到从当前函数返回为止</p><p>set var 就是 set variable 修改变量的值的缩写</p><p>函数里局部变量如果没有初始化,值是不确定的, 而且如果连续调用 函数, 将会继承 函数上一次执行完的 局部变量的值, 很危险!!!!!</p><h3 id="gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A41" tabindex="-1">gdb调试基本命令1 <a class="header-anchor" href="#gdb调试基本命令1" aria-label="Permalink to &quot;gdb调试基本命令1&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">backtrace（或bt）</td><td style="text-align:left;">查看各级函数调用及参数 以及当前在哪一行&lt;br /&gt;在调试 程序崩溃 和 段错误 非常有用, 可以找到调用链</td></tr><tr><td style="text-align:left;">finish</td><td style="text-align:left;">连续运行到当前函数返回为止，然后停下来等待命令</td></tr><tr><td style="text-align:left;">frame（或f） 帧编号</td><td style="text-align:left;">选择栈帧&lt;br /&gt;结合 bt 使用, 用于切换或者查看 当前调用栈的特定帧(函数调用)</td></tr><tr><td style="text-align:left;">info（或i） locals</td><td style="text-align:left;">查看当前栈帧局部变量的值</td></tr><tr><td style="text-align:left;">list（或l）</td><td style="text-align:left;">列出源代码，接着上次的位置往下列，每次列10行</td></tr><tr><td style="text-align:left;">list 行号</td><td style="text-align:left;">列出从第几行开始的源代码</td></tr><tr><td style="text-align:left;">list 函数名</td><td style="text-align:left;">列出某个函数的源代码</td></tr><tr><td style="text-align:left;">next（或n）</td><td style="text-align:left;">执行下一行语句</td></tr><tr><td style="text-align:left;">print（或p）</td><td style="text-align:left;">打印表达式的值，通过表达式可以修改变量的值或者调用函数</td></tr><tr><td style="text-align:left;">quit（或q）</td><td style="text-align:left;">退出<code>gdb</code>调试环境</td></tr><tr><td style="text-align:left;">set var</td><td style="text-align:left;">修改变量的值</td></tr><tr><td style="text-align:left;">start</td><td style="text-align:left;">开始执行程序，停在<code>main</code>函数第一行语句前面等待命令</td></tr><tr><td style="text-align:left;">step（或s）</td><td style="text-align:left;">执行下一行语句，如果有函数调用则进入到函数中</td></tr></tbody></table><h2 id="2.%E6%96%AD%E7%82%B9breakpoints" tabindex="-1">2.断点breakpoints <a class="header-anchor" href="#2.断点breakpoints" aria-label="Permalink to &quot;2.断点breakpoints&quot;">​</a></h2><h3 id="gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A42" tabindex="-1">gdb调试基本命令2 <a class="header-anchor" href="#gdb调试基本命令2" aria-label="Permalink to &quot;gdb调试基本命令2&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">break（或b） 行号</td><td style="text-align:left;">在某一行设置断点</td></tr><tr><td style="text-align:left;">break 函数名</td><td style="text-align:left;">在某个函数开头设置断点</td></tr><tr><td style="text-align:left;">break … if …</td><td style="text-align:left;">设置条件断点</td></tr><tr><td style="text-align:left;">continue（或c）</td><td style="text-align:left;">从当前位置开始连续运行程序</td></tr><tr><td style="text-align:left;">delete breakpoints 断点号</td><td style="text-align:left;">删除断点</td></tr><tr><td style="text-align:left;">display 变量名</td><td style="text-align:left;">跟踪查看某个变量，每次停下来都显示它的值</td></tr><tr><td style="text-align:left;">disable breakpoints 断点号</td><td style="text-align:left;">禁用断点</td></tr><tr><td style="text-align:left;">enable 断点号</td><td style="text-align:left;">启用断点</td></tr><tr><td style="text-align:left;">info（或i） breakpoints</td><td style="text-align:left;">查看当前设置了哪些断点</td></tr><tr><td style="text-align:left;">run（或r）</td><td style="text-align:left;">从头开始连续运行程序</td></tr><tr><td style="text-align:left;">undisplay 跟踪显示号</td><td style="text-align:left;">取消跟踪显示</td></tr></tbody></table><h2 id="3.%E8%A7%82%E5%AF%9F%E7%82%B9%20watchpoints" tabindex="-1">3.观察点 watchpoints <a class="header-anchor" href="#3.观察点 watchpoints" aria-label="Permalink to &quot;3.观察点 watchpoints&quot;">​</a></h2><p>断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有用。</p><table tabindex="0"><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">watch</td><td style="text-align:left;">设置观察点</td></tr><tr><td style="text-align:left;">info（或i） watchpoints</td><td style="text-align:left;">查看当前设置了哪些观察点</td></tr><tr><td style="text-align:left;">x</td><td style="text-align:left;">从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量</td></tr></tbody></table><p>x/7b input input是一个数组名</p><p><code>x</code>命令打印指定存储单元的内容。<code>7b</code>是打印格式，<code>b</code>表示每个字节一组，7表示打印7组[<a href="https://www.bookstack.cn/read/linux-c/b7171caee4e952d7.md#ftn.id2742046" target="_blank" rel="noreferrer">22</a>]，从<code>input</code>数组的第一个字节开始连续打印7个字节。</p><h2 id="4.%E6%AE%B5%E9%94%99%E8%AF%AF(%E6%8C%96%E4%BA%86%E5%87%A0%E4%B8%AA%E5%9D%91%20%E5%90%8E%E7%BB%AD%E8%AE%B2)" tabindex="-1">4.段错误(挖了几个坑 后续讲) <a class="header-anchor" href="#4.段错误(挖了几个坑 后续讲)" aria-label="Permalink to &quot;4.段错误(挖了几个坑 后续讲)&quot;">​</a></h2><p>中文:段错误</p><p>英文:segmentation fault</p><p>一般这个错误, 就是直接显示 段错误</p><p>开始从头调试, 段错误 在 调试时, 会在错误的地方 停下来 ,此时 使用 bt 查看栈帧信息 ,错误就在这个调用链里</p><hr><h1 id="%E4%BA%94%201-4%E6%80%BB%E7%BB%93(%E8%BF%98%E6%9C%AA%E7%9C%8B)" tabindex="-1">五 1-4总结(还未看) <a class="header-anchor" href="#五 1-4总结(还未看)" aria-label="Permalink to &quot;五 1-4总结(还未看)&quot;">​</a></h1><p>第一阶段总结, 有好多问题, 还没看</p><hr><h1 id="%E5%85%AD%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA" tabindex="-1">六 计算机中数的表示 <a class="header-anchor" href="#六 计算机中数的表示" aria-label="Permalink to &quot;六 计算机中数的表示&quot;">​</a></h1><p>计组中的知识</p><p>有门电路,一位全加器,浮点数的ieee754标准</p><hr><h1 id="%E5%85%AB%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3" tabindex="-1">八 数据类型详解 <a class="header-anchor" href="#八 数据类型详解" aria-label="Permalink to &quot;八 数据类型详解&quot;">​</a></h1><h2 id="1.%E6%95%B4%E5%9E%8B" tabindex="-1">1.整型 <a class="header-anchor" href="#1.整型" aria-label="Permalink to &quot;1.整型&quot;">​</a></h2><p>有符号 和 无符号 signed 和 unsigned</p><p>char 的有符号和无符号</p><p>许多详细的点 需要结合 具体的编译器而定, 脱离了编译器 谈 c 的细节 就是耍流氓</p><p>在C标准中没有做明确规定的地方会用Implementation-defined、Unspecified或Undefined来表述, 统称为 未明确定义</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">C标准没有明确规定char是有符号的还是无符号的，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">---</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">implementation_define</span></span></code></pre></div><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">对于Unspecified的情况，往往有几种可选的处理方式，C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式</span></span></code></pre></div><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Undefined的情况则是完全不确定的，C标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，有很多Undefined的情况编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是Undefined的。</span></span></code></pre></div><p>x86平台上<code>int</code>的取值范围是-2147483648~2147483647，那么用<code>printf(&quot;%d\n&quot;, -2147483648);</code></p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">有些平台编译器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">warning: format ‘</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d’ expects type ‘</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">’, but argument </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> has type ‘</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">’</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">会警告,  比如 linux 下的 gcc</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">直接使用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2147483648</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 警告的编译器会解释成 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2147483648</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ,然而没有 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2147483648</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 数存在 产生了溢出</span></span></code></pre></div><p>还有 ll i = 123456789 * 123456789</p><p>也会警告, int * int 是 int , 想要消除警告, 就必须 进行 ll int 参与进去 修改 123456789ll * 123456789</p><h2 id="2.%E6%B5%AE%E7%82%B9%E5%9E%8B" tabindex="-1">2.浮点型 <a class="header-anchor" href="#2.浮点型" aria-label="Permalink to &quot;2.浮点型&quot;">​</a></h2><p><code>long double</code>型通常是比<code>double</code>型精度更高的类型，但各平台的实现有较大差异。在x86平台上，大多数编译器实现的<code>long double</code>型是80位，因为x86的浮点运算单元具有80位精度，<code>gcc</code>实现的<code>long double</code>型是12字节（96位），这是为了对齐到4字节边界（在<a href="https://www.bookstack.cn/read/linux-c/2aa8e59e2d2873d2.md#asmc.structunion" target="_blank" rel="noreferrer">第 4 节 “结构体和联合体”</a>详细讨论对齐的问题），也有些编译器实现的<code>long double</code>型和<code>double</code>型精度相同，没有充分利用x86浮点运算单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如PowerPC上的<code>long double</code>型通常是128位。</p><h2 id="3.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2(%E5%BE%88%E4%B9%B1%2C%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF)" tabindex="-1">3.类型转换(很乱,了解即可) <a class="header-anchor" href="#3.类型转换(很乱%2C了解即可)" aria-label="Permalink to &quot;3.类型转换(很乱,了解即可)&quot;">​</a></h2><p>了解有符号数和无符号数混用会非常麻烦，从而避免触及这些规则，并且在程序出错时记得往这上面找原因。所以这些规则不需要牢记，但要知道有这么回事，以便在用到的时候能找到我书上的这一段</p><p>+ - * / % &gt; &lt; &gt;= &lt;= == !=运算符都需要做Usual Arithmetic Conversion (通常算术转换) 要求两边操作数的类型一致</p><p>单目运算符+ - ~只有一个操作数，移位运算符&lt;&lt; &gt;&gt;两边的操作数类型不要求一致，这些运算不需要做Usual Arithmetic Conversion，但也需要做Integer Promotion(整数提升), 就是隐式转换规则</p><p>注意: char = getchar() getchar返回值并不是char, 而是int</p><p>强制转换</p><hr><h1 id="%E4%B9%9D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%A6%E8%A7%A3" tabindex="-1">九 运算符详解 <a class="header-anchor" href="#九 运算符详解" aria-label="Permalink to &quot;九 运算符详解&quot;">​</a></h1><h2 id="1.%E4%BD%8D%E8%BF%90%E7%AE%97" tabindex="-1">1.位运算 <a class="header-anchor" href="#1.位运算" aria-label="Permalink to &quot;1.位运算&quot;">​</a></h2><p>总结: 建议只对 无符号数 做 移位运算</p><p>有些信息 必须通过 访问位 才能得到</p><p>例如 UTF-8编码</p><p>&amp; | ~ ^</p><p>不同类型 位运算 需要 注意类型转换的细节!!!</p><p>&lt;&lt; &gt;&gt; 左右移 运算</p><p>在一定的 取值范围内, &lt;&lt; 一位, 相当于乘2 , 比乘法快的多</p><p>右移,无符号数,添0</p><p>有符号数,正数 添0, 负数,不一定添0或者添1, gcc保持了最高位添1,使得 即使是负数,也可以是 除2</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cffffff3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%x\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cffffff3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%x\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">编译器 一般是将 </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">0x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,,, 直接视为 常量, 进行逻辑右移(只添0), 而不是算术右移(与正负有关)</span></span></code></pre></div><h2 id="2.%E5%85%B6%E5%AE%83%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">2.其它运算符 <a class="header-anchor" href="#2.其它运算符" aria-label="Permalink to &quot;2.其它运算符&quot;">​</a></h2><p>复合赋值运算符</p><p>+= -= /= *= 等等 这个 只求值一次, 而 拆开,则是求职两次</p><p>条件运算符 ? :</p><p>逗号运算符</p><p>(表达式1,表达式2) 作为参数传入的话, 只传入表达式2, 1被舍弃</p><p>sizeof运算符</p><p>size 表达式 和 sizeof(类型名) 两种形式</p><p>第一个可以写成sizeof(表达式), 类似 return(1), 括号不起作用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int a[12];</span></span>
<span class="line"><span>printf(&quot;%d\n&quot;, sizeof a/sizeof a[0]);</span></span></code></pre></div><p>在上面这个例子中，由于<code>sizeof 表达式</code>中的子表达式不需要求值，所以不需要到运行时才计算，事实上在编译时就知道<code>sizeof a</code>的值是48，<code>sizeof a[0]</code>的值是4，所以在编译时就已经把<code>sizeof a/sizeof a[0]</code>替换成常量12了，这是一个常量表达式。</p><p>注意:</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sizeof 的结果是一个 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这个类型定义在stddef.h头文件中，不过你的代码中只要不出现size_t这个类型名就不用包含这个头文件，比如像上面的例子就不用包含这个头文件。C标准规定size_t是一种无符号整型，编译器可以用typedef做一个类型声明：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">那么 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 就代表 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 型。不同平台的编译器可能会根据自己平台的具体情况定义 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 所代表的类型，比如有的平台定义为 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 型，有的平台定义为 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 型，C标准规定size_t这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要把size_t类型和它所代表的真实类型混用，例如：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 高位细节丢失</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef char array_t[10];array_t a;</span></span></code></pre></div><p>这相当于声明<code>char a[10];</code> 好好理解这个代码, 这个有点不懂</p><h2 id="3.side%20effect(%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8)%E5%92%8Csequence%20point(c%2Fc%2B%2B%E4%B8%AD%E7%9A%84%20%E9%A1%BA%E5%BA%8F%E7%82%B9)" tabindex="-1">3.side effect(编程中的副作用)和sequence point(c/c++中的 顺序点) <a class="header-anchor" href="#3.side effect(编程中的副作用)和sequence point(c%2Fc%2B%2B中的 顺序点)" aria-label="Permalink to &quot;3.side effect(编程中的副作用)和sequence point(c/c++中的 顺序点)&quot;">​</a></h2><p>面试题 的 hr 钻牛角尖 专用, 折磨应聘的人</p><p>side effect 在编程中指 一个表达式或函数 除了返回值之外还会对程序的状态和环境造成变化,例如修改变量,写入文件,更新数据结构等</p><p>sequence point 顺序点, 用于定义表达式中各个操作的执行顺序, 在一个顺序点之前的所有 副作用 必须在到达这个顺序点之前完成,顺序点之后的操作不会影响之前的结果</p><p>有点 云里雾里</p><p>i=i+1 这是正确的</p><p>a[i++]=i 这是 未定义 undefine 行为 也可能是 正确的, 说法不一</p><p>主要问题是, 在 = 号时, 究竟是确定的 先左后右,还是先右后左, 如果这个不确定, 那就是 未定义 行为了</p><h2 id="4.%E6%80%BB%E7%BB%93" tabindex="-1">4.总结 <a class="header-anchor" href="#4.总结" aria-label="Permalink to &quot;4.总结&quot;">​</a></h2><p>a?b:c?d:e 在c 中, 是 a?b(c?d:e)</p><p>语法规则 实际上不是 由 优先性 和 结合性 表述的, 有些细节 用这两个解释不了, 看c标准才能理解!</p><hr><h1 id="%E5%8D%81%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80(%E8%8B%B1%E6%96%87%E6%9C%AF%E8%AF%AD%E5%A4%9A%2C%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86)" tabindex="-1">十 计算机体系结构基础(英文术语多,计组知识) <a class="header-anchor" href="#十 计算机体系结构基础(英文术语多%2C计组知识)" aria-label="Permalink to &quot;十 计算机体系结构基础(英文术语多,计组知识)&quot;">​</a></h1><p>Von Neumann冯诺依曼 体系结构</p><p>这种体系结构的主要特点是：CPU（CPU，Central Processing Unit，中央处理器，或简称处理器Processor）和内存（Memory）是计算机的两个主要组成部分，内存中保存着数据和指令，CPU从内存中取指令（Fetch）执行，其中有些指令让CPU做运算，有些指令让CPU读写内存中的数据。</p><h2 id="1.CPU" tabindex="-1">1.CPU <a class="header-anchor" href="#1.CPU" aria-label="Permalink to &quot;1.CPU&quot;">​</a></h2><p>1.寄存器 register x86的寄存器<code>eax</code>、<code>esp</code>、<code>eip</code>等等</p><p><code>eip</code>用作程序计数器，这称为特殊寄存器（Special-purpose Register），而另外一些寄存器可以用在各种运算和读写内存的指令中，比如<code>eax</code>寄存器，这称为通用寄存器（General-purpose Register）。</p><p>2.程序计数器 PC Program Counter</p><p>是一种特殊寄存器，保存着CPU取下一条指令的地址，CPU按程序计数器保存的地址去内存中取指令然后解释执行，这时程序计数器保存的地址会自动加上该指令的长度，指向内存中的下一条指令。</p><p>3.指令译码器（Instruction Decoder）</p><p>CPU取上来的指令由若干个字节组成，这些字节中有些位表示内存地址，有些位表示寄存器编号，有些位表示这种指令做什么操作，是加减乘除还是读写内存，指令译码器负责解释这条指令的含义，然后调动相应的执行单元去执行它。</p><p>4.算术逻辑单元（ALU，Arithmetic and Logic Unit）</p><p>如果译码器将一条指令解释为运算指令，就调动算术逻辑单元去做运算，比如加减乘除、位运算、逻辑运算。指令中会指示运算结果保存到哪里，可能保存到寄存器中，也可能保存到内存中。</p><p>5.地址和数据总线（Bus）</p><p>CPU和内存之间用地址总线、数据总线和控制线连接起来，每条线上有1和0两种状态。</p><p>字 word 半字 half word 处理器的字长</p><p>地址线、数据线是指CPU的内总线，是直接和CPU的执行单元相连的，内总线经过MMU和总线接口的转换之后引出到芯片引脚才是外总线，外地址线和外数据线的位数都有可能和内总线不同</p><p>对于多字节的整数类型，低地址保存的是整数的低位，这称为<code>小端（Little Endian）字节序（Byte Order）</code>。x86平台是小端字节序的，而另外一些平台规定低地址保存整数的高位，称为<code>大端（Big Endian）字节序</code>。</p><h2 id="2.%E8%AE%BE%E5%A4%87" tabindex="-1">2.设备 <a class="header-anchor" href="#2.设备" aria-label="Permalink to &quot;2.设备&quot;">​</a></h2><p>设备中可供读写访问的单元通常称为<code>设备寄存器（注意和CPU寄存器不是一回事）</code>，操作设备的过程就是读写这些设备寄存器的过程，比如向串口发送寄存器里写数据，串口设备就会把数据发送出去，读串口接收寄存器的值，就可以读取串口设备接收到的数据。</p><p>从CPU核引出的地址和数据总线有一端经总线接口引出到芯片引脚上了，还有一端没有引出，而是接到芯片内部集成的设备上，无论是在CPU外部接总线的设备还是在CPU内部接总线的设备都有各自的地址范围，都可以像访问内存一样访问，</p><p>很多体系结构（比如ARM）采用这种方式操作设备，称为<code>内存映射I/O（Memory-mapped I/O）</code>。</p><p>但是x86比较特殊，x86对于设备有独立的端口地址空间，CPU核需要引出额外的地址线来连接片内设备（和访问内存所用的地址线不同），访问设备寄存器时用特殊的<code>in</code>/<code>out</code>指令，而不是和访问内存用同样的指令，这种方式称为<code>端口I/O（Port I/O）</code></p><p>从CPU的角度来看，访问设备只有内存映射I/O和端口I/O两种，要么像内存一样访问，要么用一种专用的指令访问。</p><p>其实访问设备是相当复杂的，计算机的设备五花八门，<code>各种设备的性能要求都不一样，有的要求带宽大，有的要求响应快，有的要求热插拔</code>，于是出现了各种适应不同要求的设备总线，比如<code>PCI、AGP、USB、1394、SATA</code>等等，这些设备总线并不直接和CPU相连，<code>CPU通过内存映射I/O或端口I/O访问相应的总线控制器</code>，通过总线控制器再去访问挂在总线上的设备。</p><p>在x86平台上，硬盘是挂在IDE、SATA或SCSI总线上的设备</p><p>保存在硬盘上的程序是不能被CPU直接取指令执行的，操作系统在执行程序时会把它从硬盘拷贝到内存，这样CPU才能取指令执行，这个过程称为<code>加载（Load）</code></p><p>程序加载到内存之后，成为操作系统调度执行的一个任务，就称为<code>进程（Process）</code></p><p>进程和程序<code>不是一一对应</code>的。一个程序可以多次加载到内存，成为同时运行的多个进程，例如可以同时开多个终端窗口，每个窗口都运行一个Shell进程，而它们对应的程序都是磁盘上的<code>/bin/bash</code>文件。</p><p><code>操作系统（Operating System）</code>本身也是一段保存在磁盘上的程序，计算机在启动时执行一段固定的<code>启动代码（称为Bootloader）</code></p><p>操作系统和其它用户程序的不同之处在于：<code>操作系统是常驻内存的</code>，而其它用户程序则不一定</p><p><code>操作系统最核心</code>的功能是<code>管理进程调度、管理内存的分配使用和管理各种设备</code>，做这些工作的程序称为<code>内核（Kernel）</code>，在我的系统上内核程序是<code>/boot/vmlinuz-2.6.28-13-generic</code>文件，它在计算机启动时加载到内存并常驻内存。<code>广义上</code>操作系统的概念还包括一些必不可少的用户程序，比如Shell是每个Linux系统必不可少的，而Office办公套件则是可有可无的，所以前者也属于广义上操作系统的范畴，而后者属于应用软件。</p><p>键盘设备主动通知CPU来读这个字符并做相应处理，给用户响应。这是由<code>中断（Interrupt）机制</code>实现的，每个设备都有一条中断线，通过中断控制器连接到CPU，当设备需要主动通知CPU时就引发一个中断信号，CPU正在执行的指令将被打断，程序计数器会指向某个固定的地址（这个地址由体系结构定义），于是CPU从这个地址开始取指令（或者说跳转到这个地址），执行<code>中断服务程序（ISR，Interrupt Service Routine）</code>，完成中断处理之后再返回先前被打断的地方执行后续指令。</p><p>由于各种设备的操作方法各不相同，每种设备都需要专门的<code>设备驱动程序（Device Driver）</code>，一个操作系统为了支持广泛的设备就需要有大量的设备驱动程序，事实上Linux内核源代码中绝大部分是设备驱动程序。设备驱动程序通常是<code>内核里的一组函数</code>，通过读写设备寄存器实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供ISR调用。</p><h2 id="3.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8EMMU" tabindex="-1">3.虚拟内存与MMU <a class="header-anchor" href="#3.虚拟内存与MMU" aria-label="Permalink to &quot;3.虚拟内存与MMU&quot;">​</a></h2><p>现代操作系统普遍采用<code>虚拟内存管理（Virtual Memory Management）</code>机制，这需要处理器中的<code>MMU（Memory Management Unit，内存管理单元）</code>提供支持</p><p>MMU将<code>VA(虚拟地址Virtual Address)</code>映射到<code>PA(Physical Address 物理地址)</code>是以<code>页（Page）</code>为单位的，<code>32位处理器的页尺寸通常是4KB</code>。例如，MMU可以通过一个映射项将VA的一页0xb7001000~0xb7001fff映射到PA的一页0x2000~0x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。物理内存中的页称为<code>物理页面或者页帧（Page Frame）</code>。虚拟内存的哪个页面映射到物理内存的哪个页帧是通过<code>页表（Page Table）</code>来描述的，页表保存在物理内存中，MMU会查找页表来确定一个VA应该映射到什么PA。</p><p>MMU除了做地址转换之外，还提供<code>内存保护机制</code>。各种体系结构都有<code>用户模式（User Mode）</code>和<code>特权模式（Privileged Mode）</code>之分，操作系统可以在页表中设置每个内存页面的访问权限，有些页面不允许访问，有些页面只有在CPU处于特权模式时才允许访问，有些页面在用户模式和特权模式都可以访问，<code>访问权限又分为可读、可写和可执行三种</code>。</p><p><code>异常（Exception）</code>。异常的处理过程和中断类似，不同的是中断由外部设备产生而异常由CPU内部产生，中断产生的原因和CPU当前执行的指令无关，而异常的产生就是由于CPU当前执行的指令出了问题，例如访问内存的指令被MMU检查出权限错误，除法指令的除数为0等都会产生异常。</p><p>通常操作系统把<code>虚拟地址空间</code>划分为<code>用户空间和内核空间</code>，例如<code>x86平台</code>的<code>Linux系统</code>虚拟地址空间是<code>0x00000000~0xffffffff</code>，<code>前3GB</code>（0x00000000~0xbfffffff）是<code>用户空间</code>，<code>后1GB</code>（0xc0000000~0xffffffff）是<code>内核空间</code>。</p><p>用户程序加载到用户空间，在用户模式下执行，不能访问内核中的数据，也不能跳转到内核代码中执行。这样可以<code>保护内核</code>，如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性</p><p>在正常情况下处理器在用户模式执行用户程序，在<code>中断或异常情况下</code>处理器<code>切换</code>到<code>特权模式</code>执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。</p><p><code>段错误我们已经遇到过很多次了，它是这样产生的：</code></p><ol><li><code>用户程序要访问的一个VA，经MMU检查无权访问。</code></li><li><code>MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序。</code></li><li><code>内核把这个异常解释为段错误，把引发异常的进程终止掉。</code></li></ol><p>VA</p><p><strong>扩展内存容量</strong>：虚拟内存结合磁盘，提供比物理内存更大的可用空间。</p><p><strong>内存隔离和安全</strong>：为每个进程提供独立的地址空间，防止进程间互相干扰。</p><p><strong>提高资源利用率</strong>：支持按需加载，仅加载必要数据，节省物理内存。</p><p><strong>简化内存管理</strong>：程序使用统一的虚拟地址空间，操作系统动态分配物理内存。</p><p><strong>支持数据共享和内存映射</strong>：支持多进程共享内存区域和文件内存映射操作。</p><p><strong>提高系统稳定性</strong>：通过分页和保护机制，防止非法访问并增强多任务稳定性。</p><h2 id="4.Memory%20Hierarchy%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84" tabindex="-1">4.Memory Hierarchy内存层次结构 <a class="header-anchor" href="#4.Memory Hierarchy内存层次结构" aria-label="Permalink to &quot;4.Memory Hierarchy内存层次结构&quot;">​</a></h2><p>cache 缓存</p><table tabindex="0"><thead><tr><th style="text-align:left;">存储器类型</th><th style="text-align:left;">位于哪里</th><th style="text-align:left;">存储容量</th><th style="text-align:left;">半导体工艺</th><th style="text-align:left;">访问时间</th><th style="text-align:left;">如何访问</th></tr></thead><tbody><tr><td style="text-align:left;">CPU寄存器</td><td style="text-align:left;">位于CPU执行单元中。</td><td style="text-align:left;">CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节。</td><td style="text-align:left;">“寄存器”这个名字就是一种数字电路的名字，它由一组触发器（Flip-flop）组成，每个触发器保存一个Bit的数据，可以做存取和移位等操作。计算机掉电时寄存器中保存的数据会丢失。</td><td style="text-align:left;">寄存器是访问速度最快的存储器，典型的访问时间是几纳秒。</td><td style="text-align:left;">使用哪个寄存器，如何使用寄存器，这些都是由指令决定的。</td></tr><tr><td style="text-align:left;">Cache</td><td style="text-align:left;">和MMU一样位于CPU核中。</td><td style="text-align:left;">Cache通常分为几级，最典型的是如上图所示的两级Cache，一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB。</td><td style="text-align:left;">Cache和内存都是由RAM（Random Access Memory）组成的，可以根据地址随机访问，计算机掉电时RAM中保存的数据会丢失。不同的是，Cache通常由SRAM（Static RAM，静态RAM）组成，而内存通常由DRAM（Dynamic RAM，动态RAM）组成。DRAM电路比SRAM简单，存储容量可以做得更大，但DRAM的访问速度比SRAM慢。</td><td style="text-align:left;">典型的访问时间是几十纳秒。</td><td style="text-align:left;">Cache缓存最近访问过的内存数据，由于Cache的访问速度是内存的几十倍，所以有效利用Cache可以大大提高计算机的整体性能。一级Cache是这样工作的：CPU执行单元要访问内存时首先发出VA，Cache利用VA查找相应的数据有没有被缓存，如果Cache中有就不需要访问物理内存了，如果是读操作就直接将Cache中的数据传给CPU寄存器，如果是写操作就直接改写到Cache中；如果Cache没有缓存该数据，就去物理内存中取数据，但并不是要哪个字节就取哪个字节，而是把相邻的几十个字节都取上来缓存着，以备下次用到，这称为一个Cache Line，典型的Cache Line大小是32~256字节。如果计算机还配置了二级缓存，则在访问物理内存之前先用PA去二级缓存中查找。一级缓存是用VA寻址的，二级缓存是用PA寻址的，这是它们的区别。Cache所做的工作是由硬件自动完成的，而不是像寄存器一样由指令决定先做什么后做什么。</td></tr><tr><td style="text-align:left;">内存</td><td style="text-align:left;">位于CPU外的芯片，与CPU通过地址和数据总线相连。</td><td style="text-align:left;">典型的存储容量是几百MB到几GB。</td><td style="text-align:left;">由DRAM组成，详见上面关于Cache的说明。</td><td style="text-align:left;">典型的访问时间是几百纳秒。</td><td style="text-align:left;">内存是通过地址来访问的，在启用MMU的情况下，程序指令中的地址是VA，而访问内存用的是PA，它们之间的映射关系由操作系统维护。</td></tr><tr><td style="text-align:left;">硬盘</td><td style="text-align:left;">位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘。</td><td style="text-align:left;">典型的存储容量是几百GB到几TB。</td><td style="text-align:left;">硬盘由磁性介质和磁头组成，访问硬盘时存在机械运动，磁头要移动，磁性介质要旋转，机械运动的速度很难提高到电子的速度，所以访问速度很受限制。保存在硬盘上的数据掉电后不会丢失。</td><td style="text-align:left;">典型的访问时间是几毫秒，是寄存器访问时间的106倍。</td><td style="text-align:left;">由驱动程序操作设备总线控制器去访问。由于硬盘的访问速度较慢，操作系统通常一次从硬盘上读几个页面到内存中缓存起来，如果这几个页面后来都被程序访问到了，那么这一次读硬盘的时间就可以分摊（Amortize）给程序的多次访问了。</td></tr></tbody></table><p>所以<code>预读缓存的</code>办法是很有效的：CPU取一条指令，我把和它<code>相邻的指令</code>也都缓存起来，CPU很可能马上就会取到；CPU访问一个数据，我把和它<code>相邻的数据</code>也都缓存起来，CPU很可能马上就会访问到。 这实际上 就用到了 虚拟内存技术</p><hr><h1 id="%E5%8D%81%E4%B8%80%20x86%E6%B1%87%E7%BC%96" tabindex="-1">十一 x86汇编 <a class="header-anchor" href="#十一 x86汇编" aria-label="Permalink to &quot;十一 x86汇编&quot;">​</a></h1><p>1.简单的汇编程序</p><p>将 汇编代码 作为 .s 保存</p><p>先使用 汇编器</p><hr><h1 id="%E9%99%84%E5%BD%95%20%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E5%92%8C%E6%A6%82%E5%BF%B5%E9%87%8C%E5%87%BA%E7%8E%B0%E7%9A%84%20%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E6%9C%AF%E8%AF%AD" tabindex="-1">附录 编程过程和概念里出现的 英文单词术语 <a class="header-anchor" href="#附录 编程过程和概念里出现的 英文单词术语" aria-label="Permalink to &quot;附录 编程过程和概念里出现的 英文单词术语&quot;">​</a></h1><h2 id="1.segmentation%20fault" tabindex="-1">1.segmentation fault <a class="header-anchor" href="#1.segmentation fault" aria-label="Permalink to &quot;1.segmentation fault&quot;">​</a></h2><p>段错误</p><h2 id="2.implementation_define%20%20unspecified%20%20undefine" tabindex="-1">2.implementation_define unspecified undefine <a class="header-anchor" href="#2.implementation_define  unspecified  undefine" aria-label="Permalink to &quot;2.implementation_define  unspecified  undefine&quot;">​</a></h2><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在 C 和 C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 编程中，术语 implementation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">defined、unspecified 和 undefined 表示三种不同的行为规范。它们在标准中定义不同的行为范围，以帮助开发者理解程序在特定情况下的表现和潜在风险。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Implementation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Defined Behavior（实现定义的行为）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">定义：实现定义的行为是指某些行为依赖于编译器或平台，由编译器实现者选择具体的行为方式。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：这种行为必须明确记录在编译器的文档中，且在同一实现环境中表现一致。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例子：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 等类型的具体大小（如 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位或 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 位）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字符类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 是否为有符号或无符号。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字节顺序（大端或小端）。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unspecified Behavior（未指定的行为）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">定义：未指定的行为指的是标准允许多种合法行为，但没有规定具体的选择。编译器可以自由地选择某种行为，而无需在文档中详细说明。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：未指定的行为可能在不同的实现或编译器版本中有所不同，但它不会导致程序崩溃。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例子：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">函数参数的求值顺序，例如 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">表达式中多个未序列化的副作用顺序，如 a[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Undefined Behavior（未定义的行为）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">定义：未定义的行为指的是标准未规定的行为，导致编译器对该行为没有任何约束，程序可能出现不可预测的结果。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">特点：未定义的行为可能导致程序崩溃、数据损坏，甚至会在编译时产生意想不到的输出。编译器在遇到未定义行为时不负责任何后果。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例子：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">数组越界访问，例如 arr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] 在长度为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的数组 arr 上。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">对空指针解引用，例如 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ptr 当 ptr 为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">使用未初始化的变量。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">总结</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Implementation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Defined：行为在编译器中有特定定义，并记录在文档中。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Unspecified：允许多种合法行为，但编译器无需明确记录，且在不同编译器间可能不同。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Undefined：标准未定义，可能导致程序不可预测的行为，使用时要特别小心。</span></span></code></pre></div><h2 id="3.side%20effect%E5%92%8Csequence%20point" tabindex="-1">3.side effect和sequence point <a class="header-anchor" href="#3.side effect和sequence point" aria-label="Permalink to &quot;3.side effect和sequence point&quot;">​</a></h2><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Side Effect（副作用）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">定义：副作用是指在表达式求值过程中对程序状态（例如变量值、内存内容）的更改。这些更改可能会影响程序的后续行为。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">常见副作用：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">修改变量的值（例如 x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 或 x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">O 操作，例如 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()、</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scanf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">动态内存分配和释放（如 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 或 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">）。</span></span></code></pre></div><p>例子:</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // x++ 是一个带有副作用的操作，因为它会改变 x 的值。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在这个例子中，x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 不仅计算 x 的值，还会对 x 进行递增操作，这是一个副作用。</span></span></code></pre></div><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Sequence Point（序列点）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">定义：序列点是一个程序中确定的时间点，在该点之前的所有副作用都被保证完成（执行完毕），并且不会与该点之后的副作用发生冲突。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">序列点确保了程序中的某些操作具有确定的执行顺序，防止在求值顺序不确定时出现未定义行为。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">常见的序列点：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">表达式和表达式之间，例如在 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、,（逗号运算符）中。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">完整的表达式末尾，例如每个语句结束时。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">函数调用时，所有参数的副作用都在函数调用前完成。</span></span></code></pre></div><p>例子:</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // &#39;&amp;&amp;&#39; 是一个序列点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在这个例子中，a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的副作用在 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 之前完成，保证了 a 的值在 a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 之前递增。</span></span></code></pre></div><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Side Effect 和 Sequence Point 的关系</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">序列点的存在确保了在某些表达式中副作用按顺序执行，从而避免了未定义行为。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在没有明确序列点的情况下，如果对同一对象有多次未序列化的修改，可能会导致 未定义行为</span></span></code></pre></div><p>例子:</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 未定义行为：i 同时在表达式中被读取和修改，且没有序列点。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在这种情况下，i 的自增和赋值在没有序列点的情况下同时发生，因此编译器行为不可预测。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">不同的编译器 可能执行结果 并不一样</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">据 C 和 C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的标准，如果在同一个表达式中对一个对象（如 i）进行了多次修改，并且这些修改之间没有确定的求值顺序或序列点，就会出现未定义行为。</span></span></code></pre></div><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 之后的变化：Sequence Point 被 Sequence 替代</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在 C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 标准中，</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sequence point&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的概念被更通用的 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sequenced before&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">、</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sequenced after&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 所替代。新的标准定义了更明确的求值顺序规则，用以下三种关系描述操作的顺序：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sequenced Before：一个操作在另一个操作之前按顺序执行。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sequenced After：一个操作在另一个操作之后按顺序执行。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Unsequenced：两个操作的执行顺序未定义，且没有依赖关系。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这种方式定义更加灵活，帮助编译器优化程序，同时也减少了未定义行为的可能性</span></span></code></pre></div><h2 id="4.fetch" tabindex="-1">4.fetch <a class="header-anchor" href="#4.fetch" aria-label="Permalink to &quot;4.fetch&quot;">​</a></h2><p>指令 不同的计算机领域, 含义不太一样</p><h2 id="5.register" tabindex="-1">5.register <a class="header-anchor" href="#5.register" aria-label="Permalink to &quot;5.register&quot;">​</a></h2><p>寄存器</p></div></div></main><footer class="VPDocFooter" data-v-37be3093 data-v-6b2a470d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-6b2a470d><span class="visually-hidden" id="doc-footer-aria-label" data-v-6b2a470d>Pager</span><div class="pager" data-v-6b2a470d><!----></div><div class="pager" data-v-6b2a470d><a class="VPLink link pager-link next" href="/mycppnoteweb/1-linux%E9%98%B6%E6%AE%B5%E6%B1%87%E6%80%BB/1-%E9%BB%91%E9%A9%AClinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-%E7%BB%93%E5%90%88%E8%AF%BE%E4%BB%B6%E7%9C%8B.html" data-v-6b2a470d><!--[--><span class="desc" data-v-6b2a470d>Next page</span><span class="title" data-v-6b2a470d>系统编程-1</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-1b770e11 data-v-88476a4e><div class="container" data-v-88476a4e><!----><p class="copyright" data-v-88476a4e>Copyright © 2025-present xinghuai</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"1-linux阶段汇总_1-黑马linux系统编程课堂笔记-结合课件看.md\":\"BRx75Ula\",\"1-linux阶段汇总_2-黑马linux系统编程.md\":\"ZLEMj7Vt\",\"1-linux阶段汇总_3-黑马linux系统编程.md\":\"DQRC_oxC\",\"1-linux阶段汇总_4-黑马linux网络编程.md\":\"piWqOmPQ\",\"1-linux阶段汇总_5-黑马网络编程.md\":\"DScH2CPe\",\"1-linux阶段汇总_6-黑马网络编程.md\":\"BqRO5LnQ\",\"1-linux阶段汇总_7-黑马网络编程.md\":\"DByNaKtb\",\"1-linux阶段汇总_8-系统_网络代码练习汇总.md\":\"DHN867QZ\",\"1-linux阶段汇总_linux c一站式学习笔记.md\":\"D9G_3GLW\",\"api-examples.md\":\"B7e-YOhA\",\"index.md\":\"lSx-3cHM\",\"readme.md\":\"B-c1lZsH\",\"中高级c__阶段学习笔记-md_1-中级c__笔记-1.md\":\"BSU5zpPW\",\"中高级c__阶段学习笔记-md_1-中级c__笔记-2.md\":\"Cup3-0HH\",\"中高级c__阶段学习笔记-md_1-中级面试问题汇总.md\":\"D5nMXlgd\",\"中高级c__阶段学习笔记-md_2-高级c__笔记-1.md\":\"DMUvXHys\",\"中高级c__阶段学习笔记-md_2-高级c__笔记-2.md\":\"C-HrruXS\",\"中高级c__阶段学习笔记-md_回调函数.md\":\"BoqoVYsO\",\"中高级c__阶段学习笔记-md_回顾linux的多线程.md\":\"C7SP32fD\",\"数据结构_1-数据结构.md\":\"CiGtMIoq\",\"数据结构_2-数据结构(五大算法之后).md\":\"DiYmI0kI\",\"数据结构_复习-代码.md\":\"pjALHusO\",\"数据结构_数据结构小补充.md\":\"Czqk-qZa\",\"施磊数据库核心_1-数据库笔记.md\":\"DrVH4p7L\",\"施磊数据库核心_2-常用命令.md\":\"CPUknL5n\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"mycpp-note\",\"description\":\"xinghuai的学习笔记\",\"base\":\"/mycppnoteweb/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"home\",\"link\":\"/\"},{\"text\":\"linux\",\"items\":[{\"text\":\"系统编程\",\"collapsed\":false,\"items\":[{\"text\":\"系统编程-1\",\"link\":\"/1-linux阶段汇总/1-黑马linux系统编程课堂笔记-结合课件看\"},{\"text\":\"系统编程-2\",\"link\":\"/1-linux阶段汇总/2-黑马linux系统编程\"},{\"text\":\"系统编程-3\",\"link\":\"/1-linux阶段汇总/3-黑马linux系统编程\"}]},{\"text\":\"网络编程\",\"collapsed\":false,\"items\":[{\"text\":\"网络编程-1\",\"link\":\"/1-linux阶段汇总/4-黑马linux网络编程\"},{\"text\":\"网络编程-2\",\"link\":\"/1-linux阶段汇总/5-黑马网络编程\"},{\"text\":\"网络编程-3\",\"link\":\"/1-linux阶段汇总/6-黑马网络编程\"},{\"text\":\"网络编程-4\",\"link\":\"/1-linux阶段汇总/7-黑马网络编程\"}]},{\"text\":\"练习代码\",\"link\":\"/1-linux阶段汇总/8-系统+网络代码练习汇总\"}]},{\"text\":\"cpp\",\"items\":[{\"text\":\"cpp中级\",\"collapsed\":false,\"items\":[{\"text\":\"cpp中级-1\",\"link\":\"/中高级c++阶段学习笔记-md/1-中级c++笔记-1\"},{\"text\":\"cpp中级-2\",\"link\":\"/中高级c++阶段学习笔记-md/1-中级c++笔记-2\"},{\"text\":\"中级面试\",\"link\":\"/中高级c++阶段学习笔记-md/1-中级面试问题汇总\"}]},{\"text\":\"cpp高级\",\"collapsed\":false,\"items\":[{\"text\":\"cpp高级-1\",\"link\":\"/中高级c++阶段学习笔记-md/2-高级c++笔记-1\"},{\"text\":\"cpp高级-2\",\"link\":\"/中高级c++阶段学习笔记-md/2-高级c++笔记-2\"},{\"text\":\"回调函数\",\"link\":\"/中高级c++阶段学习笔记-md/回调函数\"},{\"text\":\"回顾linux的多线程\",\"link\":\"/中高级c++阶段学习笔记-md/回顾linux的多线程\"}]}]},{\"text\":\"数据结构\",\"items\":[{\"text\":\"数据结构-1\",\"link\":\"/数据结构/1-数据结构\"},{\"text\":\"数据结构-2\",\"link\":\"/数据结构/2-数据结构(五大算法之后)\"},{\"text\":\"老师pdf\",\"link\":\"/数据结构/C++版数据结构和算法课程.pdf\"},{\"text\":\"红黑树扩展\",\"link\":\"/数据结构/红黑树删除节点 - Hide on bush.pdf\"},{\"text\":\"数据结构小补充\",\"link\":\"/数据结构/数据结构小补充\"}]},{\"text\":\"项目\",\"items\":[{\"text\":\"集群聊天服务器\",\"link\":\"/markdown-examples\"},{\"text\":\"mprpc框架\",\"link\":\"/api-examples\"}]},{\"text\":\"mysql\",\"items\":[{\"text\":\"mysql-1\",\"link\":\"/施磊数据库核心/1-数据库笔记\"},{\"text\":\"常用命令小总结\",\"link\":\"/施磊数据库核心/2-常用命令\"}]}],\"sidebar\":[{\"text\":\"linux\",\"items\":[{\"text\":\"系统编程\",\"collapsed\":false,\"items\":[{\"text\":\"系统编程-1\",\"link\":\"/1-linux阶段汇总/1-黑马linux系统编程课堂笔记-结合课件看\"},{\"text\":\"系统编程-2\",\"link\":\"/1-linux阶段汇总/2-黑马linux系统编程\"},{\"text\":\"系统编程-3\",\"link\":\"/1-linux阶段汇总/3-黑马linux系统编程\"}]},{\"text\":\"网络编程\",\"collapsed\":false,\"items\":[{\"text\":\"网络编程-1\",\"link\":\"/1-linux阶段汇总/4-黑马linux网络编程\"},{\"text\":\"网络编程-2\",\"link\":\"/1-linux阶段汇总/5-黑马网络编程\"},{\"text\":\"网络编程-3\",\"link\":\"/1-linux阶段汇总/6-黑马网络编程\"},{\"text\":\"网络编程-4\",\"link\":\"/1-linux阶段汇总/7-黑马网络编程\"}]},{\"text\":\"练习代码\",\"link\":\"/1-linux阶段汇总/8-系统+网络代码练习汇总\"}]},{\"text\":\"cpp\",\"items\":[{\"text\":\"cpp中级\",\"collapsed\":false,\"items\":[{\"text\":\"cpp中级-1\",\"link\":\"/中高级c++阶段学习笔记-md/1-中级c++笔记-1\"},{\"text\":\"cpp中级-2\",\"link\":\"/中高级c++阶段学习笔记-md/1-中级c++笔记-2\"},{\"text\":\"中级面试\",\"link\":\"/中高级c++阶段学习笔记-md/1-中级面试问题汇总\"}]},{\"text\":\"cpp高级\",\"collapsed\":false,\"items\":[{\"text\":\"cpp高级-1\",\"link\":\"/中高级c++阶段学习笔记-md/2-高级c++笔记-1\"},{\"text\":\"cpp高级-2\",\"link\":\"/中高级c++阶段学习笔记-md/2-高级c++笔记-2\"},{\"text\":\"回调函数\",\"link\":\"/中高级c++阶段学习笔记-md/回调函数\"},{\"text\":\"回顾linux的多线程\",\"link\":\"/中高级c++阶段学习笔记-md/回顾linux的多线程\"}]}]},{\"text\":\"数据结构\",\"items\":[{\"text\":\"数据结构-1\",\"link\":\"/数据结构/1-数据结构\"},{\"text\":\"数据结构-2\",\"link\":\"/数据结构/2-数据结构(五大算法之后)\"},{\"text\":\"老师pdf\",\"link\":\"/数据结构/C++版数据结构和算法课程.pdf\"},{\"text\":\"红黑树扩展\",\"link\":\"/数据结构/红黑树删除节点 - Hide on bush.pdf\"},{\"text\":\"数据结构小补充\",\"link\":\"/数据结构/数据结构小补充\"}]},{\"text\":\"项目\",\"items\":[{\"text\":\"集群聊天服务器\",\"link\":\"/markdown-examples\"},{\"text\":\"mprpc框架\",\"link\":\"/api-examples\"}]},{\"text\":\"mysql\",\"items\":[{\"text\":\"mysql\",\"link\":\"/施磊数据库核心/1-数据库笔记\"},{\"text\":\"常用命令小总结\",\"link\":\"/施磊数据库核心/2-常用命令\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/xinghuaiaaa/mycpp-note\"}],\"footer\":{\"copyright\":\"Copyright © 2025-present xinghuai\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>