import{_ as i,c as a,o as n,ae as t}from"./chunks/framework.MzfCtVj-.js";const g=JSON.parse('{"title":"商汤科技 cpp 面经","description":"","frontmatter":{},"headers":[],"relativePath":"中高级c++阶段学习笔记-md/1-中级面试问题汇总.md","filePath":"中高级c++阶段学习笔记-md/1-中级面试问题汇总.md"}'),l={name:"中高级c++阶段学习笔记-md/1-中级面试问题汇总.md"};function p(h,s,e,k,E,r){return n(),a("div",null,s[0]||(s[0]=[t(`<p>语法 是 很不重要的, 基本的回会了就行了</p><h1 id="%E5%95%86%E6%B1%A4%E7%A7%91%E6%8A%80%20cpp%20%E9%9D%A2%E7%BB%8F" tabindex="-1">商汤科技 cpp 面经 <a class="header-anchor" href="#商汤科技 cpp 面经" aria-label="Permalink to &quot;商汤科技 cpp 面经&quot;">​</a></h1><p>[TOC]</p><h2 id="1.%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%3F--%E5%8F%AF%E4%BB%A5%E8%AF%A6%E7%9C%8B%E6%96%BD%E7%A3%8A%E8%80%81%E5%B8%88%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE" tabindex="-1">1.程序的内存布局?--可以详看施磊老师第一节课 <a class="header-anchor" href="#1.程序的内存布局%3F--可以详看施磊老师第一节课" aria-label="Permalink to &quot;1.程序的内存布局?--可以详看施磊老师第一节课&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">布局大概</th><th></th></tr></thead><tbody><tr><td style="text-align:center;">.text(代码段,放指令), .rodata(只读数据段,比如: 常量字符串)---只读,不写&lt;br /&gt;.data(数据段: 存放初始化的,且初始化不为0的)&lt;br /&gt;.dss(数据段: 存放未初始化的,和初始化为0的)&lt;br /&gt;.heap(堆)(只有运行new了才有, 低地址向高地址)&lt;br /&gt;<em>.so,</em>.dll(共享库,静态与动态)&lt;br /&gt;stack(栈空间, 从下往上增长,高地址向低地址)&lt;br /&gt;命令行参数和环境变量&lt;br /&gt;</td><td>0x00000000&lt;br /&gt;0x08048000&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;0xc0000000&lt;br /&gt;3G-----用户空间</td></tr><tr><td style="text-align:center;">内核区(kernel space)&lt;br /&gt; <strong>ZONE_DMA</strong>：前 16MB，用于支持老旧设备的 DMA。 <strong>ZONE_DMA32</strong>（仅在 64 位系统中存在）：支持 32 位地址的 DMA，范围是前 4GB。 <strong>ZONE_NORMAL</strong>：常规内存区域，通常用于内核和用户空间的普通内存分配。 <strong>ZONE_HIGHMEM</strong>（仅在 32 位系统中存在）：用于映射超过 1GB 的物理内存（仅在 32 位系统中需要）。</td><td>1G---内核空间--0xffffffff</td></tr></tbody></table><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">00000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这是一个空指针地址，通常用于表示无效或未初始化的指针。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在许多操作系统中，这个地址是保留的，访问它可能会导致段错误（segmentation fault）或程序崩溃。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08048000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这是32位x86架构的Linux可执行文件中，.text段（存放可执行代码的部分）的默认起始地址。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">它是Linux系统中使用ld链接器生成的可执行文件的默认基地址。</span></span></code></pre></div><ol><li><strong>数据段</strong> 被称为 <strong>静态内存区</strong> 是很<strong>不专业</strong>的术语!!!</li><li>text和rodata是在一起吗? 并不在一块存, 不同的页面上, 从内存的属性上,即只读的, 可以理解为一块内存</li></ol><h2 id="2.%E5%A0%86%E6%A0%88%E5%8C%BA%E5%88%AB" tabindex="-1">2.堆栈区别 <a class="header-anchor" href="#2.堆栈区别" aria-label="Permalink to &quot;2.堆栈区别&quot;">​</a></h2><ol><li><p>内存方面的: 堆内存和栈内存</p><p>malloc或者new调用堆内存, free和delete释放堆内存, 手动开辟和释放 栈内存在调用函数就会占用栈内存, 系统自动开辟和释放</p></li><li><p>数据结构方面的: 二叉堆,大根堆,小根堆, 栈? 栈是一个先进后出的线性表, 堆常用的二叉堆, 就是一个二叉树, 二叉堆里经常用的就是大根堆(堆顶是最大的)和小根堆(堆顶是最小的) priority_queue 就是默认用大根堆实现的 栈 stack</p></li></ol><h2 id="3.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E9%80%92%E7%9A%84%3F" tabindex="-1">3.函数调用参数是怎么传递的? <a class="header-anchor" href="#3.函数调用参数是怎么传递的%3F" aria-label="Permalink to &quot;3.函数调用参数是怎么传递的?&quot;">​</a></h2><ol><li>实参传给 形参----&gt;太捞了</li><li>讲讲函数 调用的 压栈行为 多参数, <strong>从右往左压栈</strong>, 压完参数, <strong>压调用方的下一行指令地址</strong>(为了在函数执行完毕后，程序知道从哪里继续执行), <strong>然后把调用方的栈底地址ebp压上</strong>(这是为了在函数返回时能够恢复调用方的栈帧), <strong>然后ebp指针指向这里的esp作为新的栈底, 开始压调用的函数内容</strong>使用esp指针偏移进行后续的压栈, <strong>使用ebp偏移访问形参</strong></li></ol><h2 id="4.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%8E%E5%8F%B3%E5%BE%80%E5%B7%A6%E5%8E%8B%E6%A0%88" tabindex="-1">4.为什么函数调用从右往左压栈 <a class="header-anchor" href="#4.为什么函数调用从右往左压栈" aria-label="Permalink to &quot;4.为什么函数调用从右往左压栈&quot;">​</a></h2><ol><li><p>因为c/cpp是为了支持可变参数</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">指令是在 编译时生成的, 编译阶段 是无法知道到底有多少 可变参数的, 需要把确定的参数, 放到离 ebp 最近的地方, 编译器永远知道, ebp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">是第一个参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">从右往左压参数, 可以保证第一个参数, 就在ebp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的地方</span></span></code></pre></div></li></ol><h2 id="5.%E5%87%BD%E6%95%B0%E9%A2%98" tabindex="-1">5.函数题 <a class="header-anchor" href="#5.函数题" aria-label="Permalink to &quot;5.函数题&quot;">​</a></h2><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">string</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">string</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> s1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">string</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> s2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    string tmp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s2;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol><li><p>主函数通过 string s = fun(s1+s2); 调用, 依照代码执行顺序分析一下 调用了什么 构造函数和顺序, 以及析构函数的调用顺序</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 因为是值传递, 实参s2到形参s2的拷贝构造, 实参s1到形参s1的拷贝构造</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s2到tmp的拷贝构造</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s2) , </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s2)返回来的并不产生临时对象,  因此变为了 string s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  这是一个拷贝构造 </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">被调用的函数里面开始析构了, 析构 tmp,s1, s2, 注意顺序</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">最后主函数完了后, 析构s</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">知识点: 任意cpp编译器 都会做优化, 什么优化</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如果用临时对象 拷贝构造 新对象, 那么临时对象就不产生了, 直接构造新对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">临时对象是指在表达式求值过程中由编译器自动创建的对象。这些对象通常没有显式的名字，生命周期短暂，仅在表达式求值期间存在，之后会被销毁</span></span></code></pre></div></li><li><p>如果 return s1+s2; 与原来有什么区别?</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">省略了 tmp的拷贝构造和析构函数</span></span></code></pre></div></li><li><p>优化</p></li></ol><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 参数传递使用引用, 省略拷贝构造</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 返回对象时,直接返回结果, 不要先定义再返回</span></span></code></pre></div><h2 id="6.%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90----%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93" tabindex="-1">6.类和结构体的内存对齐----空结构体 <a class="header-anchor" href="#6.类和结构体的内存对齐----空结构体" aria-label="Permalink to &quot;6.类和结构体的内存对齐----空结构体&quot;">​</a></h2><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//2*8=16字节</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //1字节, 8bits</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c:    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//3字节</span></span></code></pre></div><p><strong>重点: 空结构体</strong></p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">win下面, vs 的.c 文件, 不允许定义空结构体</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gcc linux下, 空结构体是 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字节</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">win下面 vs 和 gcc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> linux下, .cpp .cc cpp语言 是 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字节</span></span></code></pre></div><p><strong>为什么?</strong></p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在c里, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 是变量, 叫结构体变量</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cpp里 struct不是变量, 叫对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">变量只需要内存,没有东西, 就是0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">对象不仅有对象, 还有构造, 而且构造函数 会生成this指针 ,  内存最小单位是 1字节, 所以是1字节</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">this 指针是一个隐含的指针，指向当前对象的地址。它的确占用 4 字节（32 位系统）或 8 字节（64 位系统），但 this 指针本身并不是对象的一部分，而是编译器在调用成员函数时隐式传递的一个参数。</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">this 指针的本质</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">this 指针是一个隐式参数，它在调用成员函数时由编译器自动传递。具体来说：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">当你调用一个成员函数时，编译器会将当前对象的地址作为第一个参数传递给该函数。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这个地址就是 this 指针的值。</span></span></code></pre></div><p>cpp中, 只有一个字节的变量的对象, 也是一字节大小</p><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">基类是 空, 派生类本身也是空</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">则 派生类也是1,因为啥也没继承, 而不要考虑 基类</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">派生类</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">那如果虚继承类呢, 会有vbptr, 则派生类将是 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 字节(指针大小),  若还有虚函数, 将还有vfptr, 将是8字节</span></span></code></pre></div><h2 id="7.%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" tabindex="-1">7.智能指针 <a class="header-anchor" href="#7.智能指针" aria-label="Permalink to &quot;7.智能指针&quot;">​</a></h2><p>防止内存泄漏,资源泄露 不带引用计数的智能指针: <strong>auto_ptr, unique_ptr</strong> 带引用计数的智能指针:<strong>shared_ptr, weak_ptr</strong></p><p>若使用智能指针shared_ptr, 会造成交叉引用问题, 导致资源无法释放----详见高级课程</p>`,28)]))}const c=i(l,[["render",p]]);export{g as __pageData,c as default};
