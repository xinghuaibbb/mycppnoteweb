import{_ as s,c as n,o as l,ae as p}from"./chunks/framework.MzfCtVj-.js";const u=JSON.parse('{"title":"回调函数作用","description":"","frontmatter":{},"headers":[],"relativePath":"中高级c++阶段学习笔记-md/回调函数.md","filePath":"中高级c++阶段学习笔记-md/回调函数.md"}'),t={name:"中高级c++阶段学习笔记-md/回调函数.md"};function e(i,a,c,o,d,r){return l(),n("div",null,a[0]||(a[0]=[p(`<h1 id="%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8" tabindex="-1">回调函数作用 <a class="header-anchor" href="#回调函数作用" aria-label="Permalink to &quot;回调函数作用&quot;">​</a></h1><h3 id="1.%20%E8%A7%A3%E8%80%A6%E9%80%BB%E8%BE%91%EF%BC%8C%E6%8F%90%E5%8D%87%E9%80%9A%E7%94%A8%E6%80%A7" tabindex="-1">1. <strong>解耦逻辑，提升通用性</strong> <a class="header-anchor" href="#1. 解耦逻辑，提升通用性" aria-label="Permalink to &quot;1. **解耦逻辑，提升通用性**&quot;">​</a></h3><ul><li>将操作行为从函数中抽离，交由调用者决定，增强模块的灵活性和复用性。</li><li>例如排序、自定义遍历、信号处理等都可通过回调定制行为。</li></ul><h3 id="2.%20%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%E6%88%96%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96" tabindex="-1">2. <strong>响应事件或状态变化</strong> <a class="header-anchor" href="#2. 响应事件或状态变化" aria-label="Permalink to &quot;2. **响应事件或状态变化**&quot;">​</a></h3><ul><li>在 GUI 编程、网络通信、系统事件处理中，当某个事件发生时，自动调用指定的函数进行处理。</li><li>典型应用：鼠标点击、服务器响应、消息到达。</li></ul><h3 id="3.%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6" tabindex="-1">3. <strong>实现异步处理机制</strong> <a class="header-anchor" href="#3. 实现异步处理机制" aria-label="Permalink to &quot;3. **实现异步处理机制**&quot;">​</a></h3><ul><li>用于在某项任务（如 I/O 或计算）完成后自动触发后续处理，避免阻塞。</li><li>比如：读取文件、等待连接完成后调用回调继续处理数据。</li></ul><h3 id="4.%20%E6%8F%90%E4%BE%9B%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B" tabindex="-1">4. <strong>提供扩展能力</strong> <a class="header-anchor" href="#4. 提供扩展能力" aria-label="Permalink to &quot;4. **提供扩展能力**&quot;">​</a></h3><ul><li>允许用户传入自己的函数，自定义某个阶段的处理流程，实现插件机制或“钩子”函数。</li><li>常见于框架或库中开放的接口设计。</li></ul><blockquote><h3 id="%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%A8%20C%2B%2B%20%E4%B8%AD%E7%94%A8%E4%BA%8E%E5%B0%86%E6%8E%A7%E5%88%B6%E6%9D%83%E4%BA%A4%E8%BF%98%E7%BB%99%E8%B0%83%E7%94%A8%E8%80%85%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%81%B5%E6%B4%BB%E6%89%A9%E5%B1%95%E3%80%81%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E5%92%8C%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%8C%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E8%80%A6%E5%90%88%E3%80%81%E6%8F%90%E9%AB%98%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E3%80%82" tabindex="-1"><strong>回调函数在 C++ 中用于将控制权交还给调用者，实现灵活扩展、事件响应和异步处理，从而降低耦合、提高可复用性。</strong> <a class="header-anchor" href="#回调函数在 C%2B%2B 中用于将控制权交还给调用者，实现灵活扩展、事件响应和异步处理，从而降低耦合、提高可复用性。" aria-label="Permalink to &quot;**回调函数在 C++ 中用于将控制权交还给调用者，实现灵活扩展、事件响应和异步处理，从而降低耦合、提高可复用性。**&quot;">​</a></h3></blockquote><h1 id="C%2B%2B%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3" tabindex="-1">C++ 回调函数详解 <a class="header-anchor" href="#C%2B%2B 回调函数详解" aria-label="Permalink to &quot;C++ 回调函数详解&quot;">​</a></h1><p>回调函数是C++中一种重要的编程技术，它允许将一个函数作为参数传递给另一个函数，在特定事件发生时被调用。以下是C++中回调的几种实现方式：</p><h2 id="1.%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%9B%9E%E8%B0%83" tabindex="-1">1. 函数指针回调 <a class="header-anchor" href="#1. 函数指针回调" aria-label="Permalink to &quot;1. 函数指针回调&quot;">​</a></h2><p>这是C风格的回调方式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 回调函数类型定义</span></span>
<span class="line"><span>typedef void (*Callback)(int);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 接受回调的函数</span></span>
<span class="line"><span>void processData(int data, Callback callback) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;处理数据: &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>    callback(data * 2); // 调用回调</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 实际回调函数</span></span>
<span class="line"><span>void myCallback(int result) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;回调结果: &quot; &lt;&lt; result &lt;&lt; std::endl;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    processData(5, myCallback);</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="2.%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%89%E5%9B%9E%E8%B0%83" tabindex="-1">2. 函数对象（仿函数）回调 <a class="header-anchor" href="#2. 函数对象（仿函数）回调" aria-label="Permalink to &quot;2. 函数对象（仿函数）回调&quot;">​</a></h2><p>使用类重载operator()实现：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class MyCallback {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    void operator()(int value) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;函数对象回调: &quot; &lt;&lt; value &lt;&lt; std::endl;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &lt;typename Callback&gt;</span></span>
<span class="line"><span>void processWithCallback(int data, Callback callback) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;处理数据: &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>    callback(data + 10);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    MyCallback callback;</span></span>
<span class="line"><span>    processWithCallback(7, callback);</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="3.%20std%3A%3Afunction%20%E5%9B%9E%E8%B0%83%20(C%2B%2B11%E5%8F%8A%E4%BB%A5%E4%B8%8A)" tabindex="-1">3. std::function 回调 (C++11及以上) <a class="header-anchor" href="#3. std%3A%3Afunction 回调 (C%2B%2B11及以上)" aria-label="Permalink to &quot;3. std::function 回调 (C++11及以上)&quot;">​</a></h2><p>更现代、灵活的回调方式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;functional&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void processWithStdFunction(int data, std::function&lt;void(int)&gt; callback) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;处理数据: &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>    callback(data * 3);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void regularFunction(int x) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;常规函数回调: &quot; &lt;&lt; x &lt;&lt; std::endl;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    // 使用普通函数</span></span>
<span class="line"><span>    processWithStdFunction(3, regularFunction);</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 使用lambda表达式</span></span>
<span class="line"><span>    processWithStdFunction(4, [](int x) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;Lambda回调: &quot; &lt;&lt; x &lt;&lt; std::endl;</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="4.%20%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83" tabindex="-1">4. 成员函数回调 <a class="header-anchor" href="#4. 成员函数回调" aria-label="Permalink to &quot;4. 成员函数回调&quot;">​</a></h2><p>回调类成员函数的方法：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;functional&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class MyClass {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    void memberCallback(int value) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;成员函数回调: &quot; &lt;&lt; value &lt;&lt; std::endl;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void processMemberCallback(int data, std::function&lt;void(int)&gt; callback) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;处理数据: &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>    callback(data + 5);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    MyClass obj;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 使用std::bind绑定成员函数</span></span>
<span class="line"><span>    processMemberCallback(10, std::bind(&amp;MyClass::memberCallback, &amp;obj, std::placeholders::_1));</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 或者使用lambda</span></span>
<span class="line"><span>    processMemberCallback(15, [&amp;obj](int x) { obj.memberCallback(x); });</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="5.%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9E%E8%B0%83%20(C%2B%2B11%E5%8F%8A%E4%BB%A5%E4%B8%8A)" tabindex="-1">5. Lambda表达式回调 (C++11及以上) <a class="header-anchor" href="#5. Lambda表达式回调 (C%2B%2B11及以上)" aria-label="Permalink to &quot;5. Lambda表达式回调 (C++11及以上)&quot;">​</a></h2><p>最简洁的现代C++回调方式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;functional&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void processWithLambda(int data, const std::function&lt;void(int)&gt;&amp; callback) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;处理数据: &quot; &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>    callback(data * data);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    int multiplier = 2;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    processWithLambda(5, [multiplier](int result) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;Lambda回调结果: &quot; &lt;&lt; result * multiplier &lt;&lt; std::endl;</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="%E5%9B%9E%E8%B0%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">回调的应用场景 <a class="header-anchor" href="#回调的应用场景" aria-label="Permalink to &quot;回调的应用场景&quot;">​</a></h2><ol><li>事件处理系统</li><li>异步操作完成通知</li><li>自定义排序或搜索算法</li><li>GUI编程中的事件处理</li><li>线程完成通知</li></ol><h2 id="%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE" tabindex="-1">选择建议 <a class="header-anchor" href="#选择建议" aria-label="Permalink to &quot;选择建议&quot;">​</a></h2><ul><li>简单情况：函数指针或lambda</li><li>需要状态保持：函数对象或std::function + lambda捕获</li><li>面向对象设计：std::function + 成员函数</li><li>C++11及以上：优先使用std::function和lambda</li></ul><p>现代C++中，std::function结合lambda表达式是最灵活和推荐的回调实现方式。</p><h1 id="%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%3A" tabindex="-1">参考链接: <a class="header-anchor" href="#参考链接%3A" aria-label="Permalink to &quot;参考链接:&quot;">​</a></h1><p><a href="https://mp.weixin.qq.com/s/TfJmGUXsvensSUYDi5xmJw" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/TfJmGUXsvensSUYDi5xmJw</a></p>`,34)]))}const h=s(t,[["render",e]]);export{u as __pageData,h as default};
