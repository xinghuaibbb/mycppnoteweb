

```c++
x86 架构
开发者：最早由 Intel 于 1978 年发布，随后 AMD 也推出了兼容的处理器产品。

特点：x86 是一种CISC（复杂指令集计算机）架构，指令集较为复杂，允许单个指令执行多个操作。

版本：

x86 (32位)：早期的 x86 处理器为 16 位和 32 位版本，例如 Intel 80386 和 80486，以及后续的 Pentium 系列。
x86-64 (AMD64)：64 位扩展版本，最早由 AMD 开发并普及。相比 32 位 x86，x86-64 支持更大的内存寻址空间和更多的寄存器。
寄存器：

32 位模式：主要寄存器包括 EAX、EBX、ECX、EDX 等，每个寄存器为 32 位。
64 位模式：寄存器扩展为 64 位（如 RAX、RBX 等），增加了 8 个新的通用寄存器，总数达到 16 个。
指令集扩展：

x86 架构在演进过程中增加了许多指令集扩展，如 SSE（用于多媒体处理）、AVX（用于浮点运算和矢量处理）、AES-NI（加密指令集）等，增强了处理器在科学计算、数据加密和多媒体处理方面的性能。
应用：

台式机和笔记本电脑：绝大部分 Windows 和 Linux 系统使用 x86 或 x86-64 架构的 CPU。
服务器：大量服务器使用 x86-64 架构处理器，如 Intel Xeon 和 AMD EPYC。
虚拟化：x86-64 支持硬件虚拟化（Intel VT-x 和 AMD-V），使得其在云计算和虚拟化环境中应用广泛。
优点：

丰富的生态系统：由于历史悠久且广泛普及，x86 处理器拥有丰富的软件和硬件生态系统，支持大量的应用程序和操作系统。
强大的兼容性：x86-64 向后兼容 x86 32 位程序，因此可以运行旧的应用。
高性能：在频率和指令集优化方面表现良好，尤其适合多媒体、科学计算和加密等任务。
缺点：

功耗较高：相比于 RISC 架构（如 ARM），x86 的复杂指令集导致功耗较高，这也是 x86 在移动设备上不如 ARM 普及的原因。
架构复杂：为了保持向后兼容，x86 架构不断扩展和增加新特性，使得处理器设计和指令解码相对复杂。
典型处理器：Intel Core 系列、AMD Ryzen 系列（用于个人计算）；Intel Xeon、AMD EPYC 系列（用于服务器）。


    
    1. x86-64 (AMD64)
开发者：最初由 AMD 开发，后来 Intel 也采用并推广。
特点：x86-64 是 x86 架构的 64 位扩展，支持 32 位和 64 位指令。
应用：台式机、笔记本、服务器，以及几乎所有的 Windows 和 Linux 系统。
优点：
向后兼容 x86，因此可以运行大量旧的 32 位软件。
支持更多的寄存器和更大的内存寻址空间（最高可支持 16 EB 地址空间）。
拥有丰富的指令集扩展，如 SSE、AVX，用于多媒体和科学计算。
典型处理器：Intel Core 系列、AMD Ryzen 系列。
2. ARM (ARMv8)
开发者：由 ARM Holdings 设计，授权给其他公司制造，如苹果、高通、三星等。
特点：基于 RISC（精简指令集）架构，拥有较少的指令，执行速度更快且功耗低。
应用：广泛用于移动设备（智能手机、平板电脑）、嵌入式设备、物联网 (IoT) 设备，最近也用于服务器（如亚马逊 Graviton 芯片）。
优点：
功耗低，非常适合移动和嵌入式应用。
ARMv8 开始支持 64 位指令集（AArch64），并兼容 32 位。
强大的 SIMD 指令集，如 NEON，加速图形和多媒体处理。
典型处理器：苹果 A 系列和 M 系列芯片、高通 Snapdragon 系列、三星 Exynos 系列。
3. RISC-V
开发者：由加州大学伯克利分校设计，现为开源架构。
特点：完全开源的 RISC 架构，模块化设计，使其易于定制和扩展。
应用：嵌入式系统、物联网设备、科研项目，逐渐向高性能计算领域扩展。
优点：
开源，无需支付许可费用，使其非常适合科研和实验。
模块化设计，用户可以根据需要添加扩展（如浮点、矢量、加密扩展等）。
架构灵活，可以在功耗、性能之间做平衡，广泛适用于多种应用场景。
典型处理器：SiFive 系列芯片、许多新兴的物联网处理器。
4. PowerPC (PPC)
开发者：IBM、摩托罗拉和苹果公司（早期）。
特点：基于 RISC，设计为高效的计算能力和低功耗的平衡。
应用：早期应用于苹果的 Macintosh 电脑和游戏主机（如 PlayStation 3、任天堂 Wii），现在用于 IBM 高性能服务器和嵌入式系统。
优点：
强大的浮点运算能力，适合科学计算和高性能任务。
设计灵活，可应用在嵌入式和高性能计算领域。
IBM 的 POWER 系列芯片依旧是服务器领域的重要玩家，适合高吞吐量任务。
典型处理器：IBM Power 系列，曾经的苹果 G3/G4/G5 处理器。
5. MIPS
开发者：由 MIPS Technologies 公司设计，基于 RISC。
特点：简单而精简的指令集，使其易于实现和扩展。
应用：主要在嵌入式系统、网络设备（如路由器），过去曾用于工作站和游戏主机（如早期的 PlayStation）。
优点：
设计简单，功耗低，适合低成本、低功耗的嵌入式设备。
RISC 设计使得 MIPS 执行效率高，适合于实时操作系统。
易于学习，因此常被用于教育和科研。
典型处理器：现代嵌入式芯片如一些路由器芯片，早期的 Silicon Graphics 工作站。
6. IBM Mainframe (z/Architecture)
开发者：IBM
特点：IBM 专有架构，设计用于高可靠性和高吞吐量的任务。
应用：主要在银行、保险、政府等需要处理大量数据的关键任务领域。
优点：
高可靠性和高性能，特别适合大规模数据处理和事务处理。
强大的虚拟化能力和并行处理能力。
支持复杂的数据加密和安全功能，确保关键任务数据的安全性。
典型处理器：IBM Z 系列处理器。
```



# 一 程序的基本概念

## 1.编译器和解释器

解释器和编译器是两种将高级编程语言转换为机器语言（计算机能够直接执行的二进制代码）的工具，它们的主要区别在于转换和执行的方式。

1. **编译器**：
   - 编译器在程序执行之前，先将整个源代码一次性翻译成机器码（通常是可执行文件）。编译过程完成后，生成的机器码就可以独立运行，不再需要编译器的参与。
   - 编译器通常进行语法检查、优化代码等过程，以提高程序运行效率。
   - 优点：由于机器码在运行时不需要进一步翻译，编译后的程序执行速度通常较快。
   - 缺点：调试比较麻烦，每次修改源代码后需要重新编译。
   - 示例语言：C、C++、Fortran。
2. **解释器**：
   - 解释器逐行翻译和执行源代码，它不生成独立的可执行文件。每次执行时，解释器都会实时将代码翻译成机器码并立即执行。
   - 解释器直接在运行时处理代码，通常提供更方便的调试和测试体验。
   - 优点：可以快速测试和调试代码，不需要编译整个程序。
   - 缺点：因为需要逐行翻译，程序执行速度相对于编译器生成的可执行程序较慢。
   - 示例语言：Python、JavaScript、Ruby。

总结：编译器将整个程序一次性转换为可执行文件，解释器则逐行解释执行代码。编译器生成的程序执行效率更高，而解释器在开发和调试过程中更加灵活方便。





## 2.关于Token的规则称为词法（Lexical）规则，而关于结构的规则称为语法（Grammar）规则

1. 词法（Lexical）规则

   ：

   - 词法规则是关于如何将输入的字符序列分割成有意义的最小单元（即Token）的规则。Token 是程序中最小的语义单位，比如关键字、标识符、运算符、数字、分隔符等。
   - 词法分析（Lexical Analysis）是编译器或解释器的第一步，它根据词法规则扫描源代码，将其转换为Token序列。这一步的任务就是识别代码中的不同类型的Token。
   - 词法规则通常涉及字符集、字符串模式、正则表达式等。

2. 语法（Grammar）规则

   ：

   - 语法规则定义了Token如何组合成合法的语句或表达式。它们描述了编程语言的结构，也就是如何组织Token来形成符合语言规范的程序。
   - 语法分析（Parsing）是编译器的第二步，它根据语法规则检查Token序列的结构，并确定是否符合语言的语法。这一步的结果通常是生成一个语法树（parse tree）或抽象语法树（AST），用于后续的编译或解释过程。
   - 语法规则常使用上下文无关文法（Context-Free Grammar, CFG）来定义，例如巴科斯范式（BNF）。

简单来说：

- **词法规则**处理的是**Token**（即最小的语义单位），它定义了如何识别这些基本元素。
- **语法规则**处理的是**Token的组合**，它定义了这些基本元素如何按照正确的顺序构成合法的结构或程序。



语法（Syntax）     符号（Token）   词法（Lexical）   语法（Grammar）   解析（Parse）  上下文（Context）  语义（Semantic）  歧义性（Ambiguity）  冗余性（Redundancy）  隐喻（Metaphor）  字面（Literal）  



结构很重要，从上到下从左到右读往往不是一个好办法，而应该学会在大脑里解析：识别Token，分解结构。



Syntax和Grammar通常都翻译成“语法”，这让初学者非常混乱，Syntax的含义其实包含了Lexical和Grammar的规则，还包含一部分语义的规则，例如在C程序中变量应先声明后使用。即使在英文的文献中Syntax和Grammar也常混用，在有些文献中Syntax的含义不包括Lexical规则，只要注意上下文就不会误解。





## 3.程序的调试

臭虫（Bug）    调试（Debug）

编译时错误  

该错误很容易解决, 大多是语法错误

运行时错误 (run-time)

好好区分明白这两种错误

逻辑错误和语义错误

  

------



# 二 c语法基础

## 1.c的字符串

唯一值得注意的一个东西  %s  打印  字符串形式数组

"hzh" 是一个字符串 ,但是其本身其实占用了4个字节, 因为有  \0 作为终止条件

char str[]="hzh"   最好不要指定长度, 容易漏掉 \0 ,  当漏掉了 \0 ,还要用  %s  打印 字符串数组 时, 由于没有终止条件Null字符, 会访问数组越界 



## 2.局部边量初始化问题

如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定的。所以，*局部变量在使用之前一定要先赋值*，如果基于一个不确定的值做后续计算肯定会引入Bug。

全局变量可以不初始化,但是局部变量必须初始化!!



------

# 三 编码规范

## 1.indent工具

自动格式化代码规范!

一般 win是 i4 即tab键 代表几个空格   这个是缩进的意思

``` 
indent -kr -i8  .c  -o  目标   linux多i8,   还可以
```



------

# 四 gdb调试

类似于 python 的 ipdb 或者 pdb   命令很多一样



## 1.单步执行和跟踪函数调用

首先, 必须在编译时 加入  -g  选项, 生成最终的 可执行文件

```c++
gcc -g test.c -o testgdb      testgdb  是有 -g 的可执行文件
然后才能 
    gdb testgdb  才能调试
```

-g 的作用是 在可执行文件中加入源代码的信息, 比如 可执行文件中第几条机器指令对应源代码的第几行 ,但并不是把整个源文件嵌入到可执行文件中 ,所以调试时必须保证gdb能找到源文件

`gdb`提供一个类似Shell的命令行环境



`list 1`表示 一次只列出 10行, 再次 `list`则是列出 11行之后    缩写   l

还可以   `l 函数名`   直接列出函数源代码



`start` 开始执行程序

next n 下一步

step s 进入函数

quit q 退出

`backtrace`  `bt`可以查看函数调用的栈帧

`info`命令（简写为`i`）查看`add_range`函数局部变量的值

i locals 显示当前函数所有局部变量的值

`main`函数当前局部变量的值也可以做到，先用`frame`命令（简写为`f`）选择1号栈帧然后再查看局部变量：

`print`命令（简写为`p`）打印出变量 的值    还可以修改变量的值, p ..=..  就可以了

`$1`表示`gdb`保存着这些中间结果，$后面的编号会自动增长，在命令中可以用`$1`、`$2`、`$3`等编号代替相应的值

`finish`命令让程序一直运行到从当前函数返回为止

set var   就是 set variable 修改变量的值的缩写



函数里局部变量如果没有初始化,值是不确定的, 而且如果连续调用 函数, 将会继承 函数上一次执行完的 局部变量的值, 很危险!!!!!

### gdb调试基本命令1

| 命令                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| backtrace（或bt）   | 查看各级函数调用及参数   以及当前在哪一行<br />在调试 程序崩溃 和 段错误 非常有用, 可以找到调用链 |
| finish              | 连续运行到当前函数返回为止，然后停下来等待命令               |
| frame（或f） 帧编号 | 选择栈帧<br />结合 bt 使用, 用于切换或者查看 当前调用栈的特定帧(函数调用) |
| info（或i） locals  | 查看当前栈帧局部变量的值                                     |
| list（或l）         | 列出源代码，接着上次的位置往下列，每次列10行                 |
| list 行号           | 列出从第几行开始的源代码                                     |
| list 函数名         | 列出某个函数的源代码                                         |
| next（或n）         | 执行下一行语句                                               |
| print（或p）        | 打印表达式的值，通过表达式可以修改变量的值或者调用函数       |
| quit（或q）         | 退出`gdb`调试环境                                            |
| set var             | 修改变量的值                                                 |
| start               | 开始执行程序，停在`main`函数第一行语句前面等待命令           |
| step（或s）         | 执行下一行语句，如果有函数调用则进入到函数中                 |





## 2.断点breakpoints

### gdb调试基本命令2

| 命令                       | 描述                                     |
| :------------------------- | :--------------------------------------- |
| break（或b） 行号          | 在某一行设置断点                         |
| break 函数名               | 在某个函数开头设置断点                   |
| break … if …               | 设置条件断点                             |
| continue（或c）            | 从当前位置开始连续运行程序               |
| delete breakpoints 断点号  | 删除断点                                 |
| display 变量名             | 跟踪查看某个变量，每次停下来都显示它的值 |
| disable breakpoints 断点号 | 禁用断点                                 |
| enable 断点号              | 启用断点                                 |
| info（或i） breakpoints    | 查看当前设置了哪些断点                   |
| run（或r）                 | 从头开始连续运行程序                     |
| undisplay 跟踪显示号       | 取消跟踪显示                             |



## 3.观察点 watchpoints



断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有用。

| 命令                    | 描述                                                         |
| :---------------------- | :----------------------------------------------------------- |
| watch                   | 设置观察点                                                   |
| info（或i） watchpoints | 查看当前设置了哪些观察点                                     |
| x                       | 从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量 |



x/7b input       input是一个数组名

`x`命令打印指定存储单元的内容。`7b`是打印格式，`b`表示每个字节一组，7表示打印7组[[22](https://www.bookstack.cn/read/linux-c/b7171caee4e952d7.md#ftn.id2742046)]，从`input`数组的第一个字节开始连续打印7个字节。



## 4.段错误(挖了几个坑 后续讲)

中文:段错误

英文:segmentation fault

一般这个错误, 就是直接显示 段错误  

开始从头调试, 段错误 在 调试时, 会在错误的地方 停下来 ,此时 使用 bt 查看栈帧信息 ,错误就在这个调用链里



------



# 五 1-4总结(还未看)

第一阶段总结, 有好多问题, 还没看







------

# 六 计算机中数的表示

计组中的知识

有门电路,一位全加器,浮点数的ieee754标准



------

# 八 数据类型详解

## 1.整型

有符号 和 无符号    signed  和 unsigned

char 的有符号和无符号

许多详细的点 需要结合 具体的编译器而定, 脱离了编译器 谈 c 的细节 就是耍流氓



在C标准中没有做明确规定的地方会用Implementation-defined、Unspecified或Undefined来表述, 统称为 未明确定义

```c++
C标准没有明确规定char是有符号的还是无符号的，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。    ---implementation_define
```

```c++
对于Unspecified的情况，往往有几种可选的处理方式，C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式
```

```c++
Undefined的情况则是完全不确定的，C标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，有很多Undefined的情况编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是Undefined的。
```



x86平台上`int`的取值范围是-2147483648~2147483647，那么用`printf("%d\n", -2147483648);`

```c++
有些平台编译器
warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘long long int’
会警告,  比如 linux 下的 gcc

直接使用 -2147483648 警告的编译器会解释成 -(2147483648) ,然而没有 2147483648 数存在 产生了溢出
```

还有 ll i = 123456789 * 123456789

也会警告, int * int 是 int , 想要消除警告, 就必须 进行 ll int 参与进去  修改 123456789ll * 123456789



## 2.浮点型

`long double`型通常是比`double`型精度更高的类型，但各平台的实现有较大差异。在x86平台上，大多数编译器实现的`long double`型是80位，因为x86的浮点运算单元具有80位精度，`gcc`实现的`long double`型是12字节（96位），这是为了对齐到4字节边界（在[第 4 节 “结构体和联合体”](https://www.bookstack.cn/read/linux-c/2aa8e59e2d2873d2.md#asmc.structunion)详细讨论对齐的问题），也有些编译器实现的`long double`型和`double`型精度相同，没有充分利用x86浮点运算单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如PowerPC上的`long double`型通常是128位。



## 3.类型转换(很乱,了解即可)

了解有符号数和无符号数混用会非常麻烦，从而避免触及这些规则，并且在程序出错时记得往这上面找原因。所以这些规则不需要牢记，但要知道有这么回事，以便在用到的时候能找到我书上的这一段

\+ - * / % > < >= <= == !=运算符都需要做Usual Arithmetic Conversion (通常算术转换)  要求两边操作数的类型一致



单目运算符+ - ~只有一个操作数，移位运算符<< >>两边的操作数类型不要求一致，这些运算不需要做Usual Arithmetic Conversion，但也需要做Integer Promotion(整数提升), 就是隐式转换规则



注意: char = getchar()  getchar返回值并不是char, 而是int

强制转换





------

# 九 运算符详解

## 1.位运算

总结: 建议只对 无符号数 做 移位运算



有些信息 必须通过 访问位 才能得到

例如 UTF-8编码



& | ~ ^

不同类型 位运算 需要 注意类型转换的细节!!!

<< >> 左右移 运算

在一定的 取值范围内, << 一位, 相当于乘2 , 比乘法快的多

右移,无符号数,添0

有符号数,正数 添0, 负数,不一定添0或者添1, gcc保持了最高位添1,使得 即使是负数,也可以是 除2



```c++
int i = 0xcffffff3;
printf("%x\n", 0xcffffff3>>2);
printf("%x\n", i>>2);

编译器 一般是将 0x,,, 直接视为 常量, 进行逻辑右移(只添0), 而不是算术右移(与正负有关)
```



## 2.其它运算符

复合赋值运算符

+= -= /= *= 等等  这个 只求值一次, 而 拆开,则是求职两次



条件运算符
? :



逗号运算符

(表达式1,表达式2)  作为参数传入的话, 只传入表达式2, 1被舍弃 



sizeof运算符

size 表达式     和   sizeof(类型名)  两种形式

第一个可以写成sizeof(表达式), 类似 return(1), 括号不起作用

```
int a[12];
printf("%d\n", sizeof a/sizeof a[0]);
```

在上面这个例子中，由于`sizeof 表达式`中的子表达式不需要求值，所以不需要到运行时才计算，事实上在编译时就知道`sizeof a`的值是48，`sizeof a[0]`的值是4，所以在编译时就已经把`sizeof a/sizeof a[0]`替换成常量12了，这是一个常量表达式。

注意:

```c++
sizeof 的结果是一个 size_t 类型
这个类型定义在stddef.h头文件中，不过你的代码中只要不出现size_t这个类型名就不用包含这个头文件，比如像上面的例子就不用包含这个头文件。C标准规定size_t是一种无符号整型，编译器可以用typedef做一个类型声明：

typedef unsigned long size_t;
那么 size_t 就代表 unsigned long 型。不同平台的编译器可能会根据自己平台的具体情况定义 size_t 所代表的类型，比如有的平台定义为 unsigned long 型，有的平台定义为 unsigned long long 型，C标准规定size_t这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要把size_t类型和它所代表的真实类型混用，例如：

unsigned long x;
size_t y;
x = y; // 高位细节丢失
```

```
typedef char array_t[10];array_t a;
```

这相当于声明`char a[10];`  好好理解这个代码, 这个有点不懂



## 3.side effect(编程中的副作用)和sequence point(c/c++中的 顺序点)

面试题 的 hr 钻牛角尖 专用, 折磨应聘的人

side effect 在编程中指 一个表达式或函数 除了返回值之外还会对程序的状态和环境造成变化,例如修改变量,写入文件,更新数据结构等

sequence point 顺序点, 用于定义表达式中各个操作的执行顺序, 在一个顺序点之前的所有 副作用 必须在到达这个顺序点之前完成,顺序点之后的操作不会影响之前的结果



有点 云里雾里



i=i+1  这是正确的  

a[i++]=i 这是 未定义 undefine 行为  也可能是 正确的, 说法不一

主要问题是, 在 = 号时,  究竟是确定的 先左后右,还是先右后左, 如果这个不确定, 那就是 未定义 行为了



## 4.总结

a?b:c?d:e  在c 中, 是 a?b(c?d:e)

语法规则 实际上不是 由 优先性 和 结合性 表述的, 有些细节 用这两个解释不了, 看c标准才能理解!



------

# 十 计算机体系结构基础(英文术语多,计组知识)

Von Neumann冯诺依曼  体系结构  

这种体系结构的主要特点是：CPU（CPU，Central Processing Unit，中央处理器，或简称处理器Processor）和内存（Memory）是计算机的两个主要组成部分，内存中保存着数据和指令，CPU从内存中取指令（Fetch）执行，其中有些指令让CPU做运算，有些指令让CPU读写内存中的数据。



## 1.CPU

1.寄存器 register  x86的寄存器`eax`、`esp`、`eip`等等

`eip`用作程序计数器，这称为特殊寄存器（Special-purpose Register），而另外一些寄存器可以用在各种运算和读写内存的指令中，比如`eax`寄存器，这称为通用寄存器（General-purpose Register）。

2.程序计数器 PC Program Counter  

是一种特殊寄存器，保存着CPU取下一条指令的地址，CPU按程序计数器保存的地址去内存中取指令然后解释执行，这时程序计数器保存的地址会自动加上该指令的长度，指向内存中的下一条指令。

3.指令译码器（Instruction Decoder）

CPU取上来的指令由若干个字节组成，这些字节中有些位表示内存地址，有些位表示寄存器编号，有些位表示这种指令做什么操作，是加减乘除还是读写内存，指令译码器负责解释这条指令的含义，然后调动相应的执行单元去执行它。

4.算术逻辑单元（ALU，Arithmetic and Logic Unit）

如果译码器将一条指令解释为运算指令，就调动算术逻辑单元去做运算，比如加减乘除、位运算、逻辑运算。指令中会指示运算结果保存到哪里，可能保存到寄存器中，也可能保存到内存中。

5.地址和数据总线（Bus）

CPU和内存之间用地址总线、数据总线和控制线连接起来，每条线上有1和0两种状态。



字 word  半字 half word   处理器的字长

地址线、数据线是指CPU的内总线，是直接和CPU的执行单元相连的，内总线经过MMU和总线接口的转换之后引出到芯片引脚才是外总线，外地址线和外数据线的位数都有可能和内总线不同



对于多字节的整数类型，低地址保存的是整数的低位，这称为`小端（Little Endian）字节序（Byte Order）`。x86平台是小端字节序的，而另外一些平台规定低地址保存整数的高位，称为`大端（Big Endian）字节序`。



## 2.设备

设备中可供读写访问的单元通常称为`设备寄存器（注意和CPU寄存器不是一回事）`，操作设备的过程就是读写这些设备寄存器的过程，比如向串口发送寄存器里写数据，串口设备就会把数据发送出去，读串口接收寄存器的值，就可以读取串口设备接收到的数据。

从CPU核引出的地址和数据总线有一端经总线接口引出到芯片引脚上了，还有一端没有引出，而是接到芯片内部集成的设备上，无论是在CPU外部接总线的设备还是在CPU内部接总线的设备都有各自的地址范围，都可以像访问内存一样访问，



很多体系结构（比如ARM）采用这种方式操作设备，称为`内存映射I/O（Memory-mapped I/O）`。



但是x86比较特殊，x86对于设备有独立的端口地址空间，CPU核需要引出额外的地址线来连接片内设备（和访问内存所用的地址线不同），访问设备寄存器时用特殊的`in`/`out`指令，而不是和访问内存用同样的指令，这种方式称为`端口I/O（Port I/O）`



从CPU的角度来看，访问设备只有内存映射I/O和端口I/O两种，要么像内存一样访问，要么用一种专用的指令访问。



其实访问设备是相当复杂的，计算机的设备五花八门，`各种设备的性能要求都不一样，有的要求带宽大，有的要求响应快，有的要求热插拔`，于是出现了各种适应不同要求的设备总线，比如`PCI、AGP、USB、1394、SATA`等等，这些设备总线并不直接和CPU相连，`CPU通过内存映射I/O或端口I/O访问相应的总线控制器`，通过总线控制器再去访问挂在总线上的设备。



在x86平台上，硬盘是挂在IDE、SATA或SCSI总线上的设备

保存在硬盘上的程序是不能被CPU直接取指令执行的，操作系统在执行程序时会把它从硬盘拷贝到内存，这样CPU才能取指令执行，这个过程称为`加载（Load）`

程序加载到内存之后，成为操作系统调度执行的一个任务，就称为`进程（Process）`

进程和程序`不是一一对应`的。一个程序可以多次加载到内存，成为同时运行的多个进程，例如可以同时开多个终端窗口，每个窗口都运行一个Shell进程，而它们对应的程序都是磁盘上的`/bin/bash`文件。



`操作系统（Operating System）`本身也是一段保存在磁盘上的程序，计算机在启动时执行一段固定的`启动代码（称为Bootloader）`

操作系统和其它用户程序的不同之处在于：`操作系统是常驻内存的`，而其它用户程序则不一定

`操作系统最核心`的功能是`管理进程调度、管理内存的分配使用和管理各种设备`，做这些工作的程序称为`内核（Kernel）`，在我的系统上内核程序是`/boot/vmlinuz-2.6.28-13-generic`文件，它在计算机启动时加载到内存并常驻内存。`广义上`操作系统的概念还包括一些必不可少的用户程序，比如Shell是每个Linux系统必不可少的，而Office办公套件则是可有可无的，所以前者也属于广义上操作系统的范畴，而后者属于应用软件。



键盘设备主动通知CPU来读这个字符并做相应处理，给用户响应。这是由`中断（Interrupt）机制`实现的，每个设备都有一条中断线，通过中断控制器连接到CPU，当设备需要主动通知CPU时就引发一个中断信号，CPU正在执行的指令将被打断，程序计数器会指向某个固定的地址（这个地址由体系结构定义），于是CPU从这个地址开始取指令（或者说跳转到这个地址），执行`中断服务程序（ISR，Interrupt Service Routine）`，完成中断处理之后再返回先前被打断的地方执行后续指令。



由于各种设备的操作方法各不相同，每种设备都需要专门的`设备驱动程序（Device Driver）`，一个操作系统为了支持广泛的设备就需要有大量的设备驱动程序，事实上Linux内核源代码中绝大部分是设备驱动程序。设备驱动程序通常是`内核里的一组函数`，通过读写设备寄存器实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供ISR调用。



## 3.虚拟内存与MMU

现代操作系统普遍采用`虚拟内存管理（Virtual Memory Management）`机制，这需要处理器中的`MMU（Memory Management Unit，内存管理单元）`提供支持



MMU将`VA(虚拟地址Virtual Address)`映射到`PA(Physical Address 物理地址)`是以`页（Page）`为单位的，`32位处理器的页尺寸通常是4KB`。例如，MMU可以通过一个映射项将VA的一页0xb7001000~0xb7001fff映射到PA的一页0x2000~0x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。物理内存中的页称为`物理页面或者页帧（Page Frame）`。虚拟内存的哪个页面映射到物理内存的哪个页帧是通过`页表（Page Table）`来描述的，页表保存在物理内存中，MMU会查找页表来确定一个VA应该映射到什么PA。



MMU除了做地址转换之外，还提供`内存保护机制`。各种体系结构都有`用户模式（User Mode）`和`特权模式（Privileged Mode）`之分，操作系统可以在页表中设置每个内存页面的访问权限，有些页面不允许访问，有些页面只有在CPU处于特权模式时才允许访问，有些页面在用户模式和特权模式都可以访问，`访问权限又分为可读、可写和可执行三种`。



`异常（Exception）`。异常的处理过程和中断类似，不同的是中断由外部设备产生而异常由CPU内部产生，中断产生的原因和CPU当前执行的指令无关，而异常的产生就是由于CPU当前执行的指令出了问题，例如访问内存的指令被MMU检查出权限错误，除法指令的除数为0等都会产生异常。



通常操作系统把`虚拟地址空间`划分为`用户空间和内核空间`，例如`x86平台`的`Linux系统`虚拟地址空间是`0x00000000~0xffffffff`，`前3GB`（0x00000000~0xbfffffff）是`用户空间`，`后1GB`（0xc0000000~0xffffffff）是`内核空间`。 

用户程序加载到用户空间，在用户模式下执行，不能访问内核中的数据，也不能跳转到内核代码中执行。这样可以`保护内核`，如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性



在正常情况下处理器在用户模式执行用户程序，在`中断或异常情况下`处理器`切换`到`特权模式`执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。



`段错误我们已经遇到过很多次了，它是这样产生的：`

1. `用户程序要访问的一个VA，经MMU检查无权访问。`
2. `MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序。`
3. `内核把这个异常解释为段错误，把引发异常的进程终止掉。`



VA

**扩展内存容量**：虚拟内存结合磁盘，提供比物理内存更大的可用空间。

**内存隔离和安全**：为每个进程提供独立的地址空间，防止进程间互相干扰。

**提高资源利用率**：支持按需加载，仅加载必要数据，节省物理内存。

**简化内存管理**：程序使用统一的虚拟地址空间，操作系统动态分配物理内存。

**支持数据共享和内存映射**：支持多进程共享内存区域和文件内存映射操作。

**提高系统稳定性**：通过分页和保护机制，防止非法访问并增强多任务稳定性。



## 4.Memory Hierarchy内存层次结构

cache 缓存

| 存储器类型 | 位于哪里                                                     | 存储容量                                                     | 半导体工艺                                                   | 访问时间                                               | 如何访问                                                     |
| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------- | :----------------------------------------------------------- |
| CPU寄存器  | 位于CPU执行单元中。                                          | CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节。 | “寄存器”这个名字就是一种数字电路的名字，它由一组触发器（Flip-flop）组成，每个触发器保存一个Bit的数据，可以做存取和移位等操作。计算机掉电时寄存器中保存的数据会丢失。 | 寄存器是访问速度最快的存储器，典型的访问时间是几纳秒。 | 使用哪个寄存器，如何使用寄存器，这些都是由指令决定的。       |
| Cache      | 和MMU一样位于CPU核中。                                       | Cache通常分为几级，最典型的是如上图所示的两级Cache，一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB。 | Cache和内存都是由RAM（Random Access Memory）组成的，可以根据地址随机访问，计算机掉电时RAM中保存的数据会丢失。不同的是，Cache通常由SRAM（Static RAM，静态RAM）组成，而内存通常由DRAM（Dynamic RAM，动态RAM）组成。DRAM电路比SRAM简单，存储容量可以做得更大，但DRAM的访问速度比SRAM慢。 | 典型的访问时间是几十纳秒。                             | Cache缓存最近访问过的内存数据，由于Cache的访问速度是内存的几十倍，所以有效利用Cache可以大大提高计算机的整体性能。一级Cache是这样工作的：CPU执行单元要访问内存时首先发出VA，Cache利用VA查找相应的数据有没有被缓存，如果Cache中有就不需要访问物理内存了，如果是读操作就直接将Cache中的数据传给CPU寄存器，如果是写操作就直接改写到Cache中；如果Cache没有缓存该数据，就去物理内存中取数据，但并不是要哪个字节就取哪个字节，而是把相邻的几十个字节都取上来缓存着，以备下次用到，这称为一个Cache Line，典型的Cache Line大小是32~256字节。如果计算机还配置了二级缓存，则在访问物理内存之前先用PA去二级缓存中查找。一级缓存是用VA寻址的，二级缓存是用PA寻址的，这是它们的区别。Cache所做的工作是由硬件自动完成的，而不是像寄存器一样由指令决定先做什么后做什么。 |
| 内存       | 位于CPU外的芯片，与CPU通过地址和数据总线相连。               | 典型的存储容量是几百MB到几GB。                               | 由DRAM组成，详见上面关于Cache的说明。                        | 典型的访问时间是几百纳秒。                             | 内存是通过地址来访问的，在启用MMU的情况下，程序指令中的地址是VA，而访问内存用的是PA，它们之间的映射关系由操作系统维护。 |
| 硬盘       | 位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘。 | 典型的存储容量是几百GB到几TB。                               | 硬盘由磁性介质和磁头组成，访问硬盘时存在机械运动，磁头要移动，磁性介质要旋转，机械运动的速度很难提高到电子的速度，所以访问速度很受限制。保存在硬盘上的数据掉电后不会丢失。 | 典型的访问时间是几毫秒，是寄存器访问时间的106倍。      | 由驱动程序操作设备总线控制器去访问。由于硬盘的访问速度较慢，操作系统通常一次从硬盘上读几个页面到内存中缓存起来，如果这几个页面后来都被程序访问到了，那么这一次读硬盘的时间就可以分摊（Amortize）给程序的多次访问了。 |



所以`预读缓存的`办法是很有效的：CPU取一条指令，我把和它`相邻的指令`也都缓存起来，CPU很可能马上就会取到；CPU访问一个数据，我把和它`相邻的数据`也都缓存起来，CPU很可能马上就会访问到。  这实际上 就用到了 虚拟内存技术



------

# 十一 x86汇编

1.简单的汇编程序

将 汇编代码 作为 .s 保存

先使用 汇编器







------

# 附录 编程过程和概念里出现的 英文单词术语

## 1.segmentation fault

段错误

## 2.implementation_define  unspecified  undefine

```c++
在 C 和 C++ 编程中，术语 implementation-defined、unspecified 和 undefined 表示三种不同的行为规范。它们在标准中定义不同的行为范围，以帮助开发者理解程序在特定情况下的表现和潜在风险。

1. Implementation-Defined Behavior（实现定义的行为）
定义：实现定义的行为是指某些行为依赖于编译器或平台，由编译器实现者选择具体的行为方式。
特点：这种行为必须明确记录在编译器的文档中，且在同一实现环境中表现一致。
例子：
int、float、double 等类型的具体大小（如 32 位或 64 位）。
字符类型 char 是否为有符号或无符号。
字节顺序（大端或小端）。
2. Unspecified Behavior（未指定的行为）
定义：未指定的行为指的是标准允许多种合法行为，但没有规定具体的选择。编译器可以自由地选择某种行为，而无需在文档中详细说明。
特点：未指定的行为可能在不同的实现或编译器版本中有所不同，但它不会导致程序崩溃。
例子：
函数参数的求值顺序，例如 f(x++, x++)。
表达式中多个未序列化的副作用顺序，如 a[i] = i++;。
3. Undefined Behavior（未定义的行为）
定义：未定义的行为指的是标准未规定的行为，导致编译器对该行为没有任何约束，程序可能出现不可预测的结果。
特点：未定义的行为可能导致程序崩溃、数据损坏，甚至会在编译时产生意想不到的输出。编译器在遇到未定义行为时不负责任何后果。
例子：
数组越界访问，例如 arr[10] 在长度为 10 的数组 arr 上。
对空指针解引用，例如 *ptr 当 ptr 为 nullptr。
使用未初始化的变量。
总结
Implementation-Defined：行为在编译器中有特定定义，并记录在文档中。
Unspecified：允许多种合法行为，但编译器无需明确记录，且在不同编译器间可能不同。
Undefined：标准未定义，可能导致程序不可预测的行为，使用时要特别小心。
```



## 3.side effect和sequence point



```c++
 Side Effect（副作用）
定义：副作用是指在表达式求值过程中对程序状态（例如变量值、内存内容）的更改。这些更改可能会影响程序的后续行为。
常见副作用：
修改变量的值（例如 x++ 或 x = 5）。
I/O 操作，例如 printf()、scanf()。
动态内存分配和释放（如 new 或 delete）。
```

例子:

```c++
int x = 5;
int y = x++ + 3; // x++ 是一个带有副作用的操作，因为它会改变 x 的值。
在这个例子中，x++ 不仅计算 x 的值，还会对 x 进行递增操作，这是一个副作用。

```





```c++
 Sequence Point（序列点）
定义：序列点是一个程序中确定的时间点，在该点之前的所有副作用都被保证完成（执行完毕），并且不会与该点之后的副作用发生冲突。

序列点确保了程序中的某些操作具有确定的执行顺序，防止在求值顺序不确定时出现未定义行为。

常见的序列点：

表达式和表达式之间，例如在 &&、||、? :、,（逗号运算符）中。
完整的表达式末尾，例如每个语句结束时。
函数调用时，所有参数的副作用都在函数调用前完成。
```

例子:

```c++
int a = 1;
int b = (a++ > 0) && (a++ < 5); // '&&' 是一个序列点
在这个例子中，a++ > 0 的副作用在 && 之前完成，保证了 a 的值在 a++ < 5 之前递增。
```



```c++
Side Effect 和 Sequence Point 的关系
序列点的存在确保了在某些表达式中副作用按顺序执行，从而避免了未定义行为。
在没有明确序列点的情况下，如果对同一对象有多次未序列化的修改，可能会导致 未定义行为
```

例子:

```c++
int i = 0;
i = i++; // 未定义行为：i 同时在表达式中被读取和修改，且没有序列点。
在这种情况下，i 的自增和赋值在没有序列点的情况下同时发生，因此编译器行为不可预测。

不同的编译器 可能执行结果 并不一样

据 C 和 C++ 的标准，如果在同一个表达式中对一个对象（如 i）进行了多次修改，并且这些修改之间没有确定的求值顺序或序列点，就会出现未定义行为。
```



```c++
C++11 之后的变化：Sequence Point 被 Sequence 替代
在 C++11 标准中，"sequence point" 的概念被更通用的 "sequenced before"、"sequenced after" 所替代。新的标准定义了更明确的求值顺序规则，用以下三种关系描述操作的顺序：

Sequenced Before：一个操作在另一个操作之前按顺序执行。
Sequenced After：一个操作在另一个操作之后按顺序执行。
Unsequenced：两个操作的执行顺序未定义，且没有依赖关系。
这种方式定义更加灵活，帮助编译器优化程序，同时也减少了未定义行为的可能性
```



## 4.fetch

指令   不同的计算机领域, 含义不太一样



## 5.register

寄存器
