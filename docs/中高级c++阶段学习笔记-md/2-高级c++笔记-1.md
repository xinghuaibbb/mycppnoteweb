[TOC]



# 1.内容提纲

1. 对象的应用优化、右值引用的优化
2. 智能指针
3. 绑定器和函数对象、lambda表达式
4. C++11内容汇总、多线程应用实践
5. 设计模式
6. 面向对象编程实践
  1. 深度遍历搜索迷宫路径
  2. 广度遍历搜索迷宫路径找最短路径
  3. 大数加减法
  4. 海量数据查重以及求top k问题
  5. 数字化男女匹配问题
7. 校招C++面经讲解
8. 应聘C++研发岗简历该怎么

# 2.对象被优化后, 才是高效的c++编程

**注意, 这节讲的, 有很多 和现代编译器的结果不同, 注意RVO的默认开启**

## 1.对象使用背后调用了哪些方法

1. 代码实例:

   ```c++
   #include <iostream>
   #include <vector>
   #include <algorithm>
   #include <functional>
   using namespace std;
   class Test{
   public:
       Test(int a = 10) :ma(a)
       {
           cout << "Test()" << endl;
       }
       ~Test()
       {
           cout << "~Test()" << endl;
       }
       Test(const Test& t) :ma(t.ma)
       {
           cout << "Test(const Test&)" << endl;
       }
       Test& operator=(const Test& t)
       {
           cout << "operator=" << endl;
           ma = t.ma;
           return *this;
       }
   private:
       int ma;
   };
   
   int main()
   {
       Test t1;
       Test t2(t1); // 拷贝构造
       Test t3 = t1; //拷贝构造
   
       //c++编译器对于对象构造的优化: 用临时对象生成新对象时,临时对象就不产生了, 直接构造新对象就行了
       Test t4 = Test(20);  // Test(20)临时对象,生存周期: 所在语句  
       //等价于
       Test t5(20);
       cout << "------------" << endl;
   
       t4 = t2;  // 赋值, 不是构造
   
       //operator=,  需要传参, 
       //这两是 显示生成临时对象
       t4 = Test(30);  // 赋值, 这个临时对象必须生成, 
       t4 = (Test)20; //int->Test(int), 编译器发现要转的类型里有int , 就可以编译器隐式转换, 
   
   
       // 隐式生成临时对象
       t4 = 30; //int->Test(int)
       cout << "------------" << endl;
   
   
       Test* p = &Test(50);  // 临时对象, 出了这个语句就没了, 析构了. 地址也就没了
       const Test& ref = Test(50);  // 引用临时对象, 需要常引用, vs版本高, 检查严格
       // 引用是可以的,  引用虽然和指针很像, 但实际是  起别名, 离开这个语句, 临时对象不会析构
       //引用在C++中是一个别名（alias），它本质上是对某个对象的另一个名字。
       //临时对象变为了 引用变量, 声明周期是整个函数里
   
   
       return 0;
   }
   ```

2. 结论:**指针指向临时变量是不安全的, 但是 引用 是安全的**

   

3. 代码示例: 各种情况

   ```c++
   #include <iostream>
   #include <vector>
   #include <algorithm>
   #include <functional>
   using namespace std;
   
   class Test {
   public:
       Test(int a=5, int b=5) : ma(a), mb(b) {
           cout << "Test(int, int)" << endl;
       }
       ~Test() {
           cout << "~Test()" << endl;
       }
       Test(const Test& t) : ma(t.ma), mb(t.mb) {
           cout << "Test(const Test&)" << endl;
       }
       Test& operator=(const Test& t) {
           cout << "operator=" << endl;
           ma = t.ma;
           mb = t.mb;
           return *this;
       }
   private:
       int ma;
       int mb;
   };
   
   Test t1(10, 10);  // 1. 全局变量先构造, 普通构造
   
   int main() {
       Test t2(20, 20);   // 3. 普通构造
       Test t3 = t2; // 4. 拷贝构造
       static Test t4 = Test(30, 30);  // 5. 静态局部变量, 程序运行到这里才 构造  临时对象被优化, 仅t4的普通构造    等价于 static Test t4(30, 30)
       t2 = Test(40, 40);  // 6. 显示生成临时对象 先临时对象普通构造, 再operator= 析构
       t2 = (Test)(50, 50); // 7. 隐式生成临时对象 先临时对象普通构造, 再operator= 析构
       t2 = 60;  //8. 隐式生成临时对象 先临时对象普通构造, 再operator= 析构
       Test* p1 = new Test(70, 70); // 9.指针, new了, 非临时对象, 普通构造 , 不析构, 没有delete
       Test* p2 = new Test[2];  // 10. 数组, 两次普通构造 , 不析构, 没有delete
       //Test* p3 = &Test(80, 80);  // 11. 指针, 普通构造 , 但是出了这句 就析构了  成为 悬空指针 会被警告, 无法编译执行
   
       const Test& p4 = Test(90, 90); //12. 引用, 普通构造, 出了这句不析构, 出了函数析构
       delete p1;  // 13. 析构 p1
       delete[] p2; // 14. 析构 p2,两次析构
   }               // 15. 12析构, 4析构, 3析构, 5析构, 静态局部变量在数据段, 程序结束才析构, 2析构, 1析构
   
   
   
   Test t5(100, 100); // 2. 全局变量先构造, 普通构造
   ```



## 2.函数调用过程中对象背后调用方法

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

class Test {
public:
    Test(int a = 10) :ma(a) {
        cout << "Test()" << endl;
    }
    ~Test() {
        cout << "~Test()" << endl;
    }
    Test(const Test& t) :ma(t.ma) {
        cout << "Test(const Test&)" << endl;
    }
    Test& operator=(const Test& t) {
        cout << "operator=" << endl;
        ma = t.ma;
        return *this;
    }

    int GetData()const {
        return ma;
    }
private:
    int ma;
};

Test GetObject(Test t) {
    int val = t.GetData();
    Test tmp(val);
    return tmp;  //不能返回 局部的或者临时对象的指针

    /*
    static Test tmp(val);
    return &tmp;
    */
}

int main() {
    Test t1;        // 1. 调用默认构造函数
    Test t2;        // 2. 调用默认构造函数
    t2 = GetObject(t1);  // 3. 调用拷贝构造函数（参数传递）
    // 4. 调用默认构造函数（创建 tmp）
    // 5. 调用拷贝构造函数（返回 tmp） 会返回一个临时对象, 这个不会被优化哈
    // 6. 析构 tmp
    // 7. 析构参数 t
    // 8. 调用赋值运算符（将返回值赋给 t2）
    // 9. 析构临时对象
    return 0;
    // 10. 析构 t2
    // 11. 析构 t1
}

Test()
Test()
Test(const Test&)
Test()
~Test()
operator=
~Test()
~Test()
~Test()
```



**注意: 以上标注只是NRVO情况, 现在的编译器默认开启RVO**----**自己补充**    会变为9个

```c++
//5和9  由于现在大多数默认启用了RVO, 将不会存在  RVO 在 C++17 之后变成“强制优化”
// RVO（Return Value Optimization，返回值优化）是 C++ 编译器的一种优化技术，用于减少临时对象的创建，提升程序性能。它的核心思想是 避免拷贝构造，直接在目标位置构造对象。

// RVO优化后
/*
Test GetObject(Test t) {
    int val = t.GetData();
    return Test(val);  // 直接构造在 t2 的内存位置上
}

*/
```



## 3.总结三条对象优化的规则

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

class Test {
public:
    Test(int a = 10) :ma(a) {
        cout << "Test()" << endl;
    }
    ~Test() {
        cout << "~Test()" << endl;
    }
    Test(const Test& t) :ma(t.ma) {
        cout << "Test(const Test&)" << endl;
    }
    Test& operator=(const Test& t) {
        cout << "operator=" << endl;
        ma = t.ma;
        return *this;
    }

    int GetData()const {
        return ma;
    }
private:
    int ma;
};

Test GetObject(Test& t) {  // 仅换为引用, 就减少了 t的拷贝构造和析构  
    int val = t.GetData();
    // Test tmp(val);
    //return tmp;  
    return Test(val);  // 返回临时对象, 会直接在main函数 构造临时对象   
    //这个在现代编译器无变化, RVO会默认开启
    //临时对象 优化 比较复杂, 先浅理解


}

int main() {
    Test t1;        
    Test t2 = GetObject(t1);       //而如果用临时对象 拷贝构造 新对象, 那么临时对象就不产生了, 直接构造新对象  减少为 4个, 直接调用构造, 也不需要 operator=
    return 0;

}


```



1. 函数参数传递过程中, **对象 优先 按 引用传递**, 不要 值传递,  会减少很多 构造析构

   ```c++
   //未开启RVO
   Test()
   Test()
   Test(const Test&) // t拷贝构造
   Test()  
   Test(const Test&)  
   ~Test() 
   ~Test() // t析构
   operator=  
   ~Test() 
   ~Test()  
   ~Test()  
   
   //变为
   
   Test()
   Test() 
   Test()  
   Test(const Test&)  
   ~Test() 
   operator=  
   ~Test()  
   ~Test()  
   ~Test()
   ```

   

2. 当函数 返回对象的 时候, **应该返回一个 临时对象**, 而不要返回 一个定义过得 对象---这个在现代编译器无变化, RVO会默认开启

   ```c++
   Test()
   Test() 
   Test()  
   Test(const Test&)  // 返回值的tmp 拷贝构造 给main里的 临时对象
   ~Test()  // 析构返回值的这个 tmp
   operator=  
   ~Test()  
   ~Test()  
   ~Test() 
   
   //变为
   
   Test()
   Test()
   Test()  // 返回临时对象, 会直接在main函数 构造临时对象
   operator=   
   ~Test()
   ~Test()
   ~Test()
   ```

   

3. **当函数返回一个对象时，优先使用初始化方式接收返回值，而不是赋值方式。**
   使用临时对象 直接 初始化 对象, 将会舍弃临时对象, 直接 使用默认构造

   ```c++
   Test()
   Test()
   Test() // 返回临时对象, 会直接在main函数 构造临时对象
   operator=   // 临时对象 operator= 赋值
   ~Test() // 析构临时对象
   ~Test()
   ~Test()
   
   //变为
   Test()
   Test()  // 直接默认构造 t2, 不要临时对象了
   ~Test()
   ~Test()
   ```



## 4.CMyString的代码问题

String类中间 会有大量的 new和 delete, 如果不做 对象优化, 效率会非常低!!!

## 5.添加带右值引用参数的拷贝构造和赋值函数

**重点最后两个函数**



```c++
#include <iostream>
#include <cstring>
using namespace std;
class String
{
public:
    // 构造函数
    String(const char* p = nullptr)
    {
        if (p != nullptr)
        {
            _pstr = new char[strlen(p) + 1];
            cout << "new" << endl;
            strcpy(_pstr, p);
        }
        else
        {
            _pstr = new char[1];
            cout << "new" << endl;
            *_pstr = '\0';
        }
        cout << "String()" << endl;
    }

    // 析构函数
    ~String()
    {
        delete[] _pstr;
        cout << "delete" << endl;
        _pstr = nullptr;
        cout << "~String()" << endl;
    }

    // 拷贝构造函数
    String(const String& other)
    {
        _pstr = new char[strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(_pstr, other._pstr);
        cout << "String(const String)" << endl;
    }

    // 赋值运算符重载
    String& operator=(const String& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = new char[strlen(other._pstr) + 1];
            cout << "new" << endl;
            strcpy(_pstr, other._pstr);
        }
		cout << "operator=" << endl;
        return *this;
    }

    //// 加法运算符重载--未优化, 多了一次new,delete
    //String operator+(const String& other) const
    //{
    //    char* newtmp = new char[strlen(_pstr) + strlen(other._pstr) + 1];
    //    strcpy(newtmp, _pstr);
    //    strcat(newtmp, other._pstr);
    //    String newString(newtmp);
    //    delete[]newtmp;
    //    return newString;
    //}

    // 加法运算符重载--小优化后
    String operator+(const String& other) const
    {
        String newString;
        newString._pstr = new char[strlen(_pstr) + strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(newString._pstr, _pstr);
        strcat(newString._pstr, other._pstr);
        return newString;
    }

    // 比较运算符重载
    bool operator>(const String& other) const
    {
        return strcmp(_pstr, other._pstr) > 0;
    }

    bool operator<(const String& other) const
    {
        return strcmp(_pstr, other._pstr) < 0;
    }

    bool operator==(const String& other) const
    {
        return strcmp(_pstr, other._pstr) == 0;
    }

    // 长度方法
    size_t length() const
    {
        return strlen(_pstr);
    }

    // 下标运算符重载
    char& operator[](size_t index)
    {
        return _pstr[index];
    }

    const char& operator[](size_t index) const
    {
        return _pstr[index];
    }

    // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const String& str)
    {
        os << str._pstr;
        return os;
    }

    // 输入运算符重载
    friend std::istream& operator>>(std::istream& is, String& str)
    {
        char buffer[1024];
        is >> buffer;
        str = String(buffer);
        return is;  // 支持链式操作  例如: cin>>a>>b,第一次cin>>a返回cin, 即后面的变为 cin>>b
    }

    const char* c_str()const { return _pstr; }

private:
    char* _pstr;
};

String GetString(String& str)
{
    const char* pstr = str.c_str();
    String tmpstr(pstr);
    return tmpstr;   // 不开启RVO时, main函数这里会拷贝构造临时对象
	  //return String(pstr);   
}

int main()
{
    String str1 ="aaaaaaaaaa";
    String str2;
    str2 = GetString(str1);
    cout << str2.c_str() << endl;
    

    return 0;
}
```

1. 在String类中, 开启RVO, 并不使用operator= 的构造,new,delete,析构 顺序

   ```c++
   new
   String()
   new
   String()
   new
   String()
   delete
   new
   operator=
   delete
   ~String()
   aaaaaaaaaa
   delete
   ~String()
   delete
   ~String()
   ```

2. 回顾右值引用:    ----   **右值是 没有名字(临时量)或者没内存**
   **普通引用只能引用左值, 且**
   **常引用 可以 引用 右值, 但不能修改**

   **右值引用 引用右值, 且能改变值**

   ```c++
       int a = 10;
       int& b = a;
       cout << b << endl;
       //int&& c = a; // 这是不行的
       int&& c = 20;  // c可以改变临时量值
       c = 40;
   	int &f = c;
       cout << c << endl;
   
       int tmp = 20;
       int& d = tmp;   
       d = 30;
       cout << d << endl;
   
       const int& e = 20;  // 常引用可以 引用右值, 但不能修改 值
       //e = 10;
       cout << e << endl;
   ```

3. 带右值引用参数的拷贝构造-------- 实际代码里 没用--RVO使得没有 拷贝构造了

   ```c++
   String(String&& other)   // 换成右值引用   
       {//临时对象进入
           _pstr = other._pstr;  // 直接指向同一个资源
           other._pstr = nullptr;
           cout << "String(String&&)" << endl;
       }
   
   
   ```

4. 带右值引用参数的operator=   --------  **这个在代码里是 实际有效的**  --- 减少一次 new

   ```c++
   String& operator=(String&& other)
       {
           if (this != &other) // 防止自赋值
           {
               delete[] _pstr;
               cout << "delete" << endl;
               _pstr = other._pstr;  // 直接指向同一个资源
           	other._pstr = nullptr;
           }
           return *this;
       }
   ```

5. 总体代码:

   ```c++
   #include <iostream>
   #include <cstring>
   using namespace std;
   class String
   {
   public:
       // 构造函数
       String(const char* p = nullptr)
       {
           if (p != nullptr)
           {
               _pstr = new char[strlen(p) + 1];
               cout << "new" << endl;
               strcpy(_pstr, p);
           }
           else
           {
               _pstr = new char[1];
               cout << "new" << endl;
               *_pstr = '\0';
           }
           cout << "String()" << endl;
       }
   
       // 析构函数
       ~String()
       {
           delete[] _pstr;
           cout << "delete" << endl;
           _pstr = nullptr;
           cout << "~String()" << endl;
       }
   
       // 左值引用拷贝构造函数
       String(const String& other)
       {
           _pstr = new char[strlen(other._pstr) + 1];
           cout << "new" << endl;
           strcpy(_pstr, other._pstr);
           cout << "String(const String)" << endl;
       }
       //右值引用拷贝构造
       String(String&& other)   // 换成右值引用   
       {//临时对象进入
           _pstr = other._pstr;  // 直接指向同一个资源
           other._pstr = nullptr;
           cout << "String(String&&)" << endl;
       }
   
       // 左值引用赋值运算符重载
       String& operator=(const String& other)
       {
           if (this != &other) // 防止自赋值
           {
               delete[] _pstr;
               cout << "delete" << endl;
               _pstr = new char[strlen(other._pstr) + 1];
               cout << "new" << endl;
               strcpy(_pstr, other._pstr);
           }
           cout << "operator=" << endl;
           return *this;
       }
   
       //右值引用赋值运算符重载
       String& operator=(String&& other)
       {
           if (this != &other) // 防止自赋值
           {
               delete[] _pstr;
               cout << "delete" << endl;
               _pstr = other._pstr;  // 直接指向同一个资源
               other._pstr = nullptr;
           }
           cout << "operator=&&" << endl;
           return *this;
       }
   
       //// 加法运算符重载--未优化, 多了一次new,delete
       //String operator+(const String& other) const
       //{
       //    char* newtmp = new char[strlen(_pstr) + strlen(other._pstr) + 1];
       //    strcpy(newtmp, _pstr);
       //    strcat(newtmp, other._pstr);
       //    String newString(newtmp);
       //    delete[]newtmp;
       //    return newString;
       //}
   
       // 加法运算符重载--小优化后
       String operator+(const String& other) const
       {
           String newString;
           newString._pstr = new char[strlen(_pstr) + strlen(other._pstr) + 1];
           cout << "new" << endl;
           strcpy(newString._pstr, _pstr);
           strcat(newString._pstr, other._pstr);
           return newString;
       }
   
       // 比较运算符重载
       bool operator>(const String& other) const
       {
           return strcmp(_pstr, other._pstr) > 0;
       }
   
       bool operator<(const String& other) const
       {
           return strcmp(_pstr, other._pstr) < 0;
       }
   
       bool operator==(const String& other) const
       {
           return strcmp(_pstr, other._pstr) == 0;
       }
   
       // 长度方法
       size_t length() const
       {
           return strlen(_pstr);
       }
   
       // 下标运算符重载
       char& operator[](size_t index)
       {
           return _pstr[index];
       }
   
       const char& operator[](size_t index) const
       {
           return _pstr[index];
       }
   
       // 输出运算符重载
       friend std::ostream& operator<<(std::ostream& os, const String& str)
       {
           os << str._pstr;
           return os;
       }
   
       // 输入运算符重载
       friend std::istream& operator>>(std::istream& is, String& str)
       {
           char buffer[1024];
           is >> buffer;
           str = String(buffer);
           return is;  // 支持链式操作  例如: cin>>a>>b,第一次cin>>a返回cin, 即后面的变为 cin>>b
       }
   
       const char* c_str()const { return _pstr; }
   
   private:
       char* _pstr;
   };
   
   String GetString(String& str)
   {
       const char* pstr = str.c_str();
       String tmpstr(pstr);
       return tmpstr;   // 不开启RVO时, main函数这里会拷贝构造临时对象
       //return String(pstr);   
   }
   
   int main()
   {
       String str1 ("aaaaaaaaaa");
       String str2;
       str2 = GetString(str1);
   
       cout << str2.c_str() << endl;
       
       return 0;
   }
   ```

   ```c++
   new
   String()
   new
   String()
   new
   String()
   delete
   operator=&&
   delete
   ~String()
   aaaaaaaaaa
   delete
   ~String()
   delete
   ~String()
   ```



## 6.String类在vector上的应用--面试题

```c++
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
#include <iostream>
#include <cstring>
using namespace std;
class String
{
public:
    // 构造函数
    String(const char* p = nullptr)
    {
        if (p != nullptr)
        {
            _pstr = new char[strlen(p) + 1];
            cout << "new" << endl;
            strcpy(_pstr, p);
        }
        else
        {
            _pstr = new char[1];
            cout << "new" << endl;
            *_pstr = '\0';
        }
        cout << "String()" << endl;
    }

    // 析构函数
    ~String()
    {
        delete[] _pstr;
        cout << "delete" << endl;
        _pstr = nullptr;
        cout << "~String()" << endl;
    }

    // 左值引用拷贝构造函数
    String(const String& other)
    {
        _pstr = new char[strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(_pstr, other._pstr);
        cout << "String(const String)" << endl;
    }
    //右值引用拷贝构造
    String(String&& other)   // 换成右值引用   
    {//临时对象进入
        _pstr = other._pstr;  // 直接指向同一个资源
        other._pstr = nullptr;
        cout << "String(String&&)" << endl;
    }

    // 左值引用赋值运算符重载
    String& operator=(const String& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = new char[strlen(other._pstr) + 1];
            cout << "new" << endl;
            strcpy(_pstr, other._pstr);
        }
        cout << "operator=" << endl;
        return *this;
    }

    //右值引用赋值运算符重载
    String& operator=(String&& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = other._pstr;  // 直接指向同一个资源
            other._pstr = nullptr;
        }
        cout << "operator=&&" << endl;
        return *this;
    }

    //// 加法运算符重载--未优化, 多了一次new,delete
    //String operator+(const String& other) const
    //{
    //    char* newtmp = new char[strlen(_pstr) + strlen(other._pstr) + 1];
    //    strcpy(newtmp, _pstr);
    //    strcat(newtmp, other._pstr);
    //    String newString(newtmp);
    //    delete[]newtmp;
    //    return newString;
    //}

    // 加法运算符重载--小优化后
    String operator+(const String& other) const
    {
        String newString;
        newString._pstr = new char[strlen(_pstr) + strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(newString._pstr, _pstr);
        strcat(newString._pstr, other._pstr);
        return newString;
    }

    // 比较运算符重载
    bool operator>(const String& other) const
    {
        return strcmp(_pstr, other._pstr) > 0;
    }

    bool operator<(const String& other) const
    {
        return strcmp(_pstr, other._pstr) < 0;
    }

    bool operator==(const String& other) const
    {
        return strcmp(_pstr, other._pstr) == 0;
    }

    // 长度方法
    size_t length() const
    {
        return strlen(_pstr);
    }

    // 下标运算符重载
    char& operator[](size_t index)
    {
        return _pstr[index];
    }

    const char& operator[](size_t index) const
    {
        return _pstr[index];
    }

    // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const String& str)
    {
        os << str._pstr;
        return os;
    }

    // 输入运算符重载
    friend std::istream& operator>>(std::istream& is, String& str)
    {
        char buffer[1024];
        is >> buffer;
        str = String(buffer);
        return is;  // 支持链式操作  例如: cin>>a>>b,第一次cin>>a返回cin, 即后面的变为 cin>>b
    }

    const char* c_str()const { return _pstr; }

private:
    char* _pstr;
};

String GetString(String& str)
{
    const char* pstr = str.c_str();
    String tmpstr(pstr);
    return tmpstr;   // 不开启RVO时, main函数这里会拷贝构造临时对象
    //return String(pstr);   
}


int main()
{
    String str1 = "aaaaaaaaaa";
    vector<String> vec;
    vec.reserve(10);
    vec.push_back(str1);  //
    vec.push_back(String("bbbb"));
    return 0;
}


```

**面试题: 问 两次push_back 分别是 使用了什么拷贝构造?!!!**
一次左值引用拷贝, 一次右值引用拷贝
右值引用相比 左值引用, 更高效

```c++
new
String()
new
String(const String)
new
String()
String(String&&)
delete
~String()
delete
~String()
delete
~String()
delete
~String()
```



## 7.move移动语义和forword类型完美转发

### move移动语义的作用

#### 代码: 

上一节代码里, 加上 很早之前写的 Vector类:    **添加一个push_back的右值引用**

```c++
#include <iostream>
#include <cstring>
using namespace std;


#include <iostream>
using namespace std;

template<typename T>
struct Allocator
{
    T* allocate(size_t size)// 开辟内存
    {
        return (T*)malloc(sizeof(T) * size);
    }

    void deallocate(void* p) // 释放内存
    {
        free(p);
    }

    void  construct(T* p, const T& val) //对象构造
    {
        new (p) T(val); //定位new
        /*
        作用是在一块已经分配好的内存上构造一个对象，而不是通过 new 运算符动态分配内存。

p 是一个指针，指向一块预先分配好的内存。

T(val) 表示调用类型 T 的构造函数，并传递参数 val。

new (p) T(val) 的意思是在 p 指向的内存地址上构造一个 T 类型的对象，并调用构造函数 T(val)。

        */
    }

    void destroy(T* p) // 对象析构
    {
        p->~T(); //~T()代表T类型的析构函数
    }
};

template<typename T, typename Alloc = Allocator<T>>  //Alloc默认是Allocator<T>
class Vector
{
private:
    T* _first;//数组起始,与数组名
    T* _last;//数组最后位置的下一个
    T* _end;//空间的后面位置
    Alloc _allocator;//定义容器空间配置对象

    void expand() //二倍扩容
    {
        int size = _last - _first;
        //T* ptmp = new T[2 * size];
        T* ptmp = _allocator.allocate(2 * size);

        for (int i = 0; i < size; i++)
        {

            //ptmp[i] = _first[i];
            _allocator.construct(ptmp + i, _first[i]);
        }
        //delete[]_first;
        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }
        _first = ptmp;
        _last = _first + size;
        _end = _first + 2 * size;


    }

public:
    Vector(int size = 10)
    {
        //_first = new T[size];
        // 只开辟内存
        _first = _allocator.allocate(size);
        _last = _first;
        _end = _first + size;
    }

    ~Vector()
    {
        //delete[]_first;
        // 析构有效的元素并释放内存
        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }
        _allocator.deallocate(_first); //释放堆上的数组内存
        _first = _last = _end = nullptr;
    }

    Vector(const Vector<T>& src)
    {
        int size = src._end - src._first;
        //_first = new T[size];
        _first = _allocator.allocate(size);
        int len = src._last - src._first;
        for (int i = 0; i < len; i++)
        {
            //_first[i] = src._first[i];
            _allocator.construct(_first + i, src._first[i]);
        }
        _last = _first + len;
        _end = _first + size;
    }

    Vector<T>& operator=(const Vector<T>& src)
    {
        if (this == &src)
        {
            return *this;
        }

        //delete[]_first;

        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }

        int size = src._end - src._first;
        //_first = new T[size];
        _first = _allocator.allocate(size);
        int len = src._last - src._first;
        for (int i = 0; i < len; i++)
        {
            //_first[i] = src._first[i];
            _allocator.construct(_first + i, src._first[i]);
        }
        _last = _first + len;
        _end = _first + size;
        return *this;

    }
	
    //添加右值引用push_back
    void push_back(T&& val) //向容器末尾添加元素
    {
        if (full())
        {
            expand();
        }
        _allocator.construct(_last, val);
        _last++;
    }
    
    
    void push_back(const T& val) //向容器末尾添加元素
    {
        if (full())
        {
            expand();
        }
        //*_last++ = val;
        _allocator.construct(_last, val);
        _last++;
    }

    void pop_back() //向容器末尾删除元素
    {
        if (empty())
        {
            return;
        }
        --_last;
        _allocator.destroy(_last);
    }

    bool full()const
    {
        return _last == _end;
    }

    bool empty()const
    {
        return _last == _first;
    }

    T back()const // 返回末尾元素
    {
        return *(_last - 1);// *(--_last)错误的, 本函数const方法, 不能修改成员变量, _last-1是偏移量, --会改变last值
    }
};


class String
{
public:
    // 构造函数
    String(const char* p = nullptr)
    {
        if (p != nullptr)
        {
            _pstr = new char[strlen(p) + 1];
            cout << "new" << endl;
            strcpy(_pstr, p);
        }
        else
        {
            _pstr = new char[1];
            cout << "new" << endl;
            *_pstr = '\0';
        }
        cout << "String()" << endl;
    }

    // 析构函数
    ~String()
    {
        delete[] _pstr;
        cout << "delete" << endl;
        _pstr = nullptr;
        cout << "~String()" << endl;
    }

    // 左值引用拷贝构造函数
    String(const String& other)
    {
        _pstr = new char[strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(_pstr, other._pstr);
        cout << "String(const String)" << endl;
    }
    //右值引用拷贝构造
    String(String&& other)   // 换成右值引用   
    {//临时对象进入
        _pstr = other._pstr;  // 直接指向同一个资源
        other._pstr = nullptr;
        cout << "String(String&&)" << endl;
    }

    // 左值引用赋值运算符重载
    String& operator=(const String& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = new char[strlen(other._pstr) + 1];
            cout << "new" << endl;
            strcpy(_pstr, other._pstr);
        }
        cout << "operator=" << endl;
        return *this;
    }

    //右值引用赋值运算符重载
    String& operator=(String&& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = other._pstr;  // 直接指向同一个资源
            other._pstr = nullptr;
        }
        cout << "operator=&&" << endl;
        return *this;
    }

    //// 加法运算符重载--未优化, 多了一次new,delete
    //String operator+(const String& other) const
    //{
    //    char* newtmp = new char[strlen(_pstr) + strlen(other._pstr) + 1];
    //    strcpy(newtmp, _pstr);
    //    strcat(newtmp, other._pstr);
    //    String newString(newtmp);
    //    delete[]newtmp;
    //    return newString;
    //}

    // 加法运算符重载--小优化后
    String operator+(const String& other) const
    {
        String newString;
        newString._pstr = new char[strlen(_pstr) + strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(newString._pstr, _pstr);
        strcat(newString._pstr, other._pstr);
        return newString;
    }

    // 比较运算符重载
    bool operator>(const String& other) const
    {
        return strcmp(_pstr, other._pstr) > 0;
    }

    bool operator<(const String& other) const
    {
        return strcmp(_pstr, other._pstr) < 0;
    }

    bool operator==(const String& other) const
    {
        return strcmp(_pstr, other._pstr) == 0;
    }

    // 长度方法
    size_t length() const
    {
        return strlen(_pstr);
    }

    // 下标运算符重载
    char& operator[](size_t index)
    {
        return _pstr[index];
    }

    const char& operator[](size_t index) const
    {
        return _pstr[index];
    }

    // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const String& str)
    {
        os << str._pstr;
        return os;
    }

    // 输入运算符重载
    friend std::istream& operator>>(std::istream& is, String& str)
    {
        char buffer[1024];
        is >> buffer;
        str = String(buffer);
        return is;  // 支持链式操作  例如: cin>>a>>b,第一次cin>>a返回cin, 即后面的变为 cin>>b
    }

    const char* c_str()const { return _pstr; }

private:
    char* _pstr;
};

String GetString(String& str)
{
    const char* pstr = str.c_str();
    String tmpstr(pstr);
    return tmpstr;   // 不开启RVO时, main函数这里会拷贝构造临时对象
    //return String(pstr);   
}


int main()
{
    String str1 = "aaaaaaaaaa";
    Vector<String> vec;
    vec.push_back(str1);  //
    vec.push_back(String("bbbb"));
    return 0;
}


```

```c++
new
String()
new
String(const String)
new
String()
new
String(const String)
delete
~String()
delete
~String()
delete
~String()
delete
~String()
```

#### **问题: **

**发现没有使用 到 右值引用**

```c++
//添加右值引用push_back
    void push_back(const T&& val) //向容器末尾添加元素
    {
        if (full())
        {
            expand();
        }
        _allocator.construct(_last, val);
        _last++;
    }
```

是因为, 这里面 给 _allocator.construct()的val 还是左值引用

#### 解决办法:   

1. move移动语义, 强转成 右值引用类型

   ```c++
   _allocator.construct(_last, val);
   //变为
   _allocator.construct(_last, move(val));   //std::move
   
   
   ```

2. 添加 construct 右值引用

   ```c++
   //右值引用 construct  里面的 也需要 move val
   void  construct(T* p, T&& val) //对象构造
   {
       new (p) T(move(val)); 
   }
   ```

#### 最终代码: 

----- **注意. 右值引用不加const**

```c++
#include <iostream>
#include <cstring>
using namespace std;


#include <iostream>
using namespace std;

template<typename T>
struct Allocator
{
    T* allocate(size_t size)// 开辟内存
    {
        return (T*)malloc(sizeof(T) * size);
    }

    void deallocate(void* p) // 释放内存
    {
        free(p);
    }

    void  construct(T* p, const T& val) //对象构造
    {
        new (p) T(val); //定位new
        /*
        作用是在一块已经分配好的内存上构造一个对象，而不是通过 new 运算符动态分配内存。

p 是一个指针，指向一块预先分配好的内存。

T(val) 表示调用类型 T 的构造函数，并传递参数 val。

new (p) T(val) 的意思是在 p 指向的内存地址上构造一个 T 类型的对象，并调用构造函数 T(val)。

        */
    }
    //右值引用 construct  里面的 也需要 move val
    void  construct(T* p, T&& val) //对象构造
    {
        new (p) T(move(val)); 
    }

    void destroy(T* p) // 对象析构
    {
        p->~T(); //~T()代表T类型的析构函数
    }
};

template<typename T, typename Alloc = Allocator<T>>  //Alloc默认是Allocator<T>
class Vector
{
private:
    T* _first;//数组起始,与数组名
    T* _last;//数组最后位置的下一个
    T* _end;//空间的后面位置
    Alloc _allocator;//定义容器空间配置对象

    void expand() //二倍扩容
    {
        int size = _last - _first;
        //T* ptmp = new T[2 * size];
        T* ptmp = _allocator.allocate(2 * size);

        for (int i = 0; i < size; i++)
        {

            //ptmp[i] = _first[i];
            _allocator.construct(ptmp + i, _first[i]);
        }
        //delete[]_first;
        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }
        _first = ptmp;
        _last = _first + size;
        _end = _first + 2 * size;


    }

public:
    Vector(int size = 10)
    {
        //_first = new T[size];
        // 只开辟内存
        _first = _allocator.allocate(size);
        _last = _first;
        _end = _first + size;
    }

    ~Vector()
    {
        //delete[]_first;
        // 析构有效的元素并释放内存
        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }
        _allocator.deallocate(_first); //释放堆上的数组内存
        _first = _last = _end = nullptr;
    }

    Vector(const Vector<T>& src)
    {
        int size = src._end - src._first;
        //_first = new T[size];
        _first = _allocator.allocate(size);
        int len = src._last - src._first;
        for (int i = 0; i < len; i++)
        {
            //_first[i] = src._first[i];
            _allocator.construct(_first + i, src._first[i]);
        }
        _last = _first + len;
        _end = _first + size;
    }

   

    Vector<T>& operator=(const Vector<T>& src)
    {
        if (this == &src)
        {
            return *this;
        }

        //delete[]_first;

        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }

        int size = src._end - src._first;
        //_first = new T[size];
        _first = _allocator.allocate(size);
        int len = src._last - src._first;
        for (int i = 0; i < len; i++)
        {
            //_first[i] = src._first[i];
            _allocator.construct(_first + i, src._first[i]);
        }
        _last = _first + len;
        _end = _first + size;
        return *this;

    }
    //添加右值引用push_back
    void push_back(T&& val) //向容器末尾添加元素
    {
        if (full())
        {
            expand();
        }
        _allocator.construct(_last, move(val));
        _last++;
    }
    void push_back(const T& val) //向容器末尾添加元素
    {
        if (full())
        {
            expand();
        }
        //*_last++ = val;
        _allocator.construct(_last, val);
        _last++;
    }

    void pop_back() //向容器末尾删除元素
    {
        if (empty())
        {
            return;
        }
        --_last;
        _allocator.destroy(_last);
    }

    bool full()const
    {
        return _last == _end;
    }

    bool empty()const
    {
        return _last == _first;
    }

    T back()const // 返回末尾元素
    {
        return *(_last - 1);// *(--_last)错误的, 本函数const方法, 不能修改成员变量, _last-1是偏移量, --会改变last值
    }
};


class String
{
public:
    // 构造函数
    String(const char* p = nullptr)
    {
        if (p != nullptr)
        {
            _pstr = new char[strlen(p) + 1];
            cout << "new" << endl;
            strcpy(_pstr, p);
        }
        else
        {
            _pstr = new char[1];
            cout << "new" << endl;
            *_pstr = '\0';
        }
        cout << "String()" << endl;
    }

    // 析构函数
    ~String()
    {
        delete[] _pstr;
        cout << "delete" << endl;
        _pstr = nullptr;
        cout << "~String()" << endl;
    }

    // 左值引用拷贝构造函数
    String(const String& other)
    {
        _pstr = new char[strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(_pstr, other._pstr);
        cout << "String(const String)" << endl;
    }
    //右值引用拷贝构造
    String(String&& other)   // 换成右值引用   
    {//临时对象进入
        _pstr = other._pstr;  // 直接指向同一个资源
        other._pstr = nullptr;
        cout << "String(String&&)" << endl;
    }

    // 左值引用赋值运算符重载
    String& operator=(const String& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = new char[strlen(other._pstr) + 1];
            cout << "new" << endl;
            strcpy(_pstr, other._pstr);
        }
        cout << "operator=" << endl;
        return *this;
    }

    //右值引用赋值运算符重载
    String& operator=(String&& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = other._pstr;  // 直接指向同一个资源
            other._pstr = nullptr;
        }
        cout << "operator=&&" << endl;
        return *this;
    }

    //// 加法运算符重载--未优化, 多了一次new,delete
    //String operator+(const String& other) const
    //{
    //    char* newtmp = new char[strlen(_pstr) + strlen(other._pstr) + 1];
    //    strcpy(newtmp, _pstr);
    //    strcat(newtmp, other._pstr);
    //    String newString(newtmp);
    //    delete[]newtmp;
    //    return newString;
    //}

    // 加法运算符重载--小优化后
    String operator+(const String& other) const
    {
        String newString;
        newString._pstr = new char[strlen(_pstr) + strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(newString._pstr, _pstr);
        strcat(newString._pstr, other._pstr);
        return newString;
    }

    // 比较运算符重载
    bool operator>(const String& other) const
    {
        return strcmp(_pstr, other._pstr) > 0;
    }

    bool operator<(const String& other) const
    {
        return strcmp(_pstr, other._pstr) < 0;
    }

    bool operator==(const String& other) const
    {
        return strcmp(_pstr, other._pstr) == 0;
    }

    // 长度方法
    size_t length() const
    {
        return strlen(_pstr);
    }

    // 下标运算符重载
    char& operator[](size_t index)
    {
        return _pstr[index];
    }

    const char& operator[](size_t index) const
    {
        return _pstr[index];
    }

    // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const String& str)
    {
        os << str._pstr;
        return os;
    }

    // 输入运算符重载
    friend std::istream& operator>>(std::istream& is, String& str)
    {
        char buffer[1024];
        is >> buffer;
        str = String(buffer);
        return is;  // 支持链式操作  例如: cin>>a>>b,第一次cin>>a返回cin, 即后面的变为 cin>>b
    }

    const char* c_str()const { return _pstr; }

private:
    char* _pstr;
};

String GetString(String& str)
{
    const char* pstr = str.c_str();
    String tmpstr(pstr);
    return tmpstr;   // 不开启RVO时, main函数这里会拷贝构造临时对象
    //return String(pstr);   
}


int main()
{
    String str1 = "aaaaaaaaaa";
    Vector<String> vec;
    vec.push_back(str1);  //
    vec.push_back(String("bbbb"));
    return 0;
}


```

```c++
new
String()
new
String(const String)
new
String()
String(String&&)
delete
~String()
delete
~String()
delete
~String()
delete
~String()
```



### forward完美转发内容

#### 引用折叠

**引用折叠**（Reference Collapsing）是 C++11 引入的一个规则，用于处理模板和类型推导中涉及引用的复杂情况。它是实现完美转发（Perfect Forwarding）和通用引用（Universal Reference）的基础。

```
template <typename T>
void foo(T&& arg) {
    // T 的类型和 arg 的类型由引用折叠规则决定
}
```

- 如果传递一个左值（如 `int x; foo(x);`），`T` 推导为 `int&`，`arg` 的类型为 `int& &&`，折叠为 `int&`。
- 如果传递一个右值（如 `foo(42);`），`T` 推导为 `int`，`arg` 的类型为 `int&&`。

#### push_back模板  -- 直接替代左右值引用push_back

```c++
 template<typename Ty>  // 函数模板的类型推演 + 引用折叠
 void push_back(Ty&& val) 
 {
     if (full())
     {
         expand();
     }
     _allocator.construct(_last, val);   // 这里还有问题, val传进去会被认为是左值
     _last++;
 }

```



#### forward完美转发

**完美转发**（Perfect Forwarding）是 C++11 引入的一项重要特性，用于在函数模板中保留参数的值类别（左值或右值），并将其原封不动地传递给其他函数。完美转发的核心目标是避免不必要的拷贝和移动操作，同时正确处理左值和右值。

**完美转发通过以下两个特性实现：**

1. **通用引用（Universal Reference）**：

   - 使用 `T&&` 作为参数类型，可以根据传入参数的值类别推导出正确的类型（左值引用或右值引用）。

2. **`std::forward`**：

   - `std::forward` 是一个工具函数，用于保留参数的值类别。
   - 如果参数是左值，`std::forward` 返回左值引用。
   - 如果参数是右值，`std::forward` 返回右值引用。

3. 最终,push_back 修改为

   ```c++
   template<typename Ty>  // 函数模板的类型推演 + 引用折叠
   void push_back(Ty&& val) 
   {
       if (full())
       {
           expand();
       }
       _allocator.construct(_last, forward<Ty>(val)); // std::forword(val) 类型的完美转发
       _last++;
   }
   
   ```

   

#### 带有完美转发的 完整代码

construct 也可以使用模板, 不写两次

```c++
#include <iostream>
#include <cstring>
using namespace std;


#include <iostream>
using namespace std;

template<typename T>
struct Allocator
{
    T* allocate(size_t size)// 开辟内存
    {
        return (T*)malloc(sizeof(T) * size);
    }

    void deallocate(void* p) // 释放内存
    {
        free(p);
    }

//    void  construct(T* p, const T& val) //对象构造
//    {
//        new (p) T(val); //定位new
//        /*
//        作用是在一块已经分配好的内存上构造一个对象，而不是通过 new 运算符动态分配内存。
//
//p 是一个指针，指向一块预先分配好的内存。
//
//T(val) 表示调用类型 T 的构造函数，并传递参数 val。
//
//new (p) T(val) 的意思是在 p 指向的内存地址上构造一个 T 类型的对象，并调用构造函数 T(val)。
//
//        */
//    }
//    ////右值引用 construct  里面的 也需要 move val
//    //void  construct(T* p, T&& val) //对象构造
//    //{
//    //    new (p) T(move(val)); 
//    //}

    //模板, 引用折叠
    template<typename Ty>
    void  construct(T* p, Ty&& val) //对象构造
    {
        new (p) T(forward<Ty>(val));  // 注意Ty和 T
    }

    void destroy(T* p) // 对象析构
    {
        p->~T(); //~T()代表T类型的析构函数
    }
};

template<typename T, typename Alloc = Allocator<T>>  //Alloc默认是Allocator<T>
class Vector
{
private:
    T* _first;//数组起始,与数组名
    T* _last;//数组最后位置的下一个
    T* _end;//空间的后面位置
    Alloc _allocator;//定义容器空间配置对象

    void expand() //二倍扩容
    {
        int size = _last - _first;
        //T* ptmp = new T[2 * size];
        T* ptmp = _allocator.allocate(2 * size);

        for (int i = 0; i < size; i++)
        {

            //ptmp[i] = _first[i];
            _allocator.construct(ptmp + i, _first[i]);
        }
        //delete[]_first;
        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }
        _first = ptmp;
        _last = _first + size;
        _end = _first + 2 * size;


    }

public:
    Vector(int size = 10)
    {
        //_first = new T[size];
        // 只开辟内存
        _first = _allocator.allocate(size);
        _last = _first;
        _end = _first + size;
    }

    ~Vector()
    {
        //delete[]_first;
        // 析构有效的元素并释放内存
        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }
        _allocator.deallocate(_first); //释放堆上的数组内存
        _first = _last = _end = nullptr;
    }

    Vector(const Vector<T>& src)
    {
        int size = src._end - src._first;
        //_first = new T[size];
        _first = _allocator.allocate(size);
        int len = src._last - src._first;
        for (int i = 0; i < len; i++)
        {
            //_first[i] = src._first[i];
            _allocator.construct(_first + i, src._first[i]);
        }
        _last = _first + len;
        _end = _first + size;
    }

   

    Vector<T>& operator=(const Vector<T>& src)
    {
        if (this == &src)
        {
            return *this;
        }

        //delete[]_first;

        for (T* p = _first; p != _last; ++p)
        {
            _allocator.destroy(p); //析构_first指针指向的数组的有效元素
        }

        int size = src._end - src._first;
        //_first = new T[size];
        _first = _allocator.allocate(size);
        int len = src._last - src._first;
        for (int i = 0; i < len; i++)
        {
            //_first[i] = src._first[i];
            _allocator.construct(_first + i, src._first[i]);
        }
        _last = _first + len;
        _end = _first + size;
        return *this;

    }
    template<typename Ty>  // 函数模板的类型推演 + 引用折叠
    void push_back(Ty&& val) 
    {
        if (full())
        {
            expand();
        }
        _allocator.construct(_last, forward<Ty>(val)); // std::forword(val) 类型的完美转发
        _last++;
    }

    ////添加右值引用push_back
    //void push_back(T&& val) //向容器末尾添加元素
    //{
    //    if (full())
    //    {
    //        expand();
    //    }
    //    _allocator.construct(_last, move(val));
    //    _last++;
    //}
    //void push_back(const T& val) //向容器末尾添加元素
    //{
    //    if (full())
    //    {
    //        expand();
    //    }
    //    //*_last++ = val;
    //    _allocator.construct(_last, val);
    //    _last++;
    //}

    void pop_back() //向容器末尾删除元素
    {
        if (empty())
        {
            return;
        }
        --_last;
        _allocator.destroy(_last);
    }

    bool full()const
    {
        return _last == _end;
    }

    bool empty()const
    {
        return _last == _first;
    }

    T back()const // 返回末尾元素
    {
        return *(_last - 1);// *(--_last)错误的, 本函数const方法, 不能修改成员变量, _last-1是偏移量, --会改变last值
    }
};


class String
{
public:
    // 构造函数
    String(const char* p = nullptr)
    {
        if (p != nullptr)
        {
            _pstr = new char[strlen(p) + 1];
            cout << "new" << endl;
            strcpy(_pstr, p);
        }
        else
        {
            _pstr = new char[1];
            cout << "new" << endl;
            *_pstr = '\0';
        }
        cout << "String()" << endl;
    }

    // 析构函数
    ~String()
    {
        delete[] _pstr;
        cout << "delete" << endl;
        _pstr = nullptr;
        cout << "~String()" << endl;
    }

    // 左值引用拷贝构造函数
    String(const String& other)
    {
        _pstr = new char[strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(_pstr, other._pstr);
        cout << "String(const String)" << endl;
    }
    //右值引用拷贝构造
    String(String&& other)   // 换成右值引用   
    {//临时对象进入
        _pstr = other._pstr;  // 直接指向同一个资源
        other._pstr = nullptr;
        cout << "String(String&&)" << endl;
    }

    // 左值引用赋值运算符重载
    String& operator=(const String& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = new char[strlen(other._pstr) + 1];
            cout << "new" << endl;
            strcpy(_pstr, other._pstr);
        }
        cout << "operator=" << endl;
        return *this;
    }

    //右值引用赋值运算符重载
    String& operator=(String&& other)
    {
        if (this != &other) // 防止自赋值
        {
            delete[] _pstr;
            cout << "delete" << endl;
            _pstr = other._pstr;  // 直接指向同一个资源
            other._pstr = nullptr;
        }
        cout << "operator=&&" << endl;
        return *this;
    }

    //// 加法运算符重载--未优化, 多了一次new,delete
    //String operator+(const String& other) const
    //{
    //    char* newtmp = new char[strlen(_pstr) + strlen(other._pstr) + 1];
    //    strcpy(newtmp, _pstr);
    //    strcat(newtmp, other._pstr);
    //    String newString(newtmp);
    //    delete[]newtmp;
    //    return newString;
    //}

    // 加法运算符重载--小优化后
    String operator+(const String& other) const
    {
        String newString;
        newString._pstr = new char[strlen(_pstr) + strlen(other._pstr) + 1];
        cout << "new" << endl;
        strcpy(newString._pstr, _pstr);
        strcat(newString._pstr, other._pstr);
        return newString;
    }

    // 比较运算符重载
    bool operator>(const String& other) const
    {
        return strcmp(_pstr, other._pstr) > 0;
    }

    bool operator<(const String& other) const
    {
        return strcmp(_pstr, other._pstr) < 0;
    }

    bool operator==(const String& other) const
    {
        return strcmp(_pstr, other._pstr) == 0;
    }

    // 长度方法
    size_t length() const
    {
        return strlen(_pstr);
    }

    // 下标运算符重载
    char& operator[](size_t index)
    {
        return _pstr[index];
    }

    const char& operator[](size_t index) const
    {
        return _pstr[index];
    }

    // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const String& str)
    {
        os << str._pstr;
        return os;
    }

    // 输入运算符重载
    friend std::istream& operator>>(std::istream& is, String& str)
    {
        char buffer[1024];
        is >> buffer;
        str = String(buffer);
        return is;  // 支持链式操作  例如: cin>>a>>b,第一次cin>>a返回cin, 即后面的变为 cin>>b
    }

    const char* c_str()const { return _pstr; }

private:
    char* _pstr;
};

String GetString(String& str)
{
    const char* pstr = str.c_str();
    String tmpstr(pstr);
    return tmpstr;   // 不开启RVO时, main函数这里会拷贝构造临时对象
    //return String(pstr);   
}



int main()
{
    String str1 = "aaaaaaaaaa";
    Vector<String> vec;
    vec.push_back(str1);  //
    vec.push_back(String("bbbb"));
    return 0;
}


```

### 总结

move 是为了得到 右值类型
forward 是为了 能够正确识别 左值和右值类型---**一般配合模板使用,很方便,不需要写那么多重载**

模板中的 引用折叠 很好的解决了 重载麻烦的问题

**很灵活的!!!**





# 智能指针

内容大纲

```c++
智能指针介绍
自己实现智能指针
不带引用计数的 智能指针 auto_ptr, scoped_ptr, unique_ptr
带引用计数的 智能指针shared_ptr, weak_ptr
智能指针的 交叉引用问题(循环引用)
多线程访问共享对象问题
自定义删除器

```



## 1.基础--实现简单的智能指针

1. 裸指针是什么?
   **裸指针（Raw Pointer）** 是 C++ 中的一种基本指针类型，它直接存储内存地址，不附带任何额外的管理功能（如自动内存管理或生命周期管理）。裸指针是 C++ 中最原始的指针形式，通常用于直接操作内存。
   没有自动内存管理功能，容易导致悬空指针、内存泄漏等问题。  需要手动释放

2. 裸指针缺点:

   ```c++
   1. 忘记释放资源，导致资源泄露（常发生内存泄漏问题）
   2. 同一资源释放多次，导致释放野指针，程序崩溃
   3. 明明代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间
   return掉了，导致释放资源的代码未被执行到，懵
   4. 代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到，
   懵
   ```

3. **智能指针**，智能指针的智能二字，主要体现在用户可以**不关注资源的释放，因为智能指针**
   **会帮你完全管理资源的释放**，它会保证无论程序逻辑怎么跑，正常执行或者产生异
   常，**资源在到期的情况下，一定会进行释放**。

4. **实现一个简单的 智能指针**

   ```c++
   #include <iostream>
   #include <cstring>
   using namespace std;
   
   template<typename T>
   class CSmartPtr
   {
   public:
       CSmartPtr(T* ptr = nullptr) : mptr(ptr) {}
       ~CSmartPtr() { delete mptr; }
   
       T& operator* () { return *mptr; }  // 必须引用, 否则不能修改
   
       T* operator->() { return mptr; }
   private:
       T* mptr;
   };
   
   int main()
   {
       // int *p = new int;
       CSmartPtr<int> ptr1(new int);
      
       *ptr1 = 20;   // 虽然 ptr1 本身是普通对象, 但是里面是指针,想要访问指针, 除了写访问函数, 还能用 *重载 
   
       class Test
       {
       public:
           void test() { cout << "test" << endl; }
       };
   
       CSmartPtr<Test> ptr2(new Test()); 
       (*ptr2).test();  // 好好理解,为什么要用*,
       ptr2->test(); 
        return 0;
   }
   
   ```

   利用栈上的 对象, 出作用域 自动析构的特征, 做到资源的 自动释放!

## 2.不带引用计数的智能指针

### 问题

1. 上一节代码里, 加入做下面这个:

   ```c++
    CSmartPtr<int> ptr1(new int);
    CSmartPtr<int> ptr2(ptr1);
   ```

   **默认拷贝构造是一个浅拷贝**

   1. **浅拷贝**：
      - 仅复制指针的值（内存地址）。
      - 多个对象共享同一块动态内存。
      - 适用于没有动态内存或资源的对象。
   2. **深拷贝**：
      - 复制指针所指向的实际数据。
      - 每个对象拥有独立的动态内存副本。
      - 适用于有动态内存或资源的对象。

   **会导致 两次析构 释放同一个值, 造成野指针问题**

   **野指针（Wild Pointer）** 是指未初始化或指向已释放内存的指针。野指针的行为是未定义的，访问或修改野指针指向的内存可能导致程序崩溃、数据损坏或安全漏洞。

### 解决

1. 使用 自定义的 深拷贝 构造函数, 可以解决这个问题
2. **不带引用计数的智能指针 解决**

### 不带引用计数的智能指针汇总

那些**独占所有权**的智能指针
**禁止拷贝和赋值重载,auto_ptr例外**
**自动释放**

#### auto_ptr   -- #include < memory >  -- 不推荐

**它在 C++11 中被弃用，并在 C++17 中被移除。** why?

```c++
//c++库里

int main()
{
    auto_ptr<int>  ptr1(new int);   
    auto_ptr<int>  ptr2(ptr1);  // auto_ptr 源码显示, 在拷贝构造时, 会把原来的ptr1的指针置空

    *ptr2 = 20;
    cout << *ptr1 << endl;  // 错误
     return 0;
}
```

也就是说, 拷贝构造会使得 原来的 所有的 指针 都会 置空, 不能再访问这块内存

```c++
std::auto_ptr 采用独占所有权模型，但在拷贝或赋值时会发生所有权转移。

这意味着，当一个 auto_ptr 被拷贝或赋值给另一个 auto_ptr 时，原指针会失去所有权，变为 nullptr。

这种行为容易导致意外的所有权转移和悬空指针问题。
```





#### scoped_ptr  --- 不推荐

`scoped_ptr` 是 Boost 库中提供的一种智能指针，用于在特定作用域内管理动态分配的内存。
**主要特点**:**禁止拷贝和赋值，从而避免所有权转移的问题**
直接把 里面的 拷贝构造=delete;   operator=() = delete



#### unique_ptr -- 推荐  -- 右值引用--move

直接把 里面的 左值引用拷贝构造=delete;   operator=() = delete

**但是**, 提供了 **右值 引用 拷贝构造  和 右值引用 operator=**, 因此 需要移动语义



虽然同样是 所有权, 但是 **好处**是, 可以**清楚**地 看出来, 是在**转移 资源**

```c++
int main()
{
    unique_ptr<int>  ptr1(new int);
    unique_ptr<int>  ptr2(move(ptr1)); // 需要移动语义, 好处, 清晰可见

    *ptr2 = 20;
    cout << *ptr1 << endl;  // 也是错误的, 
     return 0;
}

```





## 3.带引用计数的智能指针 

**好处: 多个指针 可以管理同一个资源**

给每一个对象资源, 匹配一个引用计数



1. 实现简单的 引用计数 智能指针----还是比较麻烦的

```c++
#include <iostream>

// 引用计数类
class RefCnt {
public:
    RefCnt(void* ptr = nullptr) : ptr_(ptr), count_(1) {}

    // 增加引用计数
    void addRef() {
        ++count_;
    }

    // 减少引用计数，如果计数为 0 则释放资源
    void release() {
        --count_;
        if (count_ == 0) {
            delete static_cast<int*>(ptr_);  // 假设资源是 int 类型
            delete this;  // 释放引用计数对象本身
        }
    }

    int getCount() const {
        return count_;
    }

private:
    void* ptr_;      // 指向资源的指针
    int count_;      // 引用计数
};

// 智能指针类
template<typename T>
class CSmartPtr {
public:
    // 构造函数
    CSmartPtr(T* ptr = nullptr) : mptr(ptr) {
        if (mptr) {
            mpRefCnt = new RefCnt(mptr);
        } else {
            mpRefCnt = nullptr;
        }
    }

    // 析构函数
    ~CSmartPtr() {
        if (mpRefCnt) {
            mpRefCnt->release();
        }
    }

    // 拷贝构造函数
    CSmartPtr(const CSmartPtr<T>& src) : mptr(src.mptr), mpRefCnt(src.mpRefCnt) {
        if (mpRefCnt) {
            mpRefCnt->addRef();
        }
    }

    // 拷贝赋值运算符
    CSmartPtr<T>& operator=(const CSmartPtr<T>& src) {
        if (this != &src) {
            // 释放当前资源
            if (mpRefCnt) {
                mpRefCnt->release();
            }

            // 复制新资源
            mptr = src.mptr;
            mpRefCnt = src.mpRefCnt;

            // 增加引用计数
            if (mpRefCnt) {
                mpRefCnt->addRef();
            }
        }
        return *this;
    }

    // 解引用运算符
    T& operator*() const {
        return *mptr;
    }

    // 箭头运算符
    T* operator->() const {
        return mptr;
    }

    // 获取引用计数
    int use_count() const {
        return mpRefCnt ? mpRefCnt->getCount() : 0;
    }

private:
    T* mptr;            // 指向资源的指针
    RefCnt* mpRefCnt;   // 指向引用计数对象的指针
};

// 测试代码
int main() {
    CSmartPtr<int> ptr1(new int(10));
    std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl;  // 输出 1

    {
        CSmartPtr<int> ptr2 = ptr1;  // 拷贝构造
        std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl;  // 输出 2
        std::cout << "ptr2 use count: " << ptr2.use_count() << std::endl;  // 输出 2
    }  // ptr2 离开作用域，引用计数减 1

    std::cout << "ptr1 use count: " << ptr1.use_count() << std::endl;  // 输出 1

    return 0;
}
```



2. 多线程下 是不安全的, 因为 引用计数的修改 不是原子操作

   ```c++
   std::atomic<int> count_;         // 原子引用计数
   
   ```



## 4.shared_ptr 交叉(循环)引用问题

使用 .use_count()  获得 指针计数

###  代码示例

1. shared_ptr 是**强智能指针**, weak_ptr 是**弱智能指针**

   强的   能改变资源的 引用计数,  弱的 不行

2. 强智能指针, 交叉引用问题?
   造成 new 出来的 资源 无法释放

   ```c++
   #include <iostream>
   #include <memory>
   
   using namespace std;
   
   class B;  // 前向声明
   
   class A {
   public:
       A() { cout << "A()" << endl; }
       ~A() { cout << "~A()" << endl; }
       shared_ptr<B> __ptrb;  // 指向 B 的 shared_ptr
   };
   
   class B {
   public:
       B() { cout << "B()" << endl; }
       ~B() { cout << "~B()" << endl; }
       // 如果 B 也持有 A 的 shared_ptr，会导致循环引用
        shared_ptr<A> __ptra;
   };
   
   int main() {
   
           shared_ptr<A> pa(new A()) ;
           shared_ptr<B> pb(new B());
           pa->__ptrb = pb;  // 出作用域之前, 是2 ,达不到析构
           pb->__ptra = pa;
   
           cout << pa.use_count() << endl;
           cout << pb.use_count() << endl;
   
   
       return 0;
   }
   ```

### 整体过程

**初始状态（创建对象）**

1. **创建 `A` 对象**：
   - `shared_ptr<A> pa(new A());`
   - `A` 对象的引用计数为 **1**（来自 `pa`）。
   - `B` 对象尚未创建。

```
+-------------------+
|       A           |
|-------------------|
| shared_ptr<B> __ptrb | -> nullptr
| ref_count: 1       |
+-------------------+
```

1. **创建 `B` 对象**：
   - `shared_ptr<B> pb(new B());`
   - `B` 对象的引用计数为 **1**（来自 `pb`）。
   - `A` 对象的引用计数仍为 **1**。



```
+-------------------+          +-------------------+
|       A           |          |       B           |
|-------------------|          |-------------------|
| shared_ptr<B> __ptrb | -> nullptr | shared_ptr<A> __ptra | -> nullptr
| ref_count: 1       |          | ref_count: 1       |
+-------------------+          +-------------------+
```

------

**步骤 1：`A` 持有 `B`（`pa->__ptrb = pb`）**

- `A` 对象的 `__ptrb` 指向 `B` 对象。
- `B` 对象的引用计数从 **1** 变为 **2**（来自 `pb` 和 `pa->__ptrb`）。
- `A` 对象的引用计数仍为 **1**。

```
+-------------------+          +-------------------+
|       A           |          |       B           |
|-------------------|          |-------------------|
| shared_ptr<B> __ptrb | ----> | shared_ptr<A> __ptra | -> nullptr
| ref_count: 1       |          | ref_count: 2       |
+-------------------+          +-------------------+
```

------

**步骤 2：`B` 持有 `A`（`pb->__ptra = pa`）**

- `B` 对象的 `__ptra` 指向 `A` 对象。
- `A` 对象的引用计数从 **1** 变为 **2**（来自 `pa` 和 `pb->__ptra`）。
- `B` 对象的引用计数仍为 **2**。

```
+-------------------+          +-------------------+
|       A           |          |       B           |
|-------------------|          |-------------------|
| shared_ptr<B> __ptrb | ----> | shared_ptr<A> __ptra | 
| ref_count: 2       |          | ref_count: 2       |
+-------------------+          +-------------------+
      ^                             |
      |                             |
      +-----------------------------+
```

------

**最终状态（循环引用）**

- `A` 和 `B` 对象的引用计数均为 **2**。
- 由于互相持有 `shared_ptr`，引用计数无法归零，导致内存泄漏。

### 解决办法--强弱混用

**定义对象的地方 使用 强智能指针, 引用对象的 地方 使用 弱智能指针**

```c++
#include <iostream>
#include <memory>

using namespace std;

class B;  // 前向声明

class A {
public:
    A() { cout << "A()" << endl; }
    ~A() { cout << "~A()" << endl; }
    weak_ptr<B> __ptrb;  // 修改
};

class B {
public:
    B() { cout << "B()" << endl; }
    ~B() { cout << "~B()" << endl; }
    
     weak_ptr<A> __ptra;  // 修改
};

int main() {

        shared_ptr<A> pa(new A()) ;
        shared_ptr<B> pb(new B());
        pa->__ptrb = pb;  // 出作用域之前, 是2 ,达不到析构
        pb->__ptra = pa;

        cout << pa.use_count() << endl;
        cout << pb.use_count() << endl;
    return 0;
}
```

### 弱智能指针 - 不能使用资源

只观察资源, **不能使用资源**

**需要转换为 `std::shared_ptr` 才能访问对象**

- 通过 `weak_ptr::lock` 方法，可以将 `std::weak_ptr` 转换为 `std::shared_ptr`，从而安全地访问对象。   `shared_ptr<A> ps = __ptra.lock();`    .lock()
- 如果对象已被释放，`lock` 返回一个空的 `std::shared_ptr`。

```c++
#include <iostream>
#include <memory>

using namespace std;

class B;  // 前向声明

class A {
public:
    A() { cout << "A()" << endl; }
    ~A() { cout << "~A()" << endl; }
    void test() { cout << "test" << endl; }
    weak_ptr<B> __ptrb; 
};

class B {
public:
    B() { cout << "B()" << endl; }
    ~B() { cout << "~B()" << endl; }
    void func()
    {
        //__ptra->test(); // 弱智能指针不能 访问对象
        shared_ptr<A> ps = __ptra.lock();
        ps->test();
    }
     weak_ptr<A> __ptra;
};

int main() {

        shared_ptr<A> pa(new A()) ;
        shared_ptr<B> pb(new B());
        pa->__ptrb = pb;  
        pb->__ptra = pa;
        pb->func();

        cout << pa.use_count() << endl;
        cout << pb.use_count() << endl;


    return 0;
}
```





## 5.多线程访问共享对象的线程安全问题

非常著名的 开源网络库 muduo 库

1. 该源码中对于智能指针的应用非常优秀，其中借助**shared_ptr和**
   **weak_ptr**解决了这样一个问题，多线程访问共享对象的线程安全问题，解释如下：

   ```c++
   线程A和线程B访问一个共享的对象，如果线程A正在析构这个对象的时候，线程B又
   要调用该共享对象的成员方法，此时可能线程A已经把对象析构完了，线程B再去访问
   该对象，就会发生不可预期的错误。
   ```

2. 代码如下:

   ```c++
   #include <iostream>
   #include <thread>
   using namespace std;
   
   class Test
   {
   public:
   	// 构造Test对象，_ptr指向一块int堆内存，初始值是20
   	Test() :_ptr(new int(20)) 
   	{
   		cout << "Test()" << endl;
   	}
   	// 析构Test对象，释放_ptr指向的堆内存
   	~Test()
   	{
   		delete _ptr;
   		_ptr = nullptr;
   		cout << "~Test()" << endl;
   	}
   	// 该show会在另外一个线程中被执行
   	void show()
   	{
   		cout << *_ptr << endl;
   	}
   private:
   	int *volatile _ptr;
   };
   void threadProc(Test *p)
   {
   	// 睡眠两秒，此时main主线程已经把Test对象给delete析构掉了
   	std::this_thread::sleep_for(std::chrono::seconds(2));
   	/* 
   	此时当前线程访问了main线程已经析构的共享对象，结果未知，隐含bug。
   	此时通过p指针想访问Test对象，需要判断Test对象是否存活，如果Test对象
   	存活，调用show方法没有问题；如果Test对象已经析构，调用show有问题！
   	*/
   	p->show();
   }
   int main()
   {
   	// 在堆上定义共享对象
   	Test *p = new Test();
   	// 使用C++11的线程类，开启一个新线程，并传入共享对象的地址p
   	std::thread t1(threadProc, p);
   	// 在main线程中析构Test共享对象
   	delete p;
   	// 等待子线程运行结束
   	t1.join();
   	return 0;
   }
   ```

   运行上面的代码，发现在**main主线程已经delete析构Test对象以后**，子线程threadProc**再去访问Test对象的show方法**，**无法打印**出*_ptr的值20。可以用shared_ptr和weak_ptr来解决多线程访问共享对象的线程安全问题，上面代码修改如下：

   ```cpp
   #include <iostream>
   #include <thread>
   #include <memory>
   using namespace std;
   
   class Test
   {
   public:
   	// 构造Test对象，_ptr指向一块int堆内存，初始值是20
   	Test() :_ptr(new int(20)) 
   	{
   		cout << "Test()" << endl;
   	}
   	// 析构Test对象，释放_ptr指向的堆内存
   	~Test()
   	{
   		delete _ptr;
   		_ptr = nullptr;
   		cout << "~Test()" << endl;
   	}
   	// 该show会在另外一个线程中被执行
   	void show()
   	{
   		cout << *_ptr << endl;
   	}
   private:
   	int *volatile _ptr;
   };
   void threadProc(weak_ptr<Test> pw) // 通过弱智能指针观察强智能指针
   {
   	// 睡眠两秒
   	std::this_thread::sleep_for(std::chrono::seconds(2));
   	/* 
   	如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升
   	为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存
   	的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象
   	已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。
   	*/
   	shared_ptr<Test> ps = pw.lock();
   	if (ps != nullptr)
   	{
   		ps->show();
   	}
   }
   int main()
   {
   	// 在堆上定义共享对象 ,  智能释放
   	shared_ptr<Test> p(new Test);
   	// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针
   	std::thread t1(threadProc, weak_ptr<Test>(p));
   	// 在main线程中析构Test共享对象
       
   	// 阻塞等待子线程运行结束
   	t1.join();
   	return 0;
   }
   ```

   运行上面的代码，show方法可以打印出20，**因为main线程调用了t1.join()方法等待子线程结束，此时pw通过lock提升为ps成功**，见上面代码示例。

   如果设置t1为分离线程，让main主线程结束，p智能指针析构，进而把Test对象析构，此时show方法已经不会被调用，**因为在threadProc方法中，pw提升到ps时，lock方法判定Test对象已经析构，提升失败**！main函数代码可以如下修改测试：

   ```cpp
   int main()
   {
   	// 在堆上定义共享对象
   	shared_ptr<Test> p(new Test);
   	// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针
   	std::thread t1(threadProc, weak_ptr<Test>(p));
   	// 在main线程中析构Test共享对象
   	// 设置子线程分离 主线程不等待子线程
   	t1.detach();
   	return 0;
   }
   ```

   该main函数运行后，最终的threadProc中，show方法不会被执行到。**以上是在多线程中访问共享对象时，对shared_ptr和weak_ptr的一个典型应用**。

## 6.自定义删除器

### 什么是自定义删除器

我们经常用智能指针管理的资源是堆内存，当智能指针出作用域的时候，在其析构函数中会delete释放堆内存资源，但是除了堆内存资源，智能指针还可以管理其它资源，比如**打开的文件**，此时**对于文件指针的关闭，就不能用delete**了，这时我们需要**自定义智能指针释放资源的方式**，先看看unique_ptr智能指针的析构函数代码，如下：

```cpp
~unique_ptr() noexcept
{	// destroy the object
if (get() != pointer())
	{
	this->get_deleter()(get()); // 这里获取底层的删除器，进行函数对象的调用
	}
}
```

从unique_ptr的析构函数可以看到，如果要实现一个自定义的删除器，实际上就是定义一个函数对象而已，示例代码如下：

```c++
_EXPORT_STD template <class _Ty, class _Dx /* = default_delete<_Ty> */>
class unique_ptr { // non-copyable pointer to an object
    {}   
    
```

**这是unique的源码, 可以看到, 模板里的第二个参数, 使用 默认的 删除器, 这个是可选的, 因此 自定义删除类的 传入接口 就在这里**

```c++
#include <iostream>
#include <thread>
#include <memory>
using namespace std;

template<typename T>
class MyDeletor
{
public:
    void operator() (T* ptr) const
    {
        cout << "call MyDeletor.operator()" << endl;
        delete[] ptr;
    }
};

int main()
{
	unique_ptr<int, MyDeletor<int>> ptr1(new int[100]);
	
	return 0;
}
```





### 文件的自定义删除器  -- 不推荐写类

```cpp
class FileDeleter
{
public:
	// 删除器负责删除资源的函数
	void operator()(FILE *pf)
	{
		fclose(pf);
	}
};
int main()
{
    // 由于用智能指针管理文件资源，因此传入自定义的删除器类型FileDeleter
	unique_ptr<FILE, FileDeleter> filePtr(fopen("data.txt", "w"));
	return 0;
}
```

当然这种方式需要定义额外的函数对象类型，不推荐，

### function和lambda结合的删除器-----推荐

**function下一节会讲到**

自定义删除器 一般指出现在 指定语句中, 写类 就显得繁杂了

可以用C++11提供的函数对象function和lambda表达式更好的处理自定义删除器，代码如下：

```cpp
#include <iostream>
#include <memory>
#include <cstdio>  // 包含 fopen 和 fclose 的头文件
#include <functional>
using namespace std;

int main()
{
    // 自定义智能指针删除器，关闭文件资源
    unique_ptr<FILE, function<void(FILE*)>>
        filePtr(fopen("data.txt", "w"), [](FILE* pf)->void {cout << "call lambda release file" << endl;fclose(pf); });

    // 自定义智能指针删除器，释放数组资源
    unique_ptr<int, function<void(int*)>>
        arrayPtr(new int[100], [](int* ptr)->void {cout << "call lambda release int []" << endl;delete[]ptr; });

    return 0;
}
```

如果想进一步了解智能指针，可以查看智能指针的源码实现，或者看muduo网络库的源码。



