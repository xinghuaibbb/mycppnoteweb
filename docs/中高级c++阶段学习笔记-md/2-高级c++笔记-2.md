

[TOC]



# 绑定器和函数对象

## 1.bind1st 和 bind2nd 

1. **这是STL中 绑定器**
   分别用于绑定二元函数的第一个或第二个参数

2. c++11 中的 bind绑定器和 function函数对象机制

3. lambda表达式---底层依赖函数对象的机制实现

4. 代码:

   ```c++
   #include <iostream>
   #include <vector>
   #include <functional>
   #include <algorithm>
   using namespace std;
   
   template<typename Container>
   void showContainer(Container& con)
   {
       typename Container::iterator it = con.begin();  //需要加 typename,编译时并不知道什么类型
       for (; it != con.end(); ++it)
       {
           cout << *it << " ";
       }
       cout << endl;
   }
   
   int main()
   {
       vector<int> vec;
       srand(time(nullptr));   // 随机种子
       for (int i = 0; i < 20; ++i)
       {
           vec.push_back(rand() % 100 + 1);
       }
   
       showContainer(vec);
       sort(vec.begin(), vec.end());
       showContainer(vec);
   
       // greater 二元函数对象
       sort(vec.begin(), vec.end(), greater<int>()); 
       showContainer(vec);
   
       //把70按顺序 插入到vec中   使用bind1st   70>b
       auto it1 = find_if(vec.begin(), vec.end(), bind1st(greater<int>(), 70));
       if (it1 != vec.end())
       {
           vec.insert(it1, 70);
       }
       showContainer(vec);
   }
   ```

## 2.bind1st的底层实现原理

代码:

```c++
#include <iostream>
#include <vector>
#include <functional> // 用于 std::greater, std::less 等

// 自定义的 mybindist 类，模拟 bind1st 的功能
template<typename Compare, typename T>
class _mybindist
{
public:
    // 构造函数，接受一个比较函数对象和一个值
    _mybindist(Compare comp, T val)
        : _comp(comp), _val(val)
    {}

    // 重载函数调用运算符，使其成为一个函数对象
    bool operator()(const T& x) const
    {
        // 使用绑定的值和传入的参数进行比较
        return _comp(x,_val);   // 这里要根据使用 greater和less 来调整顺序
    }

private:
    Compare _comp; // 比较函数对象
    T _val;        // 绑定的值
};

// 辅助函数，用于创建 mybindist 对象
template<typename Compare, typename T>
_mybindist<Compare, T> mybindist(Compare comp, const T& val)
{
    // 返回 mybindist 对象
    return _mybindist<Compare, T>(comp, val);
}

// 自定义的 my_find_if 函数，模拟 std::find_if 的功能
template<typename Iterator, typename Predicate>
Iterator my_find_if(Iterator first, Iterator last, Predicate pred)
{
    for (; first != last; ++first)
    {
        if (pred(*first)) // 如果满足条件
        {
            return first; // 返回当前迭代器
        }
    }
    return last; // 如果没有找到，返回 last
}

int main()
{
    // 创建一个整数向量
    std::vector<int> vec = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };

    // 使用 mybindist 创建一个函数对象，检查元素是否大于 70
    auto greater_than_70 = mybindist(std::greater<int>(), 70);

    // 使用 my_find_if 查找第一个大于 70 的元素
    auto it = my_find_if(vec.begin(), vec.end(), greater_than_70);

    // 输出结果
    if (it != vec.end())
    {
        std::cout << "First element greater than 70 is: " << *it << std::endl;
    }
    else
    {
        std::cout << "No element greater than 70 found." << std::endl;
    }

    return 0;
}
```

**直接使用函数模板, 好处是 可以进行 类型的 推演**

**处理能力有限, 只能处理二元函数对象, 多了就不行了**



## 3.函数对象类型function--应用实例



1. **c++11的绑定器bind** 与 STL中的bind1st 和 bind2nd不同, 能用, 但已被弃用
2. STL中的bind1st 和 bind2nd   ---- **本质还是函数对象**
3. **绑定器, 函数对象, lambda 表达式**, **只能使用在一条语句中**, 使用了function, 可以解决这个问题
4. 补充知识点: **函数类型** **和 函数指针类型 区分**

   **函数类型**

   函数类型指的是函数的签名（signature），**包括函数的返回类型和参数类型**。函数类型本身并不是一个可以直接使用的对象，而是描述函数的特征。

   ```c++
   int add(int a, int b); // 函数类型是 int(int, int)
   void print(const std::string& str); // 函数类型是 void(const std::string&)
   ```

   **函数类型通常用于模板参数或类型推导中。**

   ```c++
   std::function<int(int, int)> func = add; // std::function 使用函数类型 int(int, int)
   ```

   

   **函数指针类型**

   函数指针类型是**指向函数的指针类型**。它是一个具体的对象，可以存储函数的地址，并通过指针调用函数。

   ```c++
   int (*funcPtr)(int, int); // 函数指针类型是 int(*)(int, int)
   funcPtr = add; // 将函数 add 的地址赋值给 funcPtr
   int result = funcPtr(2, 3); // 通过函数指针调用函数
   ```

   **函数指针类型的语法**包括：

   - 返回类型
   - 指针名称（用 `*` 表示）
   - 参数类型列表
5. function 应用实例代码:
   用函数类型 实例化 function
   通过function调用operator()函数的时候, 需要根据函数类型 传入 相应的参数
   **可以保留 lambda 表达式, 到处都可以使用**
   **最大的作用: 保留可以看到的函数, 成员方法, lambda表达式, 其他函数对象**

   ```c++
   #include <iostream>
   #include <vector>
   #include <functional> // 用于 std::greater, std::less 等
   using namespace std;
   
   void hello1()
   {
       cout << "hello world!" << endl;
   }
   
   void hello2(string str)  // void(*pfunc)(string)
   {
       cout << str << endl;   
   }
   
   int sum(int a, int b)
   {
       return a + b;
   }
   
   class Test
   {
       // 成员方法和普通函数不同, 调用必须 依赖对象,通过函数指针调用 void(Test::*pfunc)(string)
   public:
       void hello(string str) { cout << str << endl; }
   };
   
   int main()
   {
       // 从function的类模板定义处，看到希望用一个函数类型实例化function 
       
       function<void()> func1 = hello1;  
       func1();  // func1.operator()=>hello1()
   
       function<void(string)> func2 = hello2;  // 
       func2("hello2");  // func2.operator()(string str)=>hello2(string)
   
       function<int(int, int)> func3 = sum;
       cout << func3(4, 5) << endl;
   
       // function + lambda
       function<int(int, int)> func4 = [](int a, int b)->int {return a + b; };
       cout << func4(40, 50) << endl;
   
       // function+成员方法
       // 课里讲的 这个在高版本 编译不了, & 必须跟左值
       //function<void(Test*, string)> func5 = &Test::hello;
       //func5(&Test(), "call Tes::hello!");  // &Test() 临时对象地址
   
       function<void(Test&&, string)> func5 = &Test::hello;
       func5(Test(), "call Tes::hello!");  // &Test() 临时对象地址
   
       return 0;
   }
   
   ```

6. **特别注意: 成员方法第一个参数, 都是 this指针!!!, 不要忽略, 这不像python, python会标出self, cpp不会标this指针**

7.  实际的 应用案例之一:
   这样的代码 无法闭合, 无法做到 "开-闭原则", 无法通过添加代码完成修改, 而是需要 修改原本的代码

   ```c++
   #include <iostream>
   using namespace std;
   
   int main() {
       int choice;
       cout << "1.查看所有书籍信息" << endl;
       cout << "2.借书" << endl;
       cout << "3.还书" << endl;
       cout << "4.查询书籍" << endl;
       cout << "5.注销" << endl;
       cout << "---" << endl;
       cout << "请选择:";
       cin >> choice;
   
       switch (choice) {
           case 1:
               // 查看所有书籍信息的代码
               cout << "查看所有书籍信息" << endl;
               break;
           case 2:
               // 借书的代码
               cout << "借书" << endl;
               break;
           case 3:
               // 还书的代码
               cout << "还书" << endl;
               break;
           case 4:
               // 查询书籍的代码
               cout << "查询书籍" << endl;
               break;
           case 5:
               // 注销的代码
               cout << "注销" << endl;
               break;
           default:
               cout << "无效的选择，请重新选择。" << endl;
               break;
       }
   
       return 0;
   }
   ```

   

   优化:----function应用

   ```c++
   #include <iostream>
   #include <functional>
   #include <map>
   using namespace std;
   
   void doshowbooks(){ cout << "查看所有书籍信息" << endl; }
   void doborrow(){ cout <<"借书" << endl; }  // ...
   
   int main() {
       int choice;
   
       map<int, function<void()>> actionmap;
       actionmap.insert({ 1,doshowbooks });  // 低版本使用 .insert(make_pair(1,do))
       actionmap.insert({ 2,doborrow});
   
       cout << "1.查看所有书籍信息" << endl;
       cout << "2.借书" << endl;
       cout << "---" << endl;
       cout << "请选择:";
       cin >> choice;
       auto it = actionmap.find(choice);
       if (it == actionmap.end())
       {
           cout << "no message!" << endl;
       }
       else
       {
           it->second();  //注意()
       }
       return 0;
   }
   ```



## 4.模板的完全特例化和部分特例化

**有完全特例化 版本, 优先匹配 完全特例化版本**

### 回顾完全特例化

```c++
#include <iostream>
#include <cstring> // 用于 strcmp 函数
using namespace std;


// 通用模板函数
template<typename T>
bool compare(T a, T b)
{
    return a > b;
}

// 特化版本，用于 const char* 类型
template<>
bool compare<const char*>(const char* a, const char* b)
{
    return strcmp(a, b) > 0;
}

int main()
{
    // 使用通用模板比较整数
    compare(10, 20);

    // 使用特化版本比较 C 风格字符串
    compare("aaa", "bbb");

    return 0;
}
```



### 部分特例化

```c++
#include <iostream>
using namespace std;

// 通用模板类
template<typename T>
class Vector
{
public:
    Vector() { cout << "call Vector template init" << endl; }
};

// 完全特例化版本，针对 char* 类型
template<>
class Vector<char*>
{
public:
    Vector() { cout << "call Vector<char*> init" << endl; }
};

// 部分特例化版本，针对所有指针类型
template<typename Ty>
class Vector<Ty*>
{
public:
    Vector() { cout << "call Vector<Ty*> init" << endl; }
};

// 部分特例化版本，针对两个参数的函数指针类型
template<typename R, typename A1, typename A2>
class Vector<R(*)(A1, A2)>
{
public:
    Vector() { cout << "call Vector<R(*)(A1, A2)> init" << endl; }
};

int sum(int a, int b)
{
    return a + b;
}

int main()
{
    // 使用通用模板类
    Vector<int> intVector; // 调用通用模板构造函数

    // 使用完全特例化版本
    Vector<char*> charPtrVector; // 调用 char* 特例化构造函数

    // 使用部分特例化版本
    Vector<int*> intPtrVector; // 调用指针类型的部分特例化构造函数

    //函数指针, 也是指针
    Vector<int(*)(int, int)> funcPtrVector; // 没有函数指针特例化, 就用匹配的部分特例化
    //这是函数类型, 不是函数指针
    Vector<int(int, int)> funcVector;

    typedef int(*PFUNCPTR)(int, int);
    PFUNCPTR func1 = sum;
    cout << func1(10, 20) << endl;

    return 0;
}
```

**注意区分函数类型和函数指针类型**



### 模板的实参推演

实例--细分:

```c++
#include <iostream>
#include <typeinfo> // 用于 typeid 和 type_info
using namespace std;

// 模板函数，用于打印类型信息
template<typename T>
void func(T a)
{
    cout << "Type of T: " << typeid(T).name() << endl;
}
// 模板函数，用于打印类型信息
template<typename T>
void func2(T* a)
{
    cout << "Type of T: " << typeid(T).name() << endl;
}

template<typename R, typename A1, typename A2>
void func3(R(*a)(A1, A2))
{ 
        cout << "Type of T: " << typeid(R).name() << endl;
        cout << "Type of A1: " << typeid(A1).name() << endl;
        cout << "Type of A2: " << typeid(A2).name() << endl;
    }

class Test
{
public:
    int sum(int a, int b) { return a + b; }
};

template<typename R, typename A1, typename A2, typename T>
void func4(R(T::*a)(A1, A2))  // a这种, 存不存在都行, 因为没使用
{
    cout << "Type of R: " << typeid(R).name() << endl;
    cout << "Type of T: " << typeid(T).name() << endl;
    cout << "Type of A1: " << typeid(A1).name() << endl;
    cout << "Type of A2: " << typeid(A2).name() << endl;
}

// 普通函数，计算两个整数的和
int sum(int a, int b) {
    return a + b;
}

int main()
{
    // 调用 func 并传入整数
    func(10); // T 推导为 int

    // 调用 func 并传入字符串字面量
    func("aaa"); // T 推导为 const char*

    // 调用 func 并传入函数指针
    func(sum); // T 推导为 int (*)(int, int)
    func2(sum);  // int __cdecl(int,int)

    //细分类型
    func3(sum);

    func(&Test::sum); //  int (__thiscall Test::*)(int,int)
    func4(&Test::sum);

    return 0;
}
```



## 5.function实现原理

### 固定参模板

一般的 自己写的 function 会因为形参个数不同, 导致需要特例化 太多, 如下:

```c++
#include <iostream>
#include <string>
using namespace std;

// 模板类，封装函数指针
template<typename R, typename A1>
class myfunction {
public:
    using PFUNC = R(*)(A1); // 定义函数指针类型

    // 构造函数，接受一个函数指针
    myfunction(PFUNC pfunc) : _pfunc(pfunc) {}

    // 重载 operator()，使对象可以像函数一样调用
    R operator()(A1 arg) {
        return _pfunc(arg);
    }

private:
    PFUNC _pfunc; // 存储函数指针
};

// 示例函数，用于测试
void hello(string str) {
    cout << "Hello, " << str << endl;
}

int main() {
    // 创建 myfunction 对象，封装 hello 函数
    myfunction<void, string> func1(hello);

    // 调用 func1，输出 "Hello, hello world!"
    func1("hello world!");

    return 0;
}
```



但是,c++11提供了 可变参的模板

### 可变参模板-->...

typename... A

```c++
template<typename R, typename... A>
class myfunction {
public:
    using PFUNC = R(*)(A...); // 定义函数指针类型

    // 构造函数，接受一个函数指针
    myfunction(PFUNC pfunc) : _pfunc(pfunc) {}

    // 重载 operator()，使对象可以像函数一样调用
    R operator()(A... arg) {
        return _pfunc(arg);
    }

private:
    PFUNC _pfunc; // 存储函数指针
};
```



## 6.c++11的bind--头文件 functional

**返回的结果 还是 一个函数对象**

**bind 是 函数模板**  -- 也就能 自动推演类型了

**不要忘记 bind(...)()最后这个括号**

### 1.无参数占位符

```c++
#include <iostream>
#include <string>
#include <functional>
using namespace std;


// 示例函数，用于测试
void hello(string str) {
    cout << "Hello, " << str << endl;
}
int sum(int a, int b) {
    return a + b;
}

class Test
{
    // 成员方法和普通函数不同, 调用必须 依赖对象,通过函数指针调用 void(Test::*pfunc)(string)
public:
    int sum(int a, int b) {
        return a + b;
    }
};

int main() {

    bind(hello, "hello bind!")(); 
    cout<<bind(sum, 10, 20)()<<endl;

    cout << bind(&Test::sum, Test(), 20, 30)() << endl; // 注意绑定Test对象

    return 0;
}
```





### 2.有参数占位符--placeholders::_

```c++
 //参数占位符
    bind(hello, placeholders::_1)("hello placeholders");

//placeholders 是一个命名空间
using namespace placeholders;
bind(hello, _1)("hello placeholders");
```





### 3.绑定器+function

**绑定器 出了 语句无法继续使用**

```c++
function<void(string)> func1 = bind(hello, placeholders::_1);
func1("hello shanxi");
func1("hello shanxi-2");
```



bind原本是 boost库里的, c++11 放到了 标准库



### 4.使用bind+function 实现 简单的 线程池

**只学过c的线程池, 可能看不明白, 后续会写 c++的多线程 笔记**

```c++
#include <iostream>
#include <vector>
#include <thread>
#include <functional> // 包含 std::bind
#include <memory>     // 包含 std::unique_ptr
using namespace std;

class Thread {
public:
    Thread(function<void()> func) : _func(func) {}  // function用于接收 bind

    thread start() {
        return thread(_func);
    }

private:
    function<void()> _func;
};

class ThreadPool {
public:
    // 开启线程池
    void startPool(int size) {
        for (int i = 0; i < size; ++i) {
            _pool.push_back(new Thread(bind(&ThreadPool::runInThread, this, i))); //不使用占位符, 将不用再次传参
        }

        for (int i = 0; i < size; ++i) {
            _handler.push_back(_pool[i]->start());
        }

        for (thread& t : _handler) {
            if (t.joinable()) {
                t.join();
            }
        }
    }

    // 清理线程池
    ~ThreadPool() {
        for (int i = 0; i < _pool.size(); ++i) {
            delete _pool[i];
        }
        
    }

private:
    vector<Thread*> _pool; // 使用智能指针管理线程对象
    vector<thread> _handler;          // 存储线程对象

    // 线程函数
    void runInThread(int id) {
        cout << "Thread " << id << " is running!" << endl;
    }
};

int main() {
    ThreadPool pool;
    pool.startPool(10); // 开启一个包含 10 个线程的线程池

    return 0;
}
```



可以使用智能指针, 自动释放
make_unique 是c++14加入的工具函数
**在容器中存储 `unique_ptr` 时，**推荐使用 `make_unique`****
**容器中 不能使用 new 传给 智能指针**

```c++
#include <iostream>
#include <vector>
#include <thread>
#include <functional> // 包含 std::bind
#include <memory>     // 包含 std::unique_ptr
using namespace std;

class Thread {
public:
    Thread(function<void()> func) : _func(func) {}  // function用于接收 bind

    thread start() {
        return thread(_func);
    }

private:
    function<void()> _func;
};

class ThreadPool {
public:
    // 开启线程池
    void startPool(int size) {
        for (int i = 0; i < size; ++i) {
            _pool.push_back(make_unique<Thread>(bind(&ThreadPool::runInThread, this, i))); //不使用占位符, 将不用再次传参
        }

        for (int i = 0; i < size; ++i) {
            _handler.push_back(_pool[i]->start());
        }

        for (thread& t : _handler) {
            if (t.joinable()) {
                t.join();
            }
        }
    }

    // 清理线程池
    ~ThreadPool() {

    }

private:
    vector<unique_ptr<Thread>> _pool; // 使用智能指针管理线程对象
    vector<thread> _handler;          // 存储线程对象

    // 线程函数
    void runInThread(int id) {
        cout << "Thread " << id << " is running!" << endl;
    }
};

int main() {
    ThreadPool pool;
    pool.startPool(10); // 开启一个包含 10 个线程的线程池

    return 0;
}
```



## 7.lambda表达式

1. **函数对象相较于 `lambda` 的缺点**

   1. **代码冗长**：需要定义类，`lambda` 只需一行代码。
   2. **不能直接捕获外部变量**：必须手动存储，而 `lambda` 可自动捕获。
   3. **不适用于局部作用域**：`lambda` 可随用随写，函数对象需额外定义类。
   4. **使用标准算法较繁琐**：`lambda` 直接传入算法，函数对象需单独定义。
   5. **不能自动推导类型**：函数对象 `operator()` 需显式指定返回类型，`lambda` 可自动推导。

2. lambda表达式语法:
   `[捕获外部变量](形参列表)->返回值 {操作代码}`
   **如果返回值不需要, 可以省略`->返回值`**
   [] :  表示 不捕获外部变量
   [=] : 以传值的方式 捕获的所有变量
   [&] :  以引用的方式 捕获的所有变量
   [this] :  捕获外部 this指针
   [=, &a] :  以传值的方式 捕获的所有变量, 但是a是引用方式捕获
   [a, b] :  以传值的方式 捕获 外部 a,b
   [a,&b] : 以传值的方式 捕获 a, 但是b是引用方式捕获

3. **mutable 关键字**
   在 C++ 中，`mutable` 是一个关键字，用于修饰类的成员变量。它的主要作用是允许在 `const` 成员函数中修改被 `mutable` 修饰的成员变量。`mutable` 通常用于那些逻辑上不改变对象状态，但技术上需要修改某些成员变量的场景。

   ```c++
   class Counter {
   public:
       Counter() : _count(0) {}
   
       void increment() const {
           ++_count; // 允许在 const 成员函数中修改 _count
       }
   
       int getCount() const {
           return _count;
       }
   
   private:
       mutable int _count; // 使用 mutable 修饰
   };
   
   int main() {
       const Counter counter;
       counter.increment(); // 调用 const 成员函数
       std::cout << "Count: " << counter.getCount() << std::endl; // 输出: Count: 1
       return 0;
   }
   ```

   

4. lambda代码示例:    ---  使用auto

   可以回顾一下 STL中使用lambda的点
   注意 成员变量是左值引用时, 不在定义出初始化, 而是在构造函数里

   ```c++
   #include <iostream>
   using namespace std;
   
   template<typename T=void>   // 注意这个 void   lambda的原理
   class TestLambda01 {
   public:
       void operator()() {
           cout << "hello world!" << endl;
       }
   };
   template<typename T = int>   // 注意这个 void   lambda的原理
   class TestLambda02 {
   public:
       TestLambda02(int a, int b):ma(a),mb(b){}
       void operator()() const{
           int tmp = mb;
           mb = ma;
           ma = tmp;
       }
   private:
       int ma;
       int mb;
   };
   
   template<typename T = int>   // 注意这个 void   lambda的原理
   class TestLambda03 {
   public:
       TestLambda03(int &a, int &b) :ma(a), mb(b) {}
       void operator()() const {
           int tmp = mb;
           mb = ma;
           ma = tmp;
       }
   private:
       int &ma;  // C++ 规定引用成员变量必须在构造函数的初始化列表中初始化。  所以这里不需要初始化
       int &mb;
   };
   
   int main() {
       auto func1 = []()->void { cout << "hello world!" << endl; };
       func1();
   
       auto func2 = []() { cout << "hello world!" << endl; };
       func2();
   
       int a = 10;
       int b = 20;
       //auto func3 = [=]() {  // 类似于 TestLambda02
       //    int tmp = b;
       //    b = a;   // lambda 默认是 是使用常方法, 因此不能修改值
       //    a = tmp;
       //    cout << "hello world!" << endl; };
       auto func3 = [=]()mutable {   // mutable 表示 可以在常方法中修改成员变量
           int tmp = b;
           b = a;  
           a = tmp;
           cout << "hello world!" << endl; };
       func3();
       cout << "a " << a << endl;   // 因为是值传递, 外边的没改变
   
   
   
       TestLambda01<> t1; //这种太冗余了
       t1();
      /* TestLambda02<int> t2(20, 30);
       t2();*/
       TestLambda03<int> t3(a, b);
       t3();
   
       return 0;
   }
   
   ```

   

## 8.lambda表达式应用实践--跨语句--function

需要多多练习 代码使用方式

```c++
#include <iostream>
#include <memory>
#include <map>
#include <functional>
#include <queue>
using namespace std;

class Data {
public:
    Data(int val1 = 10, int val2 = 10) : ma(val1), mb(val2) {}
    int ma;
    int mb;
};

// 自定义删除器   这个就有点繁琐了 可以使用function+lambda
void fileDeleter(FILE* file) {
    if (file) {
        fclose(file);
        cout << "File closed." << endl;
    }
}

int main() {
    // 使用自定义删除器的 unique_ptr
    unique_ptr<FILE, decltype(&fileDeleter)> ptr1(fopen("test.txt", "w"), fileDeleter);
    if (ptr1) {
        fprintf(ptr1.get(), "Hello, World!\n");
    }

    // 函数映射
    map<int, function<int(int, int)>> calculateMap;
    calculateMap[1] = [](int a, int b) -> int { return a + b; };
    calculateMap[2] = [](int a, int b) -> int { return a - b; };
    calculateMap[3] = [](int a, int b) -> int { return a * b; };
    calculateMap[4] = [](int a, int b) -> int { return a / b; };

    cout << "选择操作 (1: 加, 2: 减, 3: 乘, 4: 除): ";
    int choice;
    cin >> choice;

    if (calculateMap.find(choice) != calculateMap.end()) {
        int a, b;
        cout << "输入两个整数: ";
        cin >> a >> b;
        cout << "结果: " << calculateMap[choice](a, b) << endl;
    }
    else {
        cout << "无效的选择。" << endl;
    }

    
    // 使用自定义比较函数的优先级队列, 这样更 灵活, 如果写函数, 会很死板 
    using FUNC = function<bool(Data&, Data&)>;
    priority_queue<Data, vector<Data>, FUNC> maxHeap(
        [](Data& d1, Data& d2) -> bool {
            return d1.ma > d2.ma; // 大顶堆，按 ma 从大到小排序
        }
    );

    // 添加元素
    maxHeap.push(Data(5, 20));
    maxHeap.push(Data(15, 10));
    maxHeap.push(Data(10, 30));

    // 输出元素
    while (!maxHeap.empty()) {
        Data top = maxHeap.top();
        cout << "ma: " << top.ma << ", mb: " << top.mb << endl;
        maxHeap.pop();
    }

    return 0;
}
```





# c++11 知识点汇总

------

## 一、C++11常用关键知识点梳理

### 1. 关键字和语法

1. `auto`：可以根据右值，推导出右值的类型，然后左边变量的类型就已知了

2. `nullptr`：给指针专用（能够和整数进行区别）；之前的`NULL`是一个宏定义`#define NULL 0`，在代码上无法区分整数和指针地址

3. `foreach`

   语句：可以遍历数组（底层是指针遍历），容器（底层是迭代器遍历）等

   ```cpp
   for(Type val : container) => 底层就是通过指针或者迭代器来实现的
   	cout<<val<<" ";
   ```

4. 右值引用：`move`移动语义函数和`forward`类型完美转发函数

5. 模板的一个新特性：`typename... A` 表示可变参（类型参数）

### 2. 绑定器和函数对象

- `function`：函数对象
- `bind`：绑定器
- `bind1st`和`bind2nd`  只能结合 二元函数对象=>一元函数对象 -- 非常有限
- `lambda`表达式

### 3. 智能指针

`shared_ptr`和`weak_ptr`----带引用计数,   ---- 分强弱智能指针, `weak_ptr指针.lock()`可以提升为强智能指针
不带引用计数虽然有好几个, 但是 推荐使用 unique_ptr

### 4. 容器

- `set和map`：红黑树，增删查O(logn) -- 以前c++标准库就有
- `unorder_set和unorder_map`：哈希表，增删查O(1)  ---- c++11 新增
- `array`：数组，**固定大小，不可扩容**。区别于`vector`   ---- c++11 新增, 需要确保数量已知
- `forward_list`：前向链表，单链表。`list`是双向链表 ---- c++11 新增

推荐使用vector和list, 更灵活,   具体情况具体看待

## 二、C++语言级别支持的多线程编程 -- 本节重点

linux下的 线程函数, 在c++里并不适用

**C++语言级别的多线程编程 =>代码可以跨平台：windows/linux/mac**

**主要内容: thread/mutex/condition_variable**--线程, 互斥, 条件变量
**锁**: lock_quard, unique_lock
**原子类型**: atomic
**睡眠**: sleep_for

```cpp
C++语言层面 thread--可以根据系统, 使用不同的底层（底层用的还是下面平台的方法） 
   windows        linux：
      |             |
createThread    pthread_create
```

需要包含的**头文件**：`#include <thread>`-----linux是  pthread



### 1. 通过thread类编写C++多线程程序

1. **主要函数**:

  std::thread: 创建线程对象,   ----  类似于 pthread_create

  std::this_thread::sleep_for(std::chrono::seconds(2)) : 线程睡眠2s -- 类似于 sleep(2)

  线程对象.join : 回收等待子线程, **在c++里 不分离线程的化, 必须回收等待,** 这个与 linux不同----非常严格

  线程对象.detach: 分离线程

2. **怎么创建启动一个线程？**
  `std::thread`定义一个线程对象，传入线程所需要的线程函数和参数，线程自动开启

3. **子线程如何结束？**
  子线程函数运行完成，线程就结束了

4. **主线程如何处理子线程？**
  `t.join()`：等待`t`线程结束，当前线程继续往下运行
  `t.detach()`：把`t`线程设置为分离线程，主线程结束，整个进程结束，所有子线程都自动结束，类似于守护线程

```cpp
#include <iostream>
#include <thread>
using namespace std;

void threadHandle1(int time)
{
	//让子线程睡眠time秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello threadHandle1!" << endl;
}

void threadHandle2(int time)
{
	//让子线程睡眠time秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello threadHandle2!" << endl;
}

int main()
{
	// 创建了一个线程对象，传入一个线程函数（作为线程入口函数）, 新线程就开始运行，没有先后顺序，随着CPU的调度算法执行
	std::thread t1(threadHandle1, 1);
	std::thread t2(threadHandle2, 2);

	// 主线程运行到这里，等待子线程结束，主线程继续往下运行
	t1.join();
	t2.join();


	// 把子线程设置为分离线程

	//t1.detach();
	//t2.detach();

	cout << "main thread done!" << endl;

	/*
	主线程运行完成时，会查看当前进程是否还有未运行完成的子线程
	如果有未运行完成的子线程，那么进程就会异常终止
	*/
	return 0;
}
```

### 2. 线程间互斥锁与死锁 -- 对应linux多线程互斥锁

c++ thread 模拟车站三个窗口买票的 程序

#### 代码: 

-- 不加互斥锁,  数据是乱的, 会同时同一时间 访问 某个量

```cpp
#include <iostream>
#include <thread>
#include <list>
using namespace std;

/*
c++ thread 模拟车站三个窗口买票的 程序
*/

int ticketCount = 10; // 车站有10张车票，由三个窗口一起卖票

// 模拟卖票的线程函数
void sellTicket(int index)
{
	while (ticketCount > 0)
	{
		cout << "窗口:" << index << "卖出第:" << 11-ticketCount << "张票!" << endl;
		ticketCount--;
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

int main()
{
	list<std::thread> tlist;  // 使用双向链表
	for (int i = 1; i <= 3; ++i)
	{
		tlist.push_back(std::thread(sellTicket, i));
	}
		

	for (auto& t : tlist)
	{
		t.join();
	}
		
	cout << "所有窗口卖票结束!" << endl;
	return 0;
}
```



#### **竞态条件**和线程安全

指的是多个线程或进程同时访问共享资源时，程序的执行结果依赖于线程或进程的执行顺序，从而导致不可预测的行为或错误。

**线程安全**是指在多线程环境下，多个线程对共享资源（如变量、对象等）的访问，不会导致数据不一致或程序崩溃，且程序行为是可预测的。换句话说，线程安全的代码在多个线程同时访问时，不会出现竞态条件（race conditions）或者其他并发问题。

#### 线程互斥mutex---- 跟linux使用非常像

要对线程安全进行保障，这就需要线程间的互斥，使用**互斥锁**，需要包含头文件`#include <mutex>`

.lock()

.unlock()



**注意 : 加锁和解锁的位置!** 非常影响打印的效果

```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
using namespace std;

/*
c++ thread 模拟车站三个窗口买票的 程序
*/

int ticketCount = 10; // 车站有10张车票，由三个窗口一起卖票

std::mutex mtx; // 全局的一把互斥锁

// 模拟卖票的线程函数
void sellTicket(int index)
{
	//mtx.lock();//这里是不行的, 导致 一个线程 把票全卖了
	while (ticketCount > 0)
	{
		mtx.lock();
		if (ticketCount > 0)  // 必须再次判断, 因为是先进来循环,才等锁, 会引发另一个卖完了, 这个还在循环里, 还会卖
		{
			cout << "窗口:" << index << "卖出第:" << 11 - ticketCount << "张票!" << endl;
			ticketCount--;
		}
		mtx.unlock();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
		
	}
	
}


int main()
{
	list<std::thread> tlist;  // 使用双向链表
	for (int i = 1; i <= 3; ++i)
	{
		tlist.push_back(std::thread(sellTicket, i));
	}
		

	for (auto& t : tlist)
	{
		t.join();
	}
		
	cout << "所有窗口卖票结束!" << endl;
	return 0;
}
```

**临界区（Critical Section）** 是多线程编程中的一个重要概念，指的是访问共享资源（如变量、数据结构、文件等）的一段代码。临界区中的代码需要被保护，以确保同一时间只有一个线程可以执行这段代码，从而避免竞态条件（Race Condition）和数据不一致的问题。

**要保证临界区代码段 原子操作**



#### 死锁问题

程序如果在在中间出现问题, `unlock`就不会执行到了，会被阻塞加锁那里, 会导致死锁.



c++11 提供了`lock_guard`与`unique_lock`  解决死锁问题

##### lock_guard-保证所有线程都能释放锁

`lock_guard`：`lock_guard<std::mutex> lock(mutex锁名);` 构造会自动上锁，析构会自动释放。拷贝构造与赋值重载函数被删除掉了，类比智能指针`scoped_ptr`

```c++
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
using namespace std;

/*
c++ thread 模拟车站三个窗口买票的 程序
*/

int ticketCount = 10; // 车站有10张车票，由三个窗口一起卖票

std::mutex mtx; // 全局的一把互斥锁

// 模拟卖票的线程函数
void sellTicket(int index)
{
	//mtx.lock();//这里是不行的, 导致 一个线程 把票全卖了
	while (ticketCount > 0)
	{
		//mtx.lock();
		{

			lock_guard<std::mutex> lock(mtx);   // 出作用域自动析构解锁
			if (ticketCount > 0)
			{
				cout << "窗口:" << index << "卖出第:" << 11 - ticketCount << "张票!" << endl;
				ticketCount--;
			}
		}
		//mtx.unlock();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
		
	}
	
}


int main()
{
	list<std::thread> tlist;  // 使用双向链表
	for (int i = 1; i <= 3; ++i)
	{
		tlist.push_back(std::thread(sellTicket, i));
	}
		

	for (auto& t : tlist)
	{
		t.join();
	}
		
	cout << "所有窗口卖票结束!" << endl;
	return 0;
}
```





##### unique_lock

`unique_lock`：构造会自动上锁，析构会自动释放。拷贝构造与赋值重载函数被删除掉了，提供了带右值引用版本的，类比智能指针`unique_ptr`

```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
using namespace std;

/*
c++ thread 模拟车站三个窗口买票的 程序
*/

int ticketCount = 10; // 车站有10张车票，由三个窗口一起卖票

std::mutex mtx; // 全局的一把互斥锁

// 模拟卖票的线程函数
void sellTicket(int index)
{
	//mtx.lock();//这里是不行的, 导致 一个线程 把票全卖了
	while (ticketCount > 0)
	{
		//mtx.lock();
		{

			//lock_guard<std::mutex> lock(mtx);   // 出作用域自动析构解锁
			unique_lock<std::mutex> lock(mtx);   // 出作用域自动析构解锁
			if (ticketCount > 0)
			{
				cout << "窗口:" << index << "卖出第:" << 11 - ticketCount << "张票!" << endl;
				ticketCount--;
			}
		}
		//mtx.unlock();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
		
	}
	
}


int main()
{
	list<std::thread> tlist;  // 使用双向链表
	for (int i = 1; i <= 3; ++i)
	{
		tlist.push_back(std::thread(sellTicket, i));
	}
		

	for (auto& t : tlist)
	{
		t.join();
	}
		
	cout << "所有窗口卖票结束!" << endl;
	return 0;
}
```

### 3. 线程间同步通信-生产者消费者模型

**多线程编程两个问题：**

1. 线程间的互斥

   竞态条件导致=>对临界区代码段=>其原子操作=>添加互斥锁`mutex`、轻量级的无锁实现（CAS）

   Linux下`strace ./a.out`（程序启动的跟踪打印的命令)会发现 c++代码底层使用的还是 linux的 `pthread_mutex_t`

2. 线程间的同步通信

   线程间不通信的话，每个线程受CPU的调度，没有任何执行上的顺序可言，线程1和线程2是根据CPU调度算法来的，两个线程都有可能先运行，是不确定的，线程间的运行顺序是不确定的

通信就是：

- 线程1和线程2一起运行，线程2要做的事情必须先依赖于线程1完成部分的事情，然后线程1告诉线程2这部分东西做好了，线程2就可以继续向下执行了
- 或者是线程1接下来要做某些操作，这些操作需要线程2把另外一部分事情做完，然后通知一下线程1它做完了，然后线程1才能做这些操作。

#### **生产者-消费者**线程模型

**注意**： **C++ STL中所有的容器都不是线程安全的**，都需要进行封装。在这个例子中把`queue`封装成了`Queue`

##### 错误案例

先看一个非常简便的 例子 :  这个例子 问题很多:生产者空,消费者还要消费
生产者和消费者 不交流

```c++
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <queue>
using namespace std;

std::mutex mtx;

// 生产者生产一个物品，通知消费者消费一个；消费完了，消费者再通知生产者继续生产物品
class Queue
{
public:
	//生产物品
	void put(int val)
	{
		lock_guard<std::mutex> suo(mtx);
		que.push(val);

		cout << "生产者 生产：" << val <<"号物品" << endl;
	}

	// 消费物品
	int get()
	{
		lock_guard<std::mutex> suo(mtx);

		int val = que.front();
		que.pop();

		cout << "消费者 消费：" << val <<"号物品" << endl;
		return val;
	}

private:
	queue<int> que;
	
};

void producer(Queue* que)	// 生产者线程
{
	for (int i = 1; i <= 10; ++i)
	{
		que->put(i);
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

void consumer(Queue* que)	// 消费者线程
{
	for (int i = 1; i <= 10; ++i)
	{
		que->get();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

int main()
{
	Queue que;	// 两个线程共享的队列

	
	std::thread t1(producer, &que);
	std::thread t2(consumer, &que);

	t1.join();
	t2.join();

	return 0;
}
```





##### 正确案例-- 使用条件变量

信号量 (这是指c中的信号量)虽然可以做, 但是 条件变量(c里有, 但是c++11提供了更好的封装)更好用





**条件变量：**  -- **有两种**

- **功能**：条件变量允许线程等待某个条件为真时才继续执行，通常与互斥锁结合使用。

- 使用条件变量需要包含头文件`#include <condition_variable>`

- .wait()  必须传入 unique_lock 类型的 加锁, 不能是别的类型

- **`std::condition_variable`**：

  - 必须与 `std::unique_lock<std::mutex>` 配合使用。
  - 性能更高，但灵活性较低。

- **`std::condition_variable_any`**：

  - 可以与任何满足基本要求的锁类型配合使用。
  - 灵活性更高，但性能较低。

- **核心操作**:

  ```c++
  条件变量的核心操作
  wait()：
  
  使当前线程进入等待状态，直到被通知。
  
  通常与谓词（Predicate）一起使用，以避免虚假唤醒。
  
  notify_one()：
  
  唤醒一个等待的线程。
  
  notify_all()：
  
  唤醒所有等待的线程。
  ```

- 条件变量, 虽然没有明确的 状态术语, 不过 一般来说 :  `wait()` 使线程进入**等待状态**，在此期间它会释放关联的互斥锁并挂起执行，直到收到 `notify_one()` 或 `notify_all()` 的通知后被唤醒，并尝试重新获取锁；而**阻塞状态**指的是线程在尝试获取锁时发现锁已被其他线程持有，因此无法继续执行，必须等待锁释放后才能继续运行。
  通知后, 其它线程得到该通知，就会从等待状态(条件达成)=>阻塞状态，之后获取互斥锁继续执行----有点乱, 大概明白就行

```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <queue>
#include <condition_variable>
using namespace std;

std::mutex mtx;  // 定义互斥锁, 线程间的 同步操作
std::condition_variable cv; // 定义条件变量 线程间的 通信操作

// 生产者生产一个物品，通知消费者消费一个；消费完了，消费者再通知生产者继续生产物品
class Queue
{
public:
	//生产物品
	void put(int val)
	{
		/*lock_guard<std::mutex> guard(mtx);*/

		// que不为空，生产者应该通知消费者去消费
		unique_lock<std::mutex> lck(mtx);
		while (!que.empty())  
		{
			// que不为空，生产者应该通知消费者去消费, 消费者消费完了，生产者再继续生产
			// 生产者线程进入#1等待状态，并且#2把mtx互斥锁释放掉
			
			cv.wait(lck); //传入一个互斥锁，当前线程挂起，处于等待状态，并且释放当前锁
		}
		que.push(val);

		cv.notify_all();  // 通知其他线程 , 生产了物品, 可以消费
		//其它线程得到该通知，就会从等待状态变为阻塞状态，之后获取互斥锁继续执行

		cout << "生产者 生产：" << val <<"号物品" << endl;
	}

	// 消费物品
	int get()
	{
		/*lock_guard<std::mutex> guard(mtx);*/
		unique_lock<std::mutex> lck(mtx);
		//消费者线程发现que是空的，通知生产者线程先生产物品
		//消费者线程进入等待状态，并且把mtx互斥锁释放掉
		while (que.empty())
		{
			cv.wait(lck); // 循环等待, 并释放互斥锁
		}
		int val = que.front();
		que.pop();
		cv.notify_all();

		cout << "消费者 消费：" << val <<"号物品" << endl;
		return val;
	}

private:
	queue<int> que;
};

void producer(Queue* que)	// 生产者线程
{
	for (int i = 1; i <= 10; ++i)
	{
		que->put(i);
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

void consumer(Queue* que)	// 消费者线程
{
	for (int i = 1; i <= 10; ++i)
	{
		que->get();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

int main()
{
	Queue que;	// 两个线程共享的队列

	
	std::thread t1(producer, &que);
	std::thread t2(consumer, &que);

	t1.join();
	t2.join();

	return 0;
}
```



**特别注意:  **

- **锁的位置对多线程程序的正确性至关重要。**
- **锁必须覆盖整个操作，包括对共享资源的访问和条件变量的等待。**
- 如果将锁放到 `while` 循环内部，会导致竞争条件和输出乱序。
- 正确的锁位置应覆盖整个操作，确保线程间的同步和共享资源的安全性。

### 2.4 再谈lock_guard和unique_lock



主要是为了再讲讲lock_guard和unique_lock, condition_varivable, wait,notify_all



```cpp
std::mutex mtx;

mtx.lock();

mtx.unlock();
```

**普通互斥锁的缺点**:  有可能中间走掉了，导致没有`unlock()`，不安全



`lock_guard<std::mutex> guard(mtx);` 可以出了作用域 自动析构



`lock_guard`**不可能**用在函数参数传递或者返回过程中，因为拷贝构造和赋值函数都被删除了

**只能用在简单的加锁解锁临界区代码段的互斥操作中**，出作用域析构自动释放锁





`unique_lock<std::mutex> lck(mtx);`   --  **搭配条件变量使用**

unique_lock : 不仅可以使用在简单的加锁解锁临界区代码段的互斥操作中，还**能用在函数调用过程**中，因为其虽然删除了拷贝构造和赋值函数，但是**提供了带右值引用版本的**



**总结: lock_guard  适用于 无线程通信的 情况**

**unique_lock  搭配 condition_variable使用, 可以 wait和notify_all,notify_one 结合使用**



```cpp
/*
通知在cv上等待的线程，条件成立了，起来干活了！
其它在cv上等待的线程，收到通知，
从等待状态 -> 到阻塞状态（不能直接运行） 
只有当前线程释放锁了，其他线程获取互斥锁了，线程才能继续往下执行
*/
cv.notify_all();
```

### 2.5 基于CAS操作的atomic原子类型

**本节重点是:  atomic 这个模板类定义的原子类型变量 , 这种类型的变量的操作都将是 是原子操作**

这意味着：
	对 `std::atomic` 类型的变量进行的所有操作（例如读取、写入、增减等）都是不可中断的，不会被其他线程的操作打断。

1. 窗口卖票的代码, count++-- 操作, 是线程不安全的, 之前 使用了 **互斥锁 保证线程安全**

2. **互斥锁是比较重的**，临界区代码**复杂时可以使用**；但现在我们只是做一个加加减减的操作，还是需要一些**轻量级原子操作**的操作
   **解决办法**：使用**CAS**保证上面加加减减操作的原子特性就足够了，**CAS也叫做无锁操作**

3. 什么是 原子操作?

   **原子操作**（Atomic Operation）指的是一系列操作在**执行期间不可被中断**的操作，它是一个**不可分割的操作单元**。也就是说，当一个原子操作开始执行时，它要么完全执行成功，要么完全不执行，不会被其他线程中断或打断，保证了操作的完整性和一致性。

4. 什么是CAS?

   **CAS（Compare-And-Swap）** 是一种原子操作，用于在多线程环境中实现无锁的线程同步。其核心概念是：**比较和交换(exchange/swap)**，即在执行操作时，先比较目标变量的当前值与预期值是否相等，如果相等则将目标变量的值替换为新值，否则不做任何修改。
   **CAS（Compare-And-Swap）** 是一种原子操作，用于实现无锁编程（Lock-Free Programming）。它是一种硬件级别的同步机制，通常用于多线程环境中，确保对共享数据的操作是原子的（即不可分割的）。

5. **CAS 就是无锁操作, 面试的 无锁队列啥的, 就是CAS**

6. **std::atomic  这是一个模板**, 所以需要搭配<>使用

7. `volatile` 是 C 和 C++ 中的一个关键字，用于告诉编译器某个变量的值可能会在程序外部发生变化，因此编译器在优化时不能对该变量进行某些假设(**禁止优化**)，**必须每次直接从内存中读取其值。**  **防止缓存**

8. **原子操作: 实际就是  所有的读写 不会被其他线程中断**

9. `std::atomic_bool` 是 C++11 标准引入的一个别名类型，它是 `std::atomic<bool>` 的简写或别名。`std::atomic_bool` 在 C++ 中是一个 **类型别名**，通常用于让代码更加简洁，便于编写与使用。





头文件：`#include <atomic>`

代码示例：

```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <queue>
#include <condition_variable>
using namespace std;

volatile std::atomic_bool isReady = false;  // atomic的特例化版本

//volatile std::atomic_int ticketCount = 0;  // volatile  防止多线程变量 进行缓存
volatile std::atomic<int> ticketCount = 0;  // 一般这么用 

void task()
{
	while (!isReady)
		std::this_thread::yield(); // 让当前线程 自愿地让出 CPU 的控制权(cpu时间片)，允许同一线程的其他线程获得执行机会

	for (int i = 0; i < 100; ++i)
		ticketCount++;
}

int main()
{
	list<std::thread> tlist;

	for (int i = 0; i < 10; ++i)
		tlist.push_back(std::thread(task));

	std::this_thread::sleep_for(std::chrono::seconds(1));
	cout << "ticketCount:" << ticketCount << endl;	// ticketCount:0

	isReady = true;  // 这里再执行++

	for (auto& t : tlist)
		t.join();

	cout << "ticketCount:" << ticketCount << endl;	// ticketCount:1000

	return 0;
}
```





### 2.6额外补充:CAS的成员方法---课里没讲

**CAS（Compare-And-Swap）** 是一种原子操作，用于在并发编程中保证线程安全，常用于实现无锁数据结构和算法。它的基本原理是比较某个变量的当前值是否等于预期值，如果相等，则交换为新的值。这个操作是原子的，因此能有效避免线程竞争。

在 C++ 中，CAS 通常通过标准库中的 `std::atomic` 来实现，它提供了原子操作的接口，包括 `compare_exchange_weak` 和 `compare_exchange_strong` 两种形式。

#### **基本语法和使用示例**

假设你有一个 `std::atomic<int>` 类型的变量，并且你想使用 CAS 来修改它。

```
#include <iostream>
#include <atomic>

int main() {
    std::atomic<int> x(5); // 创建一个原子整数，初始值为5
    int expected = 5;       // 预期值为5
    int new_value = 10;     // 新值为10

    // 使用 compare_exchange_strong 执行 CAS 操作
    bool success = x.compare_exchange_strong(expected, new_value);

    if (success) {
        std::cout << "CAS 操作成功，新的值是: " << x.load() << std::endl;
    } else {
        std::cout << "CAS 操作失败，当前值是: " << x.load() << std::endl;
    }

    return 0;
}
```

#### **CAS 操作解释：**

1. `x.compare_exchange_strong(expected, new_value)`：
   - 比较 `x` 的当前值和 `expected` 的值。如果它们相等，`x` 将被更新为 `new_value`，并返回 `true`。
   - 如果 `x` 的当前值不等于 `expected`，则 `expected` 将被更新为 `x` 的当前值，操作失败，返回 `false`。
   - `compare_exchange_strong` 是一种强操作，它会进行多个重试，直到操作成功或遇到某些停止条件。
2. **`expected`** 变量在 CAS 操作后，可能会被修改为 `x` 当前的值，因此你需要在失败时查看 `expected` 的新值。

**`compare_exchange_weak` vs `compare_exchange_strong`：**

- **`compare_exchange_strong`**：确保操作尽可能成功地执行，可能会进行多次重试，直到操作成功。
- **`compare_exchange_weak`**：不保证每次都能执行，可能会失败并返回 `false`，适用于无锁算法中可能需要退让的情形。

**代码解析：**

- **成功的 CAS 操作**：`expected` 和 `x` 的值相等时，`x` 会被更新为新值，`success` 为 `true`。
- **失败的 CAS 操作**：`expected` 和 `x` 的值不相等时，`expected` 会更新为 `x` 的当前值，`success` 为 `false`。

**注意事项：**

1. **ABA 问题**：CAS 操作可能会出现 ABA 问题，指的是一个值从 `A` 改为 `B`，然后又变回 `A`，这时 CAS 可能会误认为值没有变化。解决方法之一是使用带有版本号的 CAS 或者增加标记。
2. **高并发问题**：CAS 操作可能导致忙等（自旋），如果操作频繁失败，可能会消耗大量的 CPU 资源。此时，可以考虑结合自旋锁或引入等待机制。

#### **总结**：

- CAS 是一种高效的原子操作，用于并发编程中无锁算法的实现。
- 在 C++ 中，`std::atomic` 提供了 CAS 操作的接口，如 `compare_exchange_strong` 和 `compare_exchange_weak`。
- 使用 CAS 时，需要注意 ABA 问题和自旋的效率问题。





 

# OOP经典设计模式





## 补充个东西: 多态 -- 学迷糊了

一般使用多态,  是将**基类指针 指向 派生类对象(本节中,使用很多),**  这样, 这个基类指针后续还可以指向 别的 派生类对象


而且,  **基类指针指向派生类对象**,  实际就是 **派生类指针 转换为 基类指针**, 这是又下向上的转换, 是被允许的!!

## 一、设计模式

设计模式是一种解决特定问题的预定义优秀代码框架，相较于自己摸索解决方案，它具有以下优点：

1. **易维护**：代码更易于维护，具有良好的可读性、复用性、可移植性和健壮性。
2. **适应需求变化**：设计模式的应用遵循 “开闭原则”（对修改关闭，对扩展开放），使得在需求变更或增加新功能时，能够灵活调整。
3. **模块化设计**：合理选择设计模式可以实现高内聚、低耦合的模块化设计，遵循软件设计的基本原则。

**设计模式的分类：**

- **创建型模式**：关注于**对象的创建**过程，尝试将对象的创建与使用**分离**，以增加系统的灵活性和可维护性
- **结构型模式**：关注于如何将**类或对象组合**成更大的结构，以解决更大的问题
- **行为型模式**：关注于**对象之间**的交互和职责分配，以实现更好的系统行为和更灵活的协作

**23种设计模式：**

- **创建型模式（5种）**：单例模式（Singleton）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、建造者模式（Builder）、原型模式（Prototype）
- **结构型模式（7种）**：**适配器模式（Adapter）**、桥接模式（Bridge）、**装饰器模式（Decorator）**、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）、**代理模式（Proxy）**
- **行为型模式（11种）**：模板方法模式（Template Method）、命令模式（Command）、迭代器模式（Iterator）、**观察者模式（Observer）**、中介者模式（Mediator）、备忘录模式（Memento）、访问者模式（Visitor）、状态模式（State）、策略模式（Strategy）、职责链模式（Chain of Responsibility）、解释器模式（Interpreter）

## 二、单例模式（创建型模式）- 重点(共三种代码)

在此之前, 先了解一下 static 关键字 

| **static 用法**  | **作用**                                                     | 补充说明                                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 静态**局部变量** | 变量不会在函数调用结束后销毁，值会保留<br />变量在函数调用结束后依然存在（局部静态变量） | \- 仅在定义它的函数内可见<br/>\- 初次声明时初始化一次，后续调用不会重新初始化<br />-会从栈区移动到数据区 |
| 静态**全局变量** | 仅在当前文件可见，防止命名冲突<br />限制变量作用范围，使其仅在当前文件可见（内部链接） | \- 作用域限制在定义它的文件中，不会污染其他文件的命名空间    |
| **静态成员变量** | 属于类，而不是对象，所有对象共享<br />变量属于类，而不是对象，所有对象共享一份数据 | \- 需在类内声明, 类外部定义和初始化 (`ClassName::variableName = value;`)<br/>\- 通过 `类名::变量名` 访问 |
| **静态成员函数** | 属于类，不依赖对象，不能访问非静态成员<br />函数属于类，而不是对象，不能访问非静态成员 | \- 无 `this` 指针，不能访问实例成员变量/方法<br/>\- 通过 `类名::函数名` 访问<br />-其内部只能访问 静态 成员, 不能访问不同的成员 |
| **静态全局函数** | 仅在当前文件可见，防止命名冲突<br />限制函数作用范围，使其仅在当前文件可见 | \- 仅在定义它的文件中可见，外部文件无法调用                  |

**单例模式**：一个类**不管创建多少次对象**，永远只能得到该类类型的**唯一一个实例对象**，那么设计一个**单例就必须要满足下面几个条件**：

1. **构造函数私有化**：通过将构造函数私有化，防止外部直接创建实例，从而控制实例的创建
2. **定义该类的唯一实例**：在类内部定义一个**该类的静态实例**，**并确保只有一个实例被创建**
3. **通过静态方法返回唯一实例**：提供一个**静态方法用于访问或获取这个唯一实例**，确保每次调用返回相同的实例
4. **删除拷贝构造和赋值运算符重载**：防止通过拷贝构造函数或赋值操作符创建新的实例

**单例模式分类：**

1. **饿汉式单例模式**：
   - **特点**：实例在**类加载时就被创建**，无论是否需要使用实例
   - **优点**：天然**线程安全**，因为实例在类加载过程中创建，不存在多线程访问问题
   - **缺点**：即使没有使用实例，资源也会被占用，可能导致资源浪费
2. **懒汉式单例模式**：
   - **特点**：实例在**第一次访问时才被创建**，采用延迟加载机制
   - **优点**：延迟实例化，只有在需要时才创建实例，节省资源
   - **缺点**：**线程不安全**，需要处理多线程环境中的同步问题，以确保实例的唯一性，可能影响性能

**单例模式的应用场景举例：**

- **日志模块**：整个应用通常只需要一个日志模块实例，以统一管理日志的输出
- **数据库模块**：在客户端和服务器端之间进行通信时，使用单例模式可以确保只有一个数据库连接实例，从而减少资源消耗和连接管理的复杂性
- **配置管理**：应用程序中配置数据通常是全局的，并且需要统一访问，可以使用单例模式来管理
- **线程池**：使用单例模式可以确保只有一个线程池实例，便于统一管理和调度线程
- **缓存**：单例模式可以用于实现应用的全局缓存，以提高访问速度和性能

### 1.1 饿汉式单例模式 -- 不受欢迎

1. 什么是饿汉式单例模式?
   **饿汉式单例**（Hungry Singleton）是一种在类加载时就立即实例化对象的单例模式

   **还没有获取实例对象, 实例对象 就已经产生了**

2. **饿汉式 一定是 线程安全的**?

   因为 静态的成员变量 在数据段(.data), 数据段 程序已启动 就初始化好了

   饿汉式单例本身在静态变量的初始化中**一般是线程安全的**，但需要注意静态初始化顺序的问题，尤其在多线程环境和动态库情况下。为了确保绝对的线程安全，可以使用一些额外的同步机制（例如 `std::call_once` 或互斥锁）来避免潜在的竞争条件。

3. 缺点: 

   **资源浪费**(主要)：即使单例未被使用，类加载时就会创建实例，导致不必要的资源消耗。

   **不支持延迟初始化**：实例在程序启动时就创建，无法根据需要延迟创建。

   **初始化顺序问题**：在静态变量初始化时可能会引发顺序问题，导致错误或未定义行为。

   **无法处理复杂并发需求**：对复杂资源或多线程环境下的初始化需求处理不足。

   **生命周期管理困难**：无法灵活控制单例的销毁和生命周期，难以处理动态加载和卸载。

代码示例：

```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <queue>
#include <condition_variable>
using namespace std;

class Singleton
{
public:
	// 3. 提供一个静态方法返回唯一实例的引用
	static Singleton* getInstance() { return &instance; }

private:
	static Singleton instance;	// 2. 定义该类的唯一实例对象（使用静态变量，在数据段上）
	Singleton() { cout << "Singleton()" << endl; }	// 1.构造函数私有化
	~Singleton() { cout << "~Singleton()" << endl; }

	// 4. 删除拷贝构造和赋值函数 - 不能让他使用默认的
	Singleton(const Singleton&) = delete;
	Singleton& operator=(const Singleton&) = delete;
};

Singleton Singleton::instance;	// 类外初始化静态成员变量

int main()
{
    // 还没有调用, 实例对象就创建了
	Singleton* p1 = Singleton::getInstance(); // 静态成员函数, 需要使用 类名::函数名 使用
	Singleton* p2 = Singleton::getInstance(); 
	Singleton* p3 = Singleton::getInstance();

	//Singleton t = *p1;  // 单例模式不允许, 需要删除类内 拷贝和赋值函数

	return 0;
}



```



测试结果：  

```cpp
Singleton()
008EE1E0
008EE1E0
008EE1E0
~Singleton()
```

可以看到，该程序通过饿汉式单例模式实现了单例的创建和管理，确保了整个程序中`Singleton`类只有一个实例。程序输出验证了单例模式的正确性，所有获取的引用都指向同一个实例

### 1.2 懒汉式单例模式 -- 受欢迎

1. 什么是懒汉式单例?

   **懒汉式单例**（Lazy Singleton）是单例设计模式的另一种实现方式，与饿汉式单例不同，它是在第一次需要实例化时才创建对象，而不是在程序启动时就立即创建。

代码示例：

```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <queue>
#include <condition_variable>
using namespace std;

class Singleton
{
public:
	
	static Singleton* getInstance() 
	{
		if (instance == nullptr)  //#3 延迟实例化
		{
			instance = new Singleton();
		}
		return instance; 
	}
	static void destroyInstance()
	{
		delete instance;
	}

private:
	static Singleton* instance;	  // #1 修改为指针, 更好的是使用智能指针, 为了自动析构, 这种一般指针, 还得写 销毁函数, 手动释放
	Singleton() { cout << "Singleton()" << endl; }	
	~Singleton() { cout << "~Singleton()" << endl; }


	Singleton(const Singleton&) = delete;
	Singleton& operator=(const Singleton&) = delete;
};

Singleton* Singleton::instance=nullptr;	// #2 初始化为空

int main()
{
	Singleton* p1 = Singleton::getInstance(); 
	Singleton* p2 = Singleton::getInstance(); 
	Singleton* p3 = Singleton::getInstance();


	cout << p1 << endl;
	cout << p2 << endl;
	cout << p3 << endl;

	Singleton::destroyInstance();

	return 0;
}
```



测试结果：

```cpp
Singleton()
00F20548
00F20548
00F20548
~Singleton()
```

### 1.3 线程安全的懒汉式单例模式--锁+volatile

1. **可重入函数**（Reentrant Function）是指在多线程或中断处理的环境下，函数能够安全地被多个线程或中断同时调用，即使在执行过程中该函数被再次调用，也能保证不会产生数据不一致或程序崩溃

2. 上面实现的懒汉式单例模式**是有问题**的

   其中`getInstance`函数**不是**可重入函数

   **根源在于**:

   会有线程安全的问题`getInstance`有**三个**步骤：**开辟内存、构造对象、给`instance`赋值**（编译器翻译成汇编指令的顺序或者也可以是开辟内存、给`instance`赋值、构造对象）, 不是原子操作

无论两种情况中的哪种，只要是线程一在给`instance`赋值之前，如果有线程二进入此函数，就会造成线程不安全。



**加锁的懒汉单例**



```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <queue>
#include <condition_variable>
using namespace std;

std::mutex mtx;
class Singleton
{
public:
	
	static Singleton* getInstance() 
	{
		//lock_guard<std::mutex> guard(mtx);  // 这个位置 锁力度太大
		if (instance == nullptr)  
		{
			lock_guard<std::mutex> guard(mtx); // 只在第一次实例化时 加锁, 这有这一块 是步骤多的, 不是原子操作
			// 加锁后, 还要判断
			if (instance == nullptr)
			{
				instance = new Singleton();
			}
			
		}
		return instance; 
	}
	static void destroyInstance()
	{
		delete instance;
	}

private:
	static Singleton *volatile instance;	  // 同时要保证 不缓存
	Singleton() { cout << "Singleton()" << endl; }	
	~Singleton() { cout << "~Singleton()" << endl; }


	Singleton(const Singleton&) = delete;
	Singleton& operator=(const Singleton&) = delete;
};

Singleton * volatile Singleton::instance=nullptr;

int main()
{
	Singleton* p1 = Singleton::getInstance(); 
	Singleton* p2 = Singleton::getInstance(); 
	Singleton* p3 = Singleton::getInstance();


	cout << p1 << endl;
	cout << p2 << endl;
	cout << p3 << endl;

	Singleton::destroyInstance();

	return 0;
}
```



给`instance`加一个`volatile`，这是给指针加的（不是给指针的指向加的）。好处是当一个线程对`instance`赋值时，其他线程马上均能看到`instance`的改变。因为线程现在已经不对共享变量进行缓存了，大家看的都是其原始内存中的值



**非互斥锁的线程安全懒汉式单例模式**

```cpp
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <queue>
#include <condition_variable>
using namespace std;

std::mutex mtx;
class Singleton
{
public:
	
	static Singleton* getInstance() 
	{
		static Singleton instance;
		return &instance; 
	}


private:
		
	Singleton() { cout << "Singleton()" << endl; }	
	~Singleton() { cout << "~Singleton()" << endl; }


	Singleton(const Singleton&) = delete;
	Singleton& operator=(const Singleton&) = delete;
};


int main()
{
	Singleton* p1 = Singleton::getInstance(); 
	Singleton* p2 = Singleton::getInstance(); 
	Singleton* p3 = Singleton::getInstance();


	cout << p1 << endl;
	cout << p2 << endl;
	cout << p3 << endl;


	return 0;
}
```

**函数静态局部变量的初始化在汇编指令上已经自动添加线程互斥指令了**，也就是已经线程安全了！(linux下 gdb调试, 看底层汇编, 看老师博客) vs里看汇编是看不到的

**在 C++11 及以后的标准中，**局部静态变量的初始化**是 **线程安全的**，**

**对于static静态局部变量的初始化，编译器会自动对它的初始化进行加锁和解锁控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量，因此上面的懒汉单例模式是线程安全的单例模式！**

## 三、工厂模式（创建型模式）

主要**用于 创建对象 非常多的 时候**



先了解一下工厂模式

**工厂模式**是一个比较常用的**创建型**设计模式，**`主要是封装了对象的创建`**，其中可以细分为三种：**简单工厂模式（Simple Factory）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）**





### 3.1 简单工厂模式

#### 基本概念

**简单工厂模式：**

- **定义**：简单工厂模式只有一个工厂类，通过该工厂类的**静态方法**来创建具体的产品对象。工厂类根据不同的参数决定实例化哪一个产品类（简单工厂模式不属于标准OOP设计模式中的一项）
- **适用场景**：适用于**产品种类较少且不经常扩展**的场合。可以快速创建不同的产品对象，但扩展性有限





#### 代码示例:

**枚举类和简单工厂类**

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Car
{
public:
	Car(string name) : _name(name) {}
	virtual void show() = 0;
protected:
	string _name;
};

class Bmw : public Car
{
public:
	Bmw(string name) : Car(name) {}
	void show() override { cout << "我是宝马：" << _name << endl; }
};

class Audi : public Car
{
public:
	Audi(string name) : Car(name) {}
	void show() override { cout << "我是奥迪：" << _name << endl; }
};

enum CarType  // 枚举值
{
	BMW, AUDI
};

class SimpleFactory   // 简单工厂的 核心
{
public:
	static Car* createCar(CarType ct)
	{
		switch (ct)
		{
		case BMW:
			return new Bmw("X3");
		case AUDI:
			return new Audi("A8");
		default:
			cerr << "传入参数不正确" << ct<< endl;
			return nullptr;
		}
	}
};

int main()
{
	// 买车, 不需要知道车是怎么构造的
	//Car* p1 = new Bmw("Bmw X1"); //使用的时候, 需要记住 很多 派生类名

	// Car* p1 = SimpleFactory::createCar(BMW);  
	// Car* p2 = SimpleFactory::createCar(AUDI);
	// if (p1) p1->show();
	// if (p2) p2->show();
	// delete p1;
	// delete p2;

	// 改成智能指针，自动释放资源, 注意需要头文件memory
	unique_ptr<Car> p1(SimpleFactory::createCar(BMW));
	unique_ptr<Car> p2(SimpleFactory::createCar(AUDI));
	if (p1) p1->show();
	if (p2) p2->show();

	return 0;
}
```

现在，简单工厂模式就实现了，但是这种方法有一些缺陷，因为同一个工厂不会又造宝马又造奥迪，又造手机又造键盘的，这一般不符合实际的情况，而且最重要的是这个工厂**不符合“开闭原则”**，如果我们要增删车辆，就要修改接口，这样很不好。

基于这样的缺陷，接下来看看**工厂方法模式**

### 3.2 工厂方法模式

#### 基本概念

**工厂方法模式：**

- **定义**：工厂方法模式由一个抽象工厂类和多个具体工厂类组成。每个具体工厂类负责创建**一个**具体产品对象。通过继承抽象工厂类的方法，可以多态地创建不同的具体产品
- **适用场景**：适用于**某个产品种类中包含多个具体产品**的情况。能够通过增加新的工厂类来扩展产品系列

#### 代码核心逻辑--重点

**核心思想：** 工厂模式的核心是：**通过工厂类来创建对象**，而不是直接在代码中使用 `new` 来实例化对象。这样，你将对象的创建过程封装在一个工厂类中，客户端只关心如何使用对象，而不需要关心对象是怎么创建的。

- **产品接口（Product）**：定义产品的公共接口。
- **具体产品类（ConcreteProduct）**：实现产品接口，提供具体的业务逻辑。
- **工厂类（Factory）**：负责创建产品对象，通常会有一个方法用来创建产品。





**如何写工厂模式：**---重点

1. **定义一个产品接口（Product）**，它是所有具体产品类的公共接口。
2. **创建多个具体产品类（ConcreteProduct）**，实现产品接口并提供具体功能。
3. **定义工厂类（Factory）**，在其中创建具体产品对象，隐藏创建细节。

**总结：** 工厂模式通过**工厂类**来创建对象，客户端通过工厂来获得产品，而无需关心具体的创建细节。





#### 代码实例: 

 **工厂方法类(虚构造函数)及其派生类**

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Car
{
public:
	Car(string name) : _name(name) {}
	virtual void show() = 0;
protected:
	string _name;
};

class Bmw : public Car
{
public:
	Bmw(string name) : Car(name) {}
	void show() override { cout << "我是宝马：" << _name << endl; }
};

class Audi : public Car
{
public:
	Audi(string name) : Car(name) {}
	void show() override { cout << "我是奥迪：" << _name << endl; }
};

// 工厂方法
class Factory
{
public:
	virtual Car* createCar(string name) = 0; // 工厂方法
};
// 宝马工厂
class BMWFactory : public Factory
{
public:
	Car* createCar(string name) override { return new Bmw(name); }
};
// 奥迪工厂
class AudiFactory : public Factory
{
public:
	Car* createCar(string name) override { return new Audi(name); }
};

int main()
{
	// 这个构建有点麻烦, 慢慢看, 先创建相应的工厂, 在使用工厂创建相应的产品

	//unique_ptr<Factory> bmwfty(new BMWFactory());
	unique_ptr<Factory> bmwfty = make_unique<BMWFactory>() ; // c++14 new在外面是不行的
	unique_ptr<Factory> audifty(new AudiFactory());

	unique_ptr<Car> p1(bmwfty->createCar("X6"));
	unique_ptr<Car> p2(audifty->createCar("A8"));
	p1->show();
	p2->show();

	return 0;
}
```

现在**符合“开闭原则”**，如果现在想加一个奔驰工厂，直接增加`BenzFactory`类就行了

### 3.3 抽象工厂模式

#### 基本概念

**抽象工厂模式：**

- **定义**：抽象工厂模式由一个抽象工厂类和多个具体工厂类组成，同时**有多个产品接口或抽象类**。每个具体工厂类可以**创建一组相关的产品对象**
- **适用场景**：适用于涉及多个产品种类的复杂系统，可以创建一组相关或依赖的产品对象。适合于需要创建多个系列产品的情况

**工厂方法与抽象工厂区别**：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。因此，**工厂方法模式可以被视为抽象工厂模式的一个特例或简化形式**





#### 核心代码逻辑  --- 重点

**抽象工厂模式（Abstract Factory Pattern）**

**核心思想：** 抽象工厂模式的核心是：**提供一个接口来创建一系列相关的对象**。它不仅能创建一个单一的产品对象，还能创建多个不同类型的相关产品对象。抽象工厂模式是工厂模式的进一步扩展，适用于需要生成多个不同类别对象的场景。

- **抽象工厂接口（AbstractFactory）**：定义创建一组相关产品的方法。
- **具体工厂类（ConcreteFactory）**：实现抽象工厂接口，负责创建具体产品。
- **抽象产品接口（AbstractProduct）**：定义产品的公共接口。
- **具体产品类（ConcreteProduct）**：实现抽象产品接口，提供具体产品的功能。

**如何写抽象工厂模式：**--**重点**

1. **定义抽象工厂接口（AbstractFactory）**，声明一组方法来创建相关产品。
2. **定义具体工厂类（ConcreteFactory）**，实现抽象工厂接口并提供产品的具体创建方法。
3. **定义抽象产品接口（AbstractProduct）**，声明产品的公共方法。
4. **创建多个具体产品类（ConcreteProduct）**，每个产品类实现抽象产品接口。

**总结：** 抽象工厂模式不仅能创建一个产品对象，还能创建多个相关的产品。它将产品的创建和具体产品的实现分开，保证了产品的一致性。



#### 代码示例:



当一个工厂不止生产车, 还生产对应的灯, 即**一组产品**

还有缺点:  基类添加新产品时, 派生类也得加

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Car {
public:
	virtual void show() = 0;
};

class Light {
public:
	virtual void type() = 0;
};
// ===================================================
class BMWCar : public Car {
public:
	void show() override { cout << "BMW car" << endl; }
};

class BMWLight : public Light {
public:
	void type() override { cout << "BMW Light" << endl; }
};
// ===================================================
class AudiCar : public Car {
public:
	void show() override { cout << "Audi car" << endl; }
};

class AudiLight : public Light {
public:
	void type() override { cout << "Audi Light" << endl; }
};
// ===================================================
class AbstractFactory {
public:	// 产品簇
	virtual Car* createCar() = 0;
	virtual Light* createLight() = 0;
};

class BMWFactory : public AbstractFactory {
public:
	Car* createCar() override { return new BMWCar(); }
	Light* createLight() override { return new BMWLight(); }
};

class AudiFactory : public AbstractFactory {
public:
	Car* createCar() override { return new AudiCar(); }
	Light* createLight() override { return new AudiLight(); }
};
// ===================================================
int main()
{
	// 创建具体工厂
	unique_ptr<AbstractFactory> bmwfty(new BMWFactory());
	unique_ptr<AbstractFactory> audifty(new AudiFactory());

	// 使用工厂创建产品
	unique_ptr<Car> bmwCar(bmwfty->createCar());
	unique_ptr<Light> bmwLight(bmwfty->createLight());
	unique_ptr<Car> audiCar(audifty->createCar());
	unique_ptr<Light> audiLight(audifty->createLight());
	if (bmwCar) bmwCar->show();
	if (bmwLight) bmwLight->type();
	if (audiCar) audiCar->show();
	if (audiLight) audiLight->type();

	return 0;
}
```





### 工厂模式总结--特点

**简单工厂 (Simple Factory)**：

- 把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象。
- 客户不用自己负责 `new` 对象，不用了解对象创建的详细过程。
- 提供创建对象实例的接口函数**不闭合，不能对修改关闭**。

**工厂方法 (Factory Method)**：

- Factory 基类，提供了一个**纯虚函数（创建产品）**，定义派生类（具体产品的工厂）负责创建对应的产品。
- 可以做到**不同的产品，在不同的工厂里面创建**，能够对现有工厂，以及产品的修改关闭。
- 实际上，很多产品是有关联关系的，属于一个产品簇，不应该放在不同的工厂里面去创建，这样：
  - 一是不符合实际的产品对象创建逻辑。
  - 二是工厂类太多了，不好维护。

**抽象工厂 (Abstract Factory)**：

- 把有关联关系的，属于**一个产品簇的所有产品**创建的接口函数，放在一个抽象工厂里面 `AbstractFactory`。
- 派生类（具体产品的工厂）应该负责创建该产品簇里面所有的产品。

## 四、代理模式（结构型模式）

###  基本概念

proxy--代理



注意: 在很多设计模式中，都会用到 **基类指针指向派生类对象**，这是一种 **面向对象编程（OOP）** 的典型技巧，主要依赖于 **多态（Polymorphism）** 的特性。



**代理模式**：通过一个**代理对象**来控制实际对象的访问权限

> 例如：**客户 <->** **助理（代理）** <->**老板（委托类：实际对象）**





### 核心代码逻辑 -- 重点

**代理模式的结构**

- **Subject（抽象主题类）**：定义目标对象和代理对象的公共接口。
- **RealSubject（真实主题类）**：定义了代理类所代表的目标对象的实际业务逻辑。
- **Proxy（代理类）**：实现 `Subject` 接口，控制对 `RealSubject` 对象的访问。在代理类中可以执行额外的操作，如日志记录、权限检查、缓存等。

**如何写代理类**

1. **定义一个抽象的 `Subject` 类**，这是目标对象和代理对象共享的接口。
2. **定义一个 `RealSubject` 类**，它实现了 `Subject` 接口并实现了实际的业务逻辑。
3. **定义一个 `Proxy` 类**，它实现了 `Subject` 接口，持有 `RealSubject` 的引用，并在对真实对象的访问前后执行一些额外操作。

### **代码示例：**

```cpp
#include <iostream>
#include <memory>
using namespace std;

// 抽象类：视频站点   #1 
class VideoSite
{
public:
	virtual void freeMovie() = 0;	// 免费电影
	virtual void vipMovie() = 0;	// VIP电影
	virtual void ticketMovie() = 0; // 用券观看电影
	virtual ~VideoSite() = default; // 虚析构函数以确保派生类正确析构 
};

// 委托类：实际对象（IQIYI 视频站点）  #2
class IQIYIVideoSite : public VideoSite
{
public:
	virtual void freeMovie() { cout << "观看免费电影" << endl; }
	virtual void vipMovie() { cout << "观看VIP电影" << endl; }
	virtual void ticketMovie() { cout << "用券观看电影" << endl; }
};

// 代理类：免费用户代理   #3
class FreeProxy : public VideoSite
{
public:
	FreeProxy() { Video = new IQIYIVideoSite(); }
	~FreeProxy() { delete Video; }

	// 通过代理类中重写的方法，来访问真正委托类的方法
	virtual void freeMovie() { Video->freeMovie(); }
	virtual void vipMovie() { cout << "您目前只是普通游客，需要升级成VIP，才能观看VIP电影" << endl; }
	virtual void ticketMovie() { cout << "您目前没有券，需要购买电影券，才能观看电影" << endl; }
private:
	VideoSite* Video; // 持有实际对象的指针 #4
};

// 代理类：VIP用户代理
class VipProxy : public VideoSite
{
public:
	VipProxy() { Video = new IQIYIVideoSite(); }
	~VipProxy() { delete Video; }

	// 通过代理类中重写的方法，来访问真正委托类的方法
	virtual void freeMovie() { Video->freeMovie(); }
	virtual void vipMovie() { Video->vipMovie(); }
	virtual void ticketMovie() { cout << "您目前没有券，需要购买电影券，才能观看电影" << endl; }
private:
	VideoSite* Video; // 持有实际对象的指针
};

// 代理类：使用电影券用户代理
class TicketProxy : public VideoSite
{
public:
	TicketProxy() { Video = new IQIYIVideoSite(); }
	~TicketProxy() { delete Video; }

	// 通过代理类中重写的方法，来访问真正委托类的方法
	virtual void freeMovie() { Video->freeMovie(); }
	virtual void vipMovie() { Video->vipMovie(); }
	virtual void ticketMovie() { Video->ticketMovie(); }
private:
	VideoSite* Video; // 持有实际对象的指针
};

// 这些都是通用的API接口，使用的都是基类的指针或者引用
void watchMovie(unique_ptr<VideoSite>& ptr)
{
	ptr->freeMovie();
	ptr->vipMovie();
	ptr->ticketMovie();
}

int main() {
	unique_ptr<VideoSite> p1(new FreeProxy);   // 创建免费用户代理对象
	unique_ptr<VideoSite> p2(new VipProxy);    // 创建VIP用户代理对象
	unique_ptr<VideoSite> p3(new TicketProxy); // 创建使用电影券用户代理对象

	watchMovie(p1); // 观看电影，使用免费用户代理
	cout << "===================" << endl;
	watchMovie(p2); // 观看电影，使用VIP用户代理
	cout << "===================" << endl;
	watchMovie(p3); // 观看电影，使用电影券用户代理

	return 0;
}
```



## 五、装饰器模式（结构型模式）-重点在于不修改原来的代码

### 基本概念

**装饰器模式**：可以**动态地添加行为到对象中**，而**不需要修改类的定义**

**解决的问题**： 为了**增强现有类的功能** , 通过实现子类的方式, 重写接口, 是可以完成功能 扩展的, 但是代码 中 有太多子类 添加进来了



**不使用装饰器, 原本的子类 都需要写 每个子类 对应的 新子类,   使用装饰器, 整体只需要写 一遍 新子类**



### 代码核心逻辑

**装饰器模式（Decorator Pattern）**

**核心思想：** 装饰器模式的核心是：**动态地给对象添加额外的功能**。装饰器模式**允许你在不修改对象原有代码**的情况下，给对象增加新的行为或功能。它通过将对象包装在一个装饰器中，来扩展它的功能。

**通俗的解释：** 装饰器模式就像是在一个基础功能的物品上 **加装不同的配件**，每个配件都能给物品增加一些新功能，但你不需要修改物品本身。比如，你有一辆车，车本身就有基本功能（如行驶），而你可以选择性地添加空调、音响、座椅加热等配件，这些配件就像装饰器一样，给原车增加了新功能。--**这就像抽象工厂, 每次工厂需要添加新的物件, 都要增加基类和派生类的 对应 虚函数**



**如何实现装饰器模式：**

1. **抽象组件基类（Component）**：定义基本功能的接口，所有装饰器和被装饰的对象都实现这个接口。
2. **具体组件（ConcreteComponent）**：实现了基本功能的类，提供最基础的行为。
3. **装饰器基类（Decorator）**：也实现了组件接口，但它在持有组件实例的同时，**扩展了功能**。
4. **具体装饰器（ConcreteDecorator）**：继承装饰器类，提供实际的功能扩展。





**总结：**

装饰器模式允许你通过“包裹”对象来 **动态地添加新功能**，而不需要修改原始对象的代码。通过装饰器，你可以按需增加功能，且多个装饰器可以组合使用，形成多样的功能扩展。



### 代码示例

**代码示例（普通指针版本）： ** -- 可以使用 智能指针

```cpp
#include <iostream>
#include <memory>
using namespace std;

// 抽象基类（组件）
class Car
{
public:
    virtual void show() = 0;
    virtual ~Car() = default; // 虚析构函数
};

// 三种汽车（具体组件）
class Bmw : public Car
{
public:
    void show() override { cout << "这是一辆宝马汽车，配置有：基本配置"; }
};

class Audi : public Car
{
public:
    void show() override { cout << "这是一辆奥迪汽车，配置有：基本配置"; }
};

class Benz : public Car
{
public:
    void show() override { cout << "这是一辆奔驰汽车，配置有：基本配置"; }
};

// 装饰器基类
class CarDecorator : public Car
{
public:
    CarDecorator(Car* car) : pCar(car) {}
    virtual ~CarDecorator() { delete pCar; } // 确保释放被装饰的对象
protected:
    Car* pCar;
};

// 装饰器1：定速巡航
class CruiseControl : public CarDecorator
{
public:
    CruiseControl(Car* car) : CarDecorator(car) {}
    void show() override
    {
        pCar->show();
        cout << ", 定速巡航";
    }
};

// 装饰器2：自动刹车
class AutoBrake : public CarDecorator
{
public:
    AutoBrake(Car* car) : CarDecorator(car) {}
    void show() override
    {
        pCar->show();
        cout << ", 自动刹车";
    }
};

// 装饰器3：车道偏离
class LaneDepartureWarning : public CarDecorator
{
public:
    LaneDepartureWarning(Car* car) : CarDecorator(car) {}
    void show() override
    {
        pCar->show();
        cout << ", 车道偏离";
    }
};

int main()
{
    //Car* bmw = new Bmw();  // 只有基类配置

    //修改1
    //Car* p1 = new Bmw();
    //p1 = new CruiseControl(p1); // 在基类配置上 添加了定速巡航

    //修改2  这三种方式都可以
    Car* p1 = new CruiseControl(new Bmw());

    p1 = new AutoBrake(p1); // 继续添加了 自动刹车
    p1 = new LaneDepartureWarning(p1); // 继续添加了 车道偏离
    p1->show();




    cout << endl;
    delete p1; // 确保释放内存

    Car* audi = new Audi();
    Car* p2 = new AutoBrake(audi);
    p2->show();
    cout << endl;
    delete p2; // 确保释放内存

    Car* benz = new Benz();
    Car* p3 = new LaneDepartureWarning(benz);
    p3->show();
    cout << endl;
    delete p3; // 确保释放内存

    return 0;
}
```

## 六、适配器模式（结构型模式）

### 基本概念

**适配器模式**：使**不兼容的接口**能够一起工作

电源转换插头、HDMI转VGA的线，这些都是适配器模式在生活中的例子



### 代码逻辑核心

**适配器模式（Adapter Pattern）**

**核心思想：** 适配器模式的核心是：**通过一个适配器类来将不兼容的接口转换成可以使用的接口**。它允许你将一个类的接口转换成客户端期望的另一个接口，从而解决接口不兼容的问题。适配器模式常用于连接不同的系统、模块或库，使它们能够互相工作。

**通俗的解释：** 适配器模式就像是你需要在中国用美国的电器插头，这时候你需要一个 **插头转换器**，它可以把美国的插头转换成中国的插座接口。**适配器类**就是这个转换器，它的作用是将一个类的接口转变成你所需要的接口，让两个原本不兼容的系统可以一起工作。





**如何实现适配器模式：**

1. **目标接口（Target）**：定义客户端所期望的接口。
2. **源接口（Adaptee）**：需要被适配的接口，通常是你无法直接修改或不符合你需求的接口。
3. **适配器（Adapter）**：实现目标接口，将源接口转换为目标接口的适配器。



**总结：**

适配器模式通过**适配器类**将一个类的接口转换成另一个接口，从而使两个原本不兼容的接口可以一起工作。就像插头转换器一样，适配器在不修改源接口的情况下，适配成我们所需要的接口。







### **代码示例：**  

```cpp
#include <iostream>
#include <memory>
using namespace std;

// VGA 接口类
class VGA
{
public:
	virtual void play() = 0;
	virtual ~VGA() = default;
};

// 具体的 VGA 投影仪
class VGAProjector : public VGA
{
public:
	void play() override { cout << "通过 VGA 接口连接投影仪，进行视频播放" << endl; }
};

// HDMI 接口类
class HDMI
{
public:
	virtual void play() = 0;
	virtual ~HDMI() = default;
};

// 具体的 HDMI 投影仪
class HDMIProjector : public HDMI
{
public:
	void play() override { cout << "通过 HDMI 接口连接投影仪，进行视频播放" << endl; }
};

// 适配器类，将 VGA 接口转换为 HDMI 接口
class VGAToHDMIAdapter : // VGA 接口类
	class VGA
{
public:
	virtual void play() = 0;
	virtual ~VGA() = default;
};

// 具体的 VGA 投影仪
class VGAProjector : public VGA
{
public:
	void play() override { cout << "通过 VGA 接口连接投影仪，进行视频播放" << endl; }
};

// HDMI 接口类
class HDMI
{
public:
	virtual void play() = 0;
	virtual ~HDMI() = default;
};

// 具体的 HDMI 投影仪
class HDMIProjector : public HDMI
{
public:
	void play() override { cout << "通过 HDMI 接口连接投影仪，进行视频播放" << endl; }
};

// 适配器类，将 VGA 接口转换为 HDMI 接口
class VGAToHDMIAdapter : public VGA
{
public:
	VGAToHDMIAdapter(HDMI* p) : pHdmi(p) {}
	void play() override { pHdmi->play(); }  // 该方法相当于转换头, 做不同接口的 信号转换
private:
	HDMI* pHdmi;
};

// 电脑类，只支持 VGA 接口
class Computer
{
public:
	void playVideo(VGA* pVGA) { pVGA->play(); }
};

int main() {
	// 创建 Computer 对象
	Computer* computer = new Computer();

	// 通过 VGA 接口连接投影仪
	VGAProjector* vgaProjector = new VGAProjector();
	computer->playVideo(vgaProjector);

	// 通过 HDMI 接口连接投影仪，使用适配器
	HDMIProjector* hdmiProjector = new HDMIProjector();
	VGAToHDMIAdapter* adapter = new VGAToHDMIAdapter(hdmiProjector);
	computer->playVideo(adapter);

	// 手动释放所有动态分配的内存
	delete adapter;
	delete hdmiProjector;
	delete vgaProjector;
	delete computer;

	return 0;
}
{
public:
	VGAToHDMIAdapter(HDMI* p) : pHdmi(p) {}
	void play() override { pHdmi->play(); }
private:
	HDMI* pHdmi;
};

// 电脑类，只支持 VGA 接口
class Computer
{
public:
	void playVideo(VGA* pVGA) { pVGA->play(); }
};

int main() {
	// 创建 Computer 对象
	Computer* computer = new Computer();

	// 通过 VGA 接口连接投影仪
	VGAProjector* vgaProjector = new VGAProjector();
	computer->playVideo(vgaProjector);

	// 通过 HDMI 接口连接投影仪，使用适配器
	HDMIProjector* hdmiProjector = new HDMIProjector();
	VGAToHDMIAdapter* adapter = new VGAToHDMIAdapter(hdmiProjector);
	computer->playVideo(adapter);

	// 手动释放所有动态分配的内存
	delete adapter;
	delete hdmiProjector;
	delete vgaProjector;
	delete computer;

	return 0;
}
```

## 七、观察者模式（行为型模式）

### 基本概念

行为型模式:  主要关注 对象之间的通信

**观察者模式**，又名**发布-订阅模式**或**事件监听器模式**，主要关注对象之间的**一对多**依赖关系。当一个对象（称为主题或被观察者）的状态**发生改变**时，所有**依赖于它的对象**（称为观察者）都会**收到通知并自动更新**



使用案例: 一组数据对象 => 通过这一组数据 => 曲线图(对象1)/柱状图(对象2)

当数据对象 改变时, 其他对象应该 接到通知

### 代码核心逻辑

**观察者模式（Observer Pattern）**

**核心思想：**
 观察者模式的核心是：**当一个对象的状态发生变化时，所有依赖它的对象都会收到通知，并自动更新。** 这样可以让多个对象之间保持同步，而不需要它们直接相互引用，提高了系统的解耦性。

------

**通俗解释：**

观察者模式就像是 **微信公众号订阅**。

- 公众号（**被观察者**）发布新文章时，会通知所有订阅它的用户（**观察者**）。
- 订阅者（观察者）可以随时关注（添加到列表）或取消关注（从列表移除）。
- 当公众号有新内容时，所有订阅者都会收到通知，而**公众号本身不需要知道每个订阅者的具体信息**。

------

**如何实现观察者模式？**

1. **被观察者（Subject）**：定义一个对象，它持有观察者列表，并提供**添加、删除观察者**的方法，同时定义**通知观察者**的方法。
2. **观察者（Observer）**：定义一个接口，所有具体观察者实现该接口，并提供**更新方法**，当被观察者状态改变时，这些方法会被调用。
3. **具体被观察者（ConcreteSubject）**：实现 `Subject` 接口，维护观察者列表，并在状态改变时通知所有观察者。
4. **具体观察者（ConcreteObserver）**：实现 `Observer` 接口，在 `update()` 方法中接收通知并进行相应处理。

### **代码示例：**

```cpp
#include <iostream>
#include <memory>
#include <unordered_map>
#include <list>
using namespace std;

// 观察者抽象类
class Observer
{
public:
	// 处理消息的接口
	virtual void handle(int msgid) = 0;
	virtual ~Observer() = default;
};

// 第一个观察者实例：对消息1和消息2感兴趣
class Observer1 : public Observer
{
public:
	void handle(int msgid) override
	{
		switch (msgid)
		{
		case 1:
			cout << "Observer1 received message 1" << endl;
			break;
		case 2:
			cout << "Observer1 received message 2" << endl;
			break;
		default:
			cout << "Observer1 received unknown message" << endl;
			break;
		}
	}
};

// 第二个观察者实例：对消息2感兴趣
class Observer2 : public Observer
{
public:
	void handle(int msgid) override
	{
		if (msgid == 2)
		{
			cout << "Observer2 received message 2" << endl;
		}
		else {
			cout << "Observer2 received unknown message" << endl;
		}
	}
};

// 第三个观察者实例：对消息1和消息3感兴趣
class Observer3 : public Observer
{
public:
	void handle(int msgid) override
	{
		switch (msgid)
		{
		case 1:
			cout << "Observer3 received message 1" << endl;
			break;
		case 3:
			cout << "Observer3 received message 3" << endl;
			break;
		default:
			cout << "Observer3 received unknown message" << endl;
			break;
		}
	}
};

// 主题类--被观察者
class Subject {
public:
	// 添加观察者
	void addObserver(Observer* observer, int msgid)
	{
		observers[msgid].push_back(observer);
		//相当于
		/*auto it = observers.find(msgid);
		if (it != observers.end())
		{
			it->second.push_back(observer);
		}
		else
		{
			list<Observer*> lis;
			lis.push_back(observer);
			observers.insert({ msgid, lis });
		}*/

	}

	// 通知观察者
	void notifyObservers(int msgid)
	{
		auto it = observers.find(msgid);
		if (it != observers.end())
			for (Observer* observer : it->second)
				observer->handle(msgid);

	}

private:
	unordered_map<int, list<Observer*>> observers; // list是观察者列表, 因为是多个，按消息ID分类
};

int main() {
	Subject subject;  // 主题
	Observer* p1 = new Observer1(); //观察者们
	Observer* p2 = new Observer2();
	Observer* p3 = new Observer3();

	// 注册观察者到不同的消息ID
	subject.addObserver(p1, 1);
	subject.addObserver(p1, 2);
	subject.addObserver(p2, 2);
	subject.addObserver(p3, 1);
	subject.addObserver(p3, 3);

	int msgid = 0;

	while (true)
	{
		cout << "输入消息ID (-1 退出): ";
		cin >> msgid;
		if (msgid == -1)
			break;
		subject.notifyObservers(msgid);
	}

	// 清理内存
	delete p1;
	delete p2;
	delete p3;

	return 0;
}
```





# 可变参语法

## **1. 基本的可变参数模板**

```
template <typename... Args>
void func(Args... args) {
    // args 是一个参数包
}
```

- `typename... Args` 代表 **类型参数包**，可以接受多个类型。
- `Args... args` 代表 **函数参数包**，对应多个参数。

------

## **2. 可变参数展开（递归）**--这个有点意思

```
#include <iostream>

// 终止递归的函数
void print() {
    std::cout << "End\n";
}

// 递归展开参数包
template <typename First, typename... Rest>
void print(First first, Rest... rest) {
    std::cout << first << " ";
    print(rest...);  // 递归调用
}

int main() {
    print(1, 2.5, "hello", 'A');  // 输出: 1 2.5 hello A End
}
```

- **终止递归** 的 `print()` 解决参数包为空的情况。
- `print(first, rest...)` 依次展开参数包，类似递归。

------

## **3. `sizeof...` 获取参数个数**

```
template <typename... Args>
void countArgs(Args... args) {
    std::cout << "参数个数: " << sizeof...(args) << "\n";
}

int main() {
    countArgs(1, 2, 3.14, "text");  // 输出: 参数个数: 4
}
```

------

## **4. 结合 `std::forward` 进行完美转发**

```
#include <iostream>
#include <utility>  // std::forward

void show(int& x) { std::cout << "Lvalue: " << x << "\n"; }
void show(int&& x) { std::cout << "Rvalue: " << x << "\n"; }

template <typename... Args>
void forwardArgs(Args&&... args) {
    show(std::forward<Args>(args)...);
}

int main() {
    int a = 10;
    forwardArgs(a);   // Lvalue: 10
    forwardArgs(20);  // Rvalue: 20
}
```

- `Args&&... args` 使 `args` 成为 **万能引用**，能够接受左值和右值。
- `std::forward<Args>(args)...` **保持原本的左值/右值特性**，防止不必要的拷贝或移动。

------

## **5. 结合 `std::initializer_list`（参数展开的一种方式）**

```
#include <iostream>

template <typename... Args>
void printAll(Args... args) {
    (std::cout << ... << args) << "\n";  // C++17 折叠表达式
}

int main() {
    printAll(1, " hello ", 3.14);  // 输出: 1 hello 3.14
}
```

- `(std::cout << ... << args)` 是 **C++17 折叠表达式**，简化递归调用。
- **等价于**：`((std::cout << args), ...)`，即 `std::cout << arg1 << arg2 << arg3;`

# C++11容器emplace方法原理剖析(push/insert)

------

本文讲解C++11中的`emplace`



## 基本概念---实际就是得益于完美转发!!

在 C++ STL（标准模板库）中，`emplace` 是用于在容器**中原地构造元素**的方法，相比 `insert` 或 `push_back` 等方法，它可以**减少不必要的对象拷贝或移动**，提高性能。



## 核心区别

push/insert  与 emplace  **直接传入对象(包括临时对象), 是没有区别的**



**传入 对象构造需要的 参数 , 就有区别了**

emplace 不会 拷贝,  push/insert 则需要拷贝

给`emplace`传入`Test`对象构造所需要的参数，会直接在容器底层构造，不会产生构造和析构临时对象的额外花销，效率大大提高。

## 代码示例-1  -- vector



```c++
#include <iostream>
#include <memory>
#include <unordered_map>
#include <list>
using namespace std;

class Test
{
public:
	Test(int) { cout << "Test(int)" << endl; }
	Test(int, int) { cout << "Test(int, int)" << endl; }
	~Test() { cout << "~Test()" << endl; }
	Test(const Test&) { cout << "Test(const Test&)" << endl; }
	Test(Test&&) { cout << "Test(Test&&)" << endl; }
};

int main()
{
	Test t1(10);
	vector<Test> vec;
	vec.reserve(10);

	// Test(int)
	// 直接插入对象，两个是没有区别的
	cout << "=================" << endl;
	// 匹配的是带左值引用参数的拷贝构造函数
	vec.push_back(t1);
	vec.emplace_back(t1);
	//Test(const Test&)
	//Test(const Test&)

	cout << "=================" << endl;
	// 匹配的是带右值引用参数的拷贝构造函数
	vec.push_back(Test(20));
	vec.emplace_back(Test(20));

	/*	Test(int)
		Test(Test&&)
		~Test()
		Test(int)
		Test(Test&&)
		~Test()*/
	cout << "=================" << endl;
	

	// 区别在这
	vec.push_back(20); /*Test(int)
						Test(Test&&)
						~Test()
*/
	vec.emplace_back(20);  // Test(int)

	//vec.push_back(30, 40); // pushback不支持多参这样传入
	vec.push_back(Test(30,40));
	vec.emplace_back(30, 40);
	cout << "=================" << endl;

	return 0;
}
```





## 代码示例-2 -- map键值对  -- 这个很方便

```c++
#include <iostream>
#include <string>
#include <map>
using namespace std;



int main()
{
	map<int, string> m;
	m.insert(make_pair(1, "hzh1" ));
	m.insert({ 2, "hzh2" });
	cout << "=================" << endl;
	m.emplace(3, "hzh3");  // 这个效率很高的

	return 0;
}
```







## **底层原理：**

注意一下 传参时和使用时 的 可变参写法

push_back 仅使用右值引用, 使得更简便,  完美转发 很重要

```cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;



class Test
{
public:
	Test(int) { cout << "Test(int)" << endl; }
	Test(int, int) { cout << "Test(int, int)" << endl; }
	~Test() { cout << "~Test()" << endl; }
	Test(const Test&) { cout << "Test(const Test&)" << endl; }
	Test(Test&&) { cout << "Test(Test&&)" << endl; }
};

// 空间配置器
template<typename T>
class MyAllocator
{
public:
	// 内存开辟、释放
	T* allocate(size_t size) { return (T*)malloc(sizeof(T) * size); }
	void deallocate(void* p) { free(p); }

	// 对象构造、析构  引用折叠
	template<typename... Ty>
	void construct(T* p, Ty&&... args)
	{
		// 本例中是Test对象，args会完美转发，选择调用Test对象中不同的构造方式
		new (p) T(std::forward<Ty>(args)...);
	}
	void destroy(T* p) { p->~T(); }
};

template<typename T, typename Alloc = MyAllocator<T>>
class vector
{
public:
	vector() :_vec(nullptr), _size(0), _idx(0) {}
	// 预留内存空间
	void reserve(size_t size)
	{
		_vec = _allocator.allocate(size);
		_size = size;
	}
	// push_back  右值引用版本, 引用折叠
	template<typename Ty>
	void push_back(Ty&& val)
	{
		_allocator.construct(_vec + _idx, std::forward<Ty>(val));
		++_idx;
	}
	// emplace_back   引用折叠、模板参数包
	template<typename... Ty>
	void emplace_back(Ty&&... args)
	{
		_allocator.construct(_vec + _idx, std::forward<Ty>(args)...);
		++_idx;
	}

private:
	T* _vec;
	int _size;
	int _idx;
	Alloc _allocator;
};

int main()
{
	Test t1(10);
	vector<Test> vec;
	vec.reserve(10);


	// 直接插入对象，两个是没有区别的
	cout << "=================" << endl;
	// 匹配的是带左值引用参数的拷贝构造函数
	vec.push_back(t1);
	vec.emplace_back(t1);


	cout << "=================" << endl;
	// 匹配的是带右值引用参数的拷贝构造函数
	vec.push_back(Test(20));
	vec.emplace_back(Test(20));

	cout << "=================" << endl;


	// 区别在这
	vec.push_back(20); 
	vec.emplace_back(20); 


	//vec.push_back(Test(30, 40));
	vec.emplace_back(30, 40);
	cout << "=================" << endl;

	return 0;
}
```

