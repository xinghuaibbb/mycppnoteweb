# 4.6 如何理解是 TCP 面向字节流协议？

有个读者问我，这么个问题：

> TCP 是面向字节流的协议，UDP 是面向报文的协议？这里的「面向字节流」和「面向报文」该如何理解。


------

## 如何理解字节流？

之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的**发送方的机制不同**，也就是问题原因在发送方。

> 先来说说为什么 UDP 是面向报文的协议？

当用户消息通过 UDP 协议传输时，**操作系统不会对消息进行拆分**，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是**每个 UDP 报文就是一个用户消息的边界**，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。

你可能会问，如果收到了两个 UDP 报文，操作系统是怎么区分开的？

操作系统在收到 UDP 报文后，会将其插入到队列里，**队列里的每一个元素就是一个 UDP 报文**，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。

![图片](https://img-blog.csdnimg.cn/img_convert/a9116c5b375d356048df033dcb53582e.png)



> 再来说说为什么 TCP 是面向字节流的协议？

当用户消息通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。

这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。

举个实际的例子来说明。

发送方准备发送「Hi.」和「I am Xiaolin」这两个消息。

在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。

至于什么时候真正被发送，**取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件**。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。

如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送「Hi.」和「I am Xiaolin」报文，那么实际的发送很有可能是这几种情况。

第一种情况，这两个消息被分到同一个 TCP 报文，像这样：

![图片](https://img-blog.csdnimg.cn/img_convert/02dce678f870c8c70482b6e37dbb5574.png)

第二种情况，「I am Xiaolin」的部分随「Hi」在一个 TCP 报文中发送出去，像这样：

![图片](https://img-blog.csdnimg.cn/img_convert/f58b70cde860188b8f95a433e2f5293b.png)

第三种情况，「Hi.」的一部分随 TCP 报文被发送出去，另一部分和「I am Xiaolin」一起随另一个 TCP 报文发送出去，像这样。

![图片](https://img-blog.csdnimg.cn/img_convert/68080e783d7acc842fa254e4f9ec5630.png)

类似的情况还能举例很多种，这里主要是想说明，我们不知道「Hi.」和「I am Xiaolin」这两个用户消息是如何进行 TCP 分组传输的。

因此，**我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议**。

当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。

要解决这个问题，要交给**应用程序**。



> ## hzh-c
>
> ### 如何理解字节流？
>
> #### 1. **UDP 是面向报文的协议**
> - **发送机制**：操作系统不会对用户消息进行拆分，直接将完整的用户消息组装成一个 UDP 报文发送。
> - **接收机制**：操作系统将每个 UDP 报文作为一个独立的队列元素存储，调用 `recvfrom()` 时，接收方可以直接读取一个完整的用户消息。
> - **特点**：
>   - 每个 UDP 报文就是一个用户消息的边界。
>   - 消息的完整性由 UDP 报文保证。
>
> #### 2. **TCP 是面向字节流的协议**
> - **发送机制**：操作系统可能会将用户消息拆分成多个 TCP 报文发送，或者将多个用户消息合并到一个 TCP 报文中。
> - **接收机制**：接收方接收到的是一个连续的字节流，无法直接区分消息的边界。
> - **特点**：
>   - TCP 不保证用户消息的边界。
>   - 消息的完整性需要应用程序自行处理。
>
> #### 3. **TCP 粘包与拆包问题**
> - **粘包**：多个用户消息被合并到一个 TCP 报文中。
> - **拆包**：一个用户消息被拆分到多个 TCP 报文中。
> - **原因**：
>   - 发送方：受发送缓冲区、发送窗口和网络状况的影响。
>   - 接收方：TCP 只提供字节流，无法直接区分消息边界。
> - **解决方法**：由应用程序处理消息边界，常见方法包括：
>   - 固定长度协议。
>   - 特殊分隔符。
>   - 消息头部携带长度信息。
>
> #### 4. **总结**
> - **UDP**：面向报文，消息边界由协议保证。
> - **TCP**：面向字节流，消息边界需要应用程序处理。



> ## hzh-d
>
> ### 字节流总结
>
> 1. **UDP 是面向报文的协议**  
>    - 每个 UDP 报文对应一个完整的用户消息，消息边界由协议保证。  
>    - 接收方通过 `recvfrom()` 直接读取完整的报文。
>
> 2. **TCP 是面向字节流的协议**  
>    - 用户消息可能被拆分成多个 TCP 报文，也可能多个消息合并到一个 TCP 报文中。  
>    - 接收方接收到的是连续的字节流，消息边界需要应用程序处理。
>
> 3. **TCP 粘包与拆包问题**  
>    - **粘包**：多个消息合并到一个 TCP 报文中。  
>    - **拆包**：一个消息被拆分到多个 TCP 报文中。  
>    - **解决方法**：通过固定长度、分隔符或消息头携带长度信息来处理消息边界。
>
> 4. **核心区别**  
>    - **UDP**：消息边界明确，面向报文。  
>    - **TCP**：消息边界不明确，面向字节流。

## 如何解决粘包？

粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。

一般有三种方式分包的方式：

- 固定长度的消息；
- 特殊字符作为边界；
- 自定义消息结构。

#### 固定长度的消息

这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。

但是这种方式灵活性不高，实际中很少用。

### 特殊字符作为边界

我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。

HTTP 是一个非常好的例子。

![图片](https://img-blog.csdnimg.cn/img_convert/a49a6bb8cd38ae1738d9c00aec68b444.png)

HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。

有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。

### 自定义消息结构

我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。

比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。

```c
struct { 
    u_int32_t message_length; 
    char message_data[]; 
} message;
```

当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整的用户消息来处理了。



> ## hzh-c
>
> ### 解决粘包问题的三种方法
>
> 1. **固定长度的消息**  
>    - **原理**：规定每个消息的长度固定，比如 64 字节，接收方每读取 64 字节就认为是一个完整的消息。  
>    - **优点**：实现简单，无需额外处理。  
>    - **缺点**：灵活性差，无法适应变长消息，浪费带宽。  
>    - **适用场景**：消息长度固定的协议。
>
> 2. **特殊字符作为边界**  
>    - **原理**：在消息之间插入特殊字符（如 `\r\n`），接收方根据特殊字符划分消息边界。  
>    - **优点**：适合变长消息，简单易实现。  
>    - **缺点**：需要对消息内容中的特殊字符进行转义，增加复杂性。  
>    - **适用场景**：如 HTTP 协议使用回车换行符 `\r\n` 作为边界。
>
> 3. **自定义消息结构**  
>    - **原理**：消息由固定大小的包头和变长数据组成，包头中包含数据长度字段，接收方先读取包头解析长度，再读取对应长度的数据。  
>    - **优点**：灵活性高，适合变长消息。  
>    - **缺点**：实现稍复杂，需要解析包头。  
>    - **适用场景**：需要传输变长消息的场景。
>
>    **示例结构**：
>    ```c
>    struct { 
>        u_int32_t message_length;  // 数据长度
>        char message_data[];      // 数据内容
>    } message;
>    ```
>
>    **处理流程**：
>    - 接收方先读取包头（如 4 字节）。
>    - 解析包头中的 `message_length` 字段，确定数据长度。
>    - 按照长度读取数据，组装成完整消息。
>
> ### 总结
> - **固定长度**：简单但不灵活，适合长度固定的消息。
> - **特殊字符**：适合变长消息，但需处理转义问题。
> - **自定义结构**：灵活性最高，适合复杂场景，但实现较复杂。

> ## hzh-d
>
> ### 粘包问题解决方法总结
>
> 1. **固定长度的消息**  
>    - **原理**：规定每个消息的长度固定，接收方按固定长度读取消息。  
>    - **优点**：简单易实现。  
>    - **缺点**：不灵活，浪费带宽。  
>    - **适用场景**：消息长度固定的场景。
>
> 2. **特殊字符作为边界**  
>    - **原理**：在消息之间插入特殊字符，接收方根据特殊字符划分消息边界。  
>    - **优点**：适合变长消息，易实现。  
>    - **缺点**：需处理消息内容中的特殊字符转义问题。  
>    - **适用场景**：如 HTTP 协议使用 `\r\n` 作为边界。
>
> 3. **自定义消息结构**  
>    - **原理**：消息由固定大小的包头和变长数据组成，包头中包含数据长度字段。  
>    - **优点**：灵活性高，适合变长消息。  
>    - **缺点**：实现稍复杂，需要解析包头。  
>    - **适用场景**：需要传输变长消息的复杂场景。
>
> ### 总结
> - **固定长度**：简单但不灵活。  
> - **特殊字符**：适合变长消息，但需处理转义。  
> - **自定义结构**：灵活性最高，适合复杂场景。
