# 4.14 HTTPS 中 TLS 和 TCP 能同时握手吗？

大家好，我是小林。

有位读者在面试的时候，碰到这么个问题：

![图片](https://img-blog.csdnimg.cn/img_convert/4d07f1ab714bb4b3efefbf5655b2f81e.png)

面试官跟他说 **HTTPS 中的 TLS 握手过程可以同时进行三次握手**，然后读者之前看我的文章是说「*先进行 TCP 三次握手，再进行 TLS 四次握手*」，他跟面试官说了这个，面试官说他不对，他就感到很困惑。

我们先不管面试官说的那句「*HTTPS 中的 TLS 握手过程可以同时进行三次握手*」对不对。

但是面试官说「*HTTPS 建立连接的过程，先进行 TCP 三次握手，再进行 TLS 四次握手*」是错的，**这很明显面试官的水平有问题，这种公司不去也罢！**

如果是我面试遇到这样的面试官，我直接当场给他抓 HTTPS 建立过程的网络包，然后给他看，啪啪啪啪啪的打他脸。

比如，下面这个 TLSv1.2 的 基于 RSA 算法的四次握手过程：

![图片](https://img-blog.csdnimg.cn/img_convert/4e4f0d13effbeaf963992148b022ef3f.png)

难道不是先三次握手，再进行 TLS 四次握手吗？面试官你脸疼吗？

不过 TLS 握手过程的次数还得看版本。

TLSv1.2 握手过程基本都是需要四次，也就是需要经过 2-RTT 才能完成握手，然后才能发送请求，而 TLSv1.3 只需要 1-RTT 就能完成 TLS 握手，如下图。

![图片](https://img-blog.csdnimg.cn/img_convert/0877fe78380bf34ad3b28768e59fb53a.png)

**一般情况下，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行**，因为 HTTPS 都是基于 TCP 传输协议实现的，得先建立完可靠的 TCP 连接才能做 TLS 握手的事情。

> 那面试官说的这句「HTTPS 中的 TLS 握手过程可以同时进行三次握手」对不对呢？

这个场景是可能发生的，但是需要在特定的条件下才可能发生，**如果没有说任何前提条件，说这句话就是在耍流氓。**

那到底什么条件下，这个场景才能发生呢？需要下面这两个条件同时满足才可以：

- **客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；**
- **客户端和服务端已经完成过一次通信。**

那具体怎么做到的呢？我们先了解些 TCP Fast Open 功能和 TLSv1.3 的特性。

## TCP Fast Open

> 我们先来了解下什么是 TCP Fast Open？

常规的情况下，如果要使用 TCP 传输协议进行通信，则客户端和服务端通信之前，先要经过 TCP 三次握手后，建立完可靠的 TCP 连接后，客户端才能将数据发送给服务端。

其中，TCP 的第一次和第二次握手是不能够携带数据的，而 TCP 的第三次握手是可以携带数据的，因为这时候客户端的 TCP 连接状态已经是 ESTABLISHED，表明客户端这一方已经完成了 TCP 连接建立。

![图片](https://img-blog.csdnimg.cn/img_convert/35bc3541c237686aa36e0a88f80592d4.png)

就算客户端携带数据的第三次握手在网络中丢失了，客户端在一定时间内没有收到服务端对该数据的应答报文，就会触发超时重传机制，然后客户端重传该携带数据的第三次握手的报文，直到重传次数达到系统的阈值，客户端就会销毁该 TCP 连接。

说完常规的 TCP 连接后，我们再来看看 TCP Fast Open。

TCP Fast Open 是为了绕过 TCP 三次握手发送数据，在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。

要使用 TCP Fast Open 功能，客户端和服务端都要同时支持才会生效。

不过，开启了 TCP Fast Open 功能，**想要绕过 TCP 三次握手发送数据，得建立第二次以后的通信过程。**

在客户端首次建立连接时的过程，如下图：

![图片](https://img-blog.csdnimg.cn/img_convert/7cb0bd3cde30493fec9562cbdb549f83.png)

具体介绍：

- 客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；
- 支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 报文中的 Fast Open 选项以发回客户端；
- 客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。

所以，第一次客户端和服务端通信的时候，还是需要正常的三次握手流程。随后，客户端就有了 Cookie 这个东西，它可以用来向服务器 TCP 证明先前与客户端 IP 地址的三向握手已成功完成。

对于客户端与服务端的后续通信，客户端可以在第一次握手的时候携带应用数据，从而达到绕过三次握手发送数据的效果，整个过程如下图：

![图片](https://img-blog.csdnimg.cn/img_convert/fc452688b9351e0cabf60212dde3f21e.png)

我详细介绍下这个过程：

- 客户端发送 SYN 报文，该报文可以携带「应用数据」以及此前记录的 Cookie；
- 支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「应用数据」递送给对应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「应用数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；
- **如果服务器接受了 SYN 报文中的「应用数据」，服务器可在握手完成之前发送「响应数据」，这就减少了握手带来的 1 个 RTT 的时间消耗**；
- 客户端将发送 ACK 确认服务器发回的 SYN 以及「应用数据」，但如果客户端在初始的 SYN 报文中发送的「应用数据」没有被确认，则客户端将重新发送「应用数据」；
- 此后的 TCP 连接的数据传输过程和非 TCP Fast Open 的正常情况一致。

所以，如果客户端和服务端同时支持 TCP Fast Open 功能，那么在完成首次通信过程后，后续客户端与服务端 的通信则可以绕过三次握手发送数据，这就减少了握手带来的 1 个 RTT 的时间消耗。



> ## hzh-c
>
> ### 什么是 TCP Fast Open？
>
> #### 1. **常规 TCP 连接的限制**
> - 在常规 TCP 连接中：
>   - **第一次和第二次握手**：不能携带数据。
>   - **第三次握手**：可以携带数据，但需要等待三次握手完成后才能发送应用数据。
> - **问题**：三次握手增加了通信的时延。
>
> ---
>
> #### 2. **TCP Fast Open 的作用**
> - **目标**：绕过三次握手发送数据，减少连接建立的时延。
> - **实现**：通过引入 **Fast Open Cookie**，在后续通信中允许客户端在第一次握手时携带应用数据。
>
> ---
>
> #### 3. **首次通信过程**
> - **流程**：
>   1. 客户端发送 SYN 报文，请求 Fast Open Cookie。
>   2. 服务端生成 Cookie，并在 SYN-ACK 报文中返回给客户端。
>   3. 客户端缓存该 Cookie。
> - **特点**：首次通信仍需完整的三次握手。
>
> ---
>
> #### 4. **后续通信过程**
> - **流程**：
>   1. 客户端发送 SYN 报文，携带应用数据和缓存的 Cookie。
>   2. 服务端校验 Cookie：
>      - **Cookie 有效**：服务端接受应用数据，并在握手完成前发送响应数据。
>      - **Cookie 无效**：服务端丢弃应用数据，仅确认 SYN。
>   3. 客户端发送 ACK 确认，完成握手。
> - **优势**：
>   - 客户端可以在第一次握手时发送应用数据。
>   - 服务端可以在握手完成前发送响应数据，减少 1 个 RTT 的时延。
>
> ---
>
> #### 5. **总结**
> - **TCP Fast Open 的特点**：
>   - 首次通信仍需三次握手。
>   - 后续通信可在第一次握手时携带应用数据，减少 1 个 RTT 的时延。
> - **适用条件**：
>   - 客户端和服务端都需支持 TCP Fast Open 功能。
>   - 客户端需缓存服务端返回的 Fast Open Cookie。
> - **优势**：
>   - 提升连接建立效率，适用于需要频繁建立短连接的场景（如 HTTP/2、微服务通信等）。

> ## hzh-d
>
> ### TCP Fast Open 总结
>
> #### 1. **定义**
> - TCP Fast Open 是一种优化 TCP 连接建立的机制，允许客户端在第一次握手时携带应用数据，从而减少 1 个 RTT 的时延。
>
> ---
>
> #### 2. **工作原理**
> 1. **首次通信**：
>    - 客户端发送 SYN 报文，请求 Fast Open Cookie。
>    - 服务端生成 Cookie，并在 SYN-ACK 报文中返回。
>    - 客户端缓存该 Cookie。
>    - **首次通信仍需完整的三次握手**。
> 2. **后续通信**：
>    - 客户端发送 SYN 报文，携带应用数据和缓存的 Cookie。
>    - 服务端校验 Cookie：
>      - **Cookie 有效**：接受应用数据，并在握手完成前发送响应数据。
>      - **Cookie 无效**：丢弃应用数据，仅确认 SYN。
>    - 客户端发送 ACK 确认，完成握手。
>
> ---
>
> #### 3. **优势**
> - 减少 1 个 RTT 的时延，提升连接建立效率。
> - 适用于需要频繁建立短连接的场景（如 HTTP/2、微服务通信等）。
>
> ---
>
> #### 4. **限制**
> - 首次通信仍需完整的三次握手。
> - 客户端和服务端都需支持 TCP Fast Open 功能。
> - 客户端需缓存服务端返回的 Fast Open Cookie。
>
> ---
>
> #### 5. **总结**
> - TCP Fast Open 是一种通过引入 Cookie 优化连接建立时延的机制。
> - 在后续通信中，客户端可以在第一次握手时携带应用数据，减少时延，提高效率。

## TLSv1.3

> 说完 TCP Fast Open，再来看看 TLSv1.3。

在最开始的时候，我也提到 TLSv1.3 握手过程只需 1-RTT 的时间，它到整个握手过程，如下图：

![图片](https://img-blog.csdnimg.cn/img_convert/1fd5ba4000f82613fdd70cab6da4b9cb.png)

TCP 连接的第三次握手是可以携带数据的，如果客户端在第三次握手发送了 TLSv1.3 第一次握手数据，是不是就表示「*HTTPS 中的 TLS 握手过程可以同时进行三次握手*」？。

不是的，因为服务端只有在收到客户端的 TCP 的第三次握手后，才能和客户端进行后续 TLSv1.3 握手。

TLSv1.3 还有个更厉害到地方在于**会话恢复**机制，在**重连 TLvS1.3 只需要 0-RTT**，用“pre_shared_key”和“early_data”扩展，在 TCP 连接后立即就建立安全连接发送加密消息，过程如下图：

![图片](https://img-blog.csdnimg.cn/img_convert/59539201f006d7dc0a06333617e5ea85.png)

> ## hzh-c
>
> ### TLSv1.3 总结
>
> #### 1. **TLSv1.3 握手过程**
> - **1-RTT 握手**：
>   - TLSv1.3 的握手过程只需 1 个 RTT。
>   - 客户端在 TCP 第三次握手完成后，发送 TLS 第一次握手数据。
>   - 服务端收到后，完成密钥协商并返回加密数据。
> - **注意**：
>   - 虽然 TCP 第三次握手可以携带数据，但 TLS 握手只能在 TCP 连接建立后进行。
>
> ---
>
> #### 2. **TLSv1.3 会话恢复**
> - **0-RTT 握手**：
>   - 使用 `pre_shared_key` 和 `early_data` 扩展。
>   - 客户端在 TCP 连接建立后，立即发送加密数据。
>   - 服务端验证预共享密钥后，直接处理数据。
> - **优势**：
>   - 减少握手时延，适用于会话恢复场景。
>   - 提升性能，尤其在高频短连接场景中。
>
> ---
>
> #### 3. **总结**
> - **1-RTT 握手**：TLSv1.3 默认握手过程，减少时延。
> - **0-RTT 握手**：通过会话恢复机制，进一步优化重连性能。
> - **特点**：
>   - 更快的握手过程。
>   - 更高的安全性和性能，适合现代网络需求。

## TCP Fast Open + TLSv1.3 

在前面我们知道，客户端和服务端同时支持 TCP Fast Open 功能的情况下，**在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据。**

如果 HTTPS 的 TLS 版本是 1.3，那么 TLS 过程只需要 1-RTT。

**因此如果「TCP Fast Open + TLSv1.3」情况下，在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的。**

**如果基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，不仅 TLS 和 TCP 的握手过程是可以同时进行的，而且 HTTP 请求也可以在这期间内一同完成。**

## 总结

最后做个总结。

「HTTPS 是先进行 TCP 三次握手，再进行 TLSv1.2 四次握手」，这句话一点问题都没有，怀疑这句话是错的人，才有问题。

「HTTPS 中的 TLS 握手过程可以同时进行三次握手」，这个场景是可能存在到，但是在没有说任何前提条件，而说这句话就等于耍流氓。需要下面这两个条件同时满足才可以：

- **客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；**
- **客户端和服务端已经完成过一次通信；**

怎么样，那位“面试官”学废了吗？

---

最新的图解文章都在公众号首发，别忘记关注哦！！如果你想加入百人技术交流群，扫码下方二维码回复「加群」。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png)