

# 1.ä¸²æ“ä½œ-é…åˆå›¾

## åŸºæœ¬ç†è®º

**å¤§æ•°æ®é‡,  ä¸ä½¿ç”¨KMP , è€Œæ˜¯  å­—å…¸æ ‘ æˆ–è€… å€’æ’ç´¢å¼•----æœç´¢å¼•æ“**



A B C D E F G ----- ä¸»ä¸²

A B D ---- å­ä¸²/æ¨¡å¼ä¸²



1. å­ä¸²åœ¨ ä¸»ä¸²é‡Œé¢çš„ æœç´¢è¿‡ç¨‹/æ“ä½œ ä¹Ÿç§°ä¸º **æ¨¡å¼åŒ¹é…**





## BFä¸²çš„æœ´ç´ ç®—æ³•

1. BFï¼ˆBrute Forceï¼‰å°±æ˜¯â€œæš´åŠ›æœç´¢â€çš„æ„æ€ã€‚å®ƒçš„åšæ³•éå¸¸ç›´ç™½ï¼š

   **åœ¨ä¸»ä¸²ä¸­ï¼Œä»å¤´åˆ°å°¾ã€ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦åœ°å»è¯•æ¢ï¼Œçœ‹å­ä¸²æ˜¯ä¸æ˜¯ä»è¿™é‡Œå¼€å§‹å®Œå…¨åŒ¹é…ã€‚**

2. å‡è®¾ï¼š

   - ä¸»ä¸² S çš„é•¿åº¦æ˜¯ n
   - æ¨¡å¼ä¸² P çš„é•¿åº¦æ˜¯ m

   æ­¥éª¤å¦‚ä¸‹ï¼š

   1. ä»ä¸»ä¸²çš„ç¬¬ `i=0` ä½å¼€å§‹ï¼Œå°è¯•åŒ¹é…æ¨¡å¼ä¸² Pï¼›
   2. å¦‚æœ**åŒ¹é…å¤±è´¥**ï¼Œå°±æŠŠ **`i` å¾€åç§»åŠ¨**ä¸€ä½(ä¸æ˜¯ç›¸å¯¹äºç°åœ¨içš„ä½ç½®, è€Œæ˜¯ ç›¸æ¯” ä¸Šæ¬¡iå¼€å§‹çš„ä½ç½®)ï¼Œå†**é‡æ–°ä» P çš„ç¬¬ä¸€ä¸ª**å­—ç¬¦å¼€å§‹æ¯”ï¼›
   3. ä¸€ç›´å°è¯•åˆ°ä¸»ä¸²å‰©ä¸‹çš„å­—ç¬¦ä¸è¶³ä»¥åŒ¹é…æ¨¡å¼ä¸²ï¼ˆå³ `i <= n - m`ï¼‰ä¸ºæ­¢ã€‚

```c++
// åˆ†æ”¯é™ç•Œç®—æ³•.cpp : æ­¤æ–‡ä»¶åŒ…å« "main" å‡½æ•°ã€‚ç¨‹åºæ‰§è¡Œå°†åœ¨æ­¤å¤„å¼€å§‹å¹¶ç»“æŸã€‚
//

#include <iostream>
#include <queue>
using namespace std;

// BFç®—æ³•    æ—¶é—´å¤æ‚åº¦ï¼šO(n)*O(m) =  O(n*m)   ç©ºé—´å¤æ‚åº¦ï¼š O(1)
int BF(string s, string t)
{
	int i = 0;
	int j = 0;

	while (i < s.size() && j < t.size())  // O(n)
	{
		if (s[i] == t[j])
		{
			i++;
			j++;
		}
		else
		{
			i = i - j + 1; // å¤ä½iï¼ŒæŒ‡å‘ä¹‹å‰å¼€å§‹åŒ¹é…å­—ç¬¦çš„ä¸‹ä¸€ä¸ªå­—ç¬¦  O(m)
			j = 0;
		}
	}

	if (j == t.size()) // æ‰¾åˆ°äº†
	{
		return i - j;
	}
	else
	{
		return -1;
	}
}

int main()
{
	string s = "abcabdefabcabc"; //"ABCDCABDEFG";
	string t = "abcabc"; //"ABD";

	int pos = BF(s, t);
	cout << pos << endl;
}

```







## KMPç®—æ³•

### åŸºç¡€



1. åˆ©ç”¨â€œå·²åŒ¹é…ä¿¡æ¯â€æ¥é¿å…é‡å¤åŒ¹é…ï¼Œåšåˆ°**ä¸å›é€€ä¸»ä¸²æŒ‡é’ˆ**ã€‚

2. å®ƒçš„æ ¸å¿ƒå°±æ˜¯æå‰ç»™æ¨¡å¼ä¸²å»ºä¸€ä¸ª **â€œéƒ¨åˆ†åŒ¹é…è¡¨â€**ï¼ˆåˆå«ï¼š**next æ•°ç»„**ã€**å‰ç¼€å‡½æ•°**ï¼‰
    è¿™ä¸ªè¡¨å‘Šè¯‰æˆ‘ä»¬ï¼šå¦‚æœå½“å‰å­—ç¬¦ä¸åŒ¹é…äº†ï¼Œæ¨¡å¼ä¸²åº”è¯¥è·³åˆ°å“ªï¼Ÿ

3. ä¸¾ä¸ªä¾‹å­ï¼š   **æ³¨æ„, jä½ç½®çœ‹å‰åç¼€, ä¸åŒ…å«jä½ç½®**

   ğŸ“Œ æ¨¡å¼ä¸²ï¼šP = "ababaca"

   æˆ‘ä»¬è¦æ„å»º `next` è¡¨ï¼ˆä¹Ÿç§° prefix tableï¼‰ï¼Œè¡¨ç¤ºæ¯ä¸ªä½ç½®å‰çš„**æœ€é•¿ç›¸ç­‰å‰åç¼€**çš„é•¿åº¦ã€‚

   | ä½ç½® (j) | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
   | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | å­—ç¬¦     | a    | b    | a    | b    | a    | c    | a    |
   | next[j]  | -1   | 0    | 0    | 1    | 2    | 3    | 0    |

   âœ… ç»“è®ºï¼š

   - æ‰€ä»¥æ­£ç¡®çš„ next è¡¨åº”è¯¥æ˜¯ï¼š
   
   ```python
   next = [-1, 0, 0, 1, 2, 3, 0]
   ```
   


### KMPæ€è€ƒæ ¸å¿ƒ-äº†è§£

1. KMPçš„**æ ¸å¿ƒ æ˜¯   æ€ä¹ˆæ±‚è¿™ä¸ª nextæ•°ç»„**

2. å­ä¸²ç¬¬ 0ä¸ª ä½ç½® next[0]=-1,   è¿™æ˜¯ ç‰¹æ®Šæƒ…å†µ,   å› ä¸º  ç¬¬ä¸€ä¸ª éƒ½ä¸åŒ¹é…äº†,  å°±æŠŠ  **ä¸»å’Œå­ ä¸²  éƒ½åç§»**------å·§å¦™åœ° å¤„ç†

3. nextæ•°ç»„ ç¤ºæ„å›¾:

   ![image-20250408092246365](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/KMP-1.png)

4. åœ¨ ä¸Šé¢çš„ æƒ…å†µä¸‹, next[ j+1 ] å¯ä»¥çœ‹ä¸€ä¸‹,  next[j]  å’Œ next[k]çš„å€¼,  å¦‚æœç›¸ç­‰, é‚£ä¹ˆå°±å¯ä»¥  next[ j+1 ] =  next[ j] +1

5. é‚£ä¸ç›¸ç­‰å‘¢, å°±éœ€è¦ å›é€€ k,  åœ¨ å‰ç¼€é‡Œ, æ‰¾ åˆ° ä¸j ç›¸ç­‰çš„ åœ°æ–¹, è¿™é‡Œå¾ˆå·§å¦™!!

   æ€è€ƒä¸€ä¸‹:

   > 1. ç°åœ¨æ˜¯ æ‰¾ next[j+1]çš„å€¼, è€Œ j ä¸ k ä¸ç›¸ç­‰, ä½†æ˜¯ ä¹‹å‰ å·²ç»ç®—è¿‡ å‰é¢çš„ å…¬å…±å‰åç¼€äº†(`0---k-1,  j-k----j-1`)
   > 2. ç°åœ¨è¦å¾—åˆ° 0----k,  ä¸ j-k-----jçš„å…¬å…±å‰åç¼€
   > 3. j å’Œ k ä¸ç›¸ç­‰, é‚£å®é™…ä¸Š,  å°±æ˜¯ æ‰¾ `0---k-1` å‰ç¼€  å’Œ  `j-k----j`åç¼€ ç›¸ç­‰çš„åœ°æ–¹
   > 4. é‚£é¦–å…ˆæ‰¾åˆ°  `0---k-1` (kå›é€€)é‡Œé¢ ä¸ j ç›¸ç­‰çš„ åœ°æ–¹
   > 5. æ‰¾åˆ°å,è®¾ä¸ºm, å†çœ‹ `0----m`  (ç›¸å½“äº `j-k----j-m+1` )ä¸ `j-m+1----j-1` ,  è€Œç”±äº 0---m----k å·²ç»æ˜¯å·²çŸ¥çš„äº†,  ç›´æ¥ç”¨å³å¯

6. ä¸Šé¢ è¿™ç‚¹ æ€è€ƒ ä¸é‡è¦, **é‡ç‚¹æ˜¯:   j != k,   åˆ™  k = next[k]**



### KMPé‡ç‚¹ ä»£ç :

1.   j != k,   åˆ™  kå›é€€,  k = next[k]

2.  j = k, åˆ™ next[j+1] =  next[j]+1(next[j]=k)--->å¯¹åº”ä»£ç :

   ```c++
   if (-1 == k || str[k] == str[j])
   		{
   			j++;
   			k++;
   			next[j] = k;
   		}
   ```

3. é‡å¤§æ ¸å¿ƒ:    --- å½¢æˆ nextæ•°ç»„

   ```c++
   if (-1 == k || str[k] == str[j])
   		{
   			j++;
   			k++;
   			next[j] = k;
   		}
   		else
   		{
   			k = next[k]; // åškå€¼å›æº¯ï¼Œç»§ç»­æ‰¾æœ€é•¿çš„å…¬å…±å‰åç¼€
   		}
   ```

   



åœ¨BF çš„ åŸºç¡€ä¸Š ,  åŠ å…¥ next æ•°ç»„, iä¸å›é€€,  å†æ”¹æ”¹ç»†èŠ‚



**æ³¨æ„ç»†èŠ‚:   .sizeè¿”å›çš„ size_t æ˜¯æ— ç¬¦å·ç±»å‹, -1è¿›å», ä¼šå˜ä¸º1**



```c++
#include <iostream>
#include <memory>
using namespace std;


// KMPç®—æ³•æ±‚è§£å­ä¸²çš„nextæ•°ç»„
int* getNext(string str)
{
	int* next = new int[str.size()];
	int j = 0; // jç”¨æ¥éå†å­ä¸²
	int k = -1; // kè¡¨ç¤ºå…¬å…±å‰åç¼€çš„é•¿åº¦
	next[j] = k;   

	while (j < str.size() - 1)   // O(m)
	{
		if (-1 == k || str[k] == str[j])
		{
			j++;
			k++;
			next[j] = k;
		}
		else
		{
			k = next[k]; // åškå€¼å›æº¯ï¼Œç»§ç»­æ‰¾æœ€é•¿çš„å…¬å…±å‰åç¼€
		}
	}

	return next;
}

// KMPç®—æ³•  æ—¶é—´å¤æ‚åº¦ï¼šO(n) + O(m) = O(n+m)  ç©ºé—´å¤æ‚åº¦ï¼šO(m)
int KMP(string s, string t)
{
	int i = 0;
	int j = 0;

	// è®¡ç®—ä¸€ä¸ªå­ä¸²å¯¹åº”çš„nextæ•°ç»„
	int* next = getNext(t);
	unique_ptr<int> ptr(next);  // deleteæ“ä½œ

	cout << t << " : ";
	for (int m = 0; m < t.size(); m++)
	{
		cout << next[m] << " ";
	}
	cout << endl;

	// j < t.size() æœ‰é—®é¢˜ï¼ï¼ï¼ j = -1 11111111111  size_t  unsigned int
	int size1 = s.size();
	int size2 = t.size();
	while (i < size1 && j < size2)   // O(n)
	{
		if (-1 == j || s[i] == t[j])
		{
			i++;
			j++;
		}
		else
		{
			// KMPçš„æ ¸å¿ƒæ˜¯ä¸å›é€€iï¼Œåªå›é€€jå€¼ 
			j = next[j];  // å¦‚æœé¦–å­—æ¯åŒ¹é…å¤±è´¥ï¼Œè¿™é‡Œj == -1

			//i = i - j + 1; 
			//j = 0;
		}
	}

	if (j == t.size()) // æ‰¾åˆ°äº†
	{
		return i - j;
	}
	else
	{
		return -1;
	}
}

int main()
{
	string s = "abcabdefababaca"; //"ABCDCABDEFG";
	string t = "ababaca"; //"ABD";

	int pos = KMP(s, t);
	cout << pos << endl;
}
```



### KMPä¼˜åŒ–

1. é’ˆå¯¹ **å­ä¸² æœ‰é‡å¤**,  å¯èƒ½å¯¼è‡´, å›é€€å, ç»§ç»­å›é€€

2. å­ä¸²   a   b  c a b c     :

   next:-1 0 0 0 1 2

   æœ€åä¸€ä¸ªcä¸åŒ¹é… ä¼šå›é€€åˆ° ä¸Šä¸€ä¸ªc, æ­¤æ—¶åˆè¦å›é€€

3. ä¼˜åŒ–ç‚¹:  ä¼˜åŒ–æ‰ ç¬¬ä¸€æ¬¡å›é€€, ç›´æ¥å›é€€ ä¸€æ­¥åˆ°ä½

4. ç¬¬ä¸€æ¬¡ ä¼šå›é€€åˆ° ä¸‹æ ‡ kè¿™ä¸ªä½ç½®,  ä¼˜åŒ–æ‰,  å°±å›é€€åˆ° next[k]çš„ä½ç½®

5. ä¾‹å­:   éƒ½æ˜¯ä¸‹æ ‡

   åˆ° 5 (next--2)ä¸åŒ¹é…, ä¼šå›é€€åˆ° 2(next -- 0), åˆä¸ä¸€æ ·, ä¼šå›é€€åˆ° -1 

   ä¼˜åŒ–å:  åˆ° 5 (next---- 0)ä¸åŒ¹é…, å›é€€åˆ° -1 

æ ¸å¿ƒä»£ç   å°ä¿®æ”¹ä¸€ä¸‹: 

```c++
if (-1 == k || str[k] == str[j])
{
	j++;
	k++;
	if (str[k] == str[j]) // è¿ç»­æœ‰é‡å¤çš„
	{
		// kmpç®—æ³•çš„ä¼˜åŒ–
		next[j] = next[k];
	}
	else
	{
		next[j] = k;
	}
}
else
{
	k = next[k]; // åškå€¼å›æº¯ï¼Œç»§ç»­æ‰¾æœ€é•¿çš„å…¬å…±å‰åç¼€
}
```







# 2.trieå­—å…¸æ ‘(ä¸²æ“ä½œ)

**â€œæ£€ç´¢â€**ï¼ˆre**trie**valï¼‰æ“ä½œçš„ä¸€ç§ç¼©å†™

## åŸºç¡€ç†è®º-pdf

> æœ¬è´¨ æ˜¯ä¸€æ£µ  **å¤šå‰æ ‘**



1. BFä¸KMP æ˜¯ æ¨¡å¼åŒ¹é…, ä¸»ä¸²é‡Œ æœç´¢ å­ä¸²
2. trieå­—å…¸æ ‘---->**ä¸é€‚ç”¨äº æ¨¡å¼åŒ¹é…, é€‚ç”¨äº æœç´¢ä¸², å‰ç¼€æœç´¢ç­‰**
3. ä¸æ­¢æ˜¯ å­—æ¯, è¿˜æœ‰åˆ«çš„ å­—ç¬¦ç±»



## å­—å…¸æ ‘çš„æ€§è´¨-é‡ç‚¹

**åŸºæœ¬æ€§è´¨ï¼š**
1ã€**æ ¹èŠ‚ç‚¹ä¸åŒ…å«å­—ç¬¦**ï¼Œé™¤æ ¹èŠ‚ç‚¹å¤–æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½**åªåŒ…å«ä¸€ä¸ª**å­—ç¬¦
2ã€ä»æ ¹èŠ‚ç‚¹åˆ°æŸä¸€ç»“ç‚¹ï¼Œè·¯å¾„ä¸Šç»è¿‡çš„**å­—ç¬¦è¿æ¥èµ·æ¥**ï¼Œä¸ºè¯¥èŠ‚ç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²
3ã€æ¯ä¸ª**èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹**åŒ…å«çš„å­—ç¬¦**éƒ½ä¸ç›¸åŒ**







**èŠ‚ç‚¹è¿ç”¨**:

å®é™…åº”ç”¨ä¸­, åœ¨ æ¯ä¸ªå•è¯çš„ æœ«å°¾,å³ä¸€æ¡è·¯å¾„ä¸Šçš„ èŠ‚ç‚¹,  åœ¨å¶å­ç»“ç‚¹ å­˜å‚¨  **isend** æ ‡è¯†------->  **hell    hello    éœ€è¦åœ¨ l å¤„æ ‡è¯†, å°±å¯ä»¥å­˜ ä¸¤ä¸ªå•è¯**





è¿˜æœ‰ä¸€ç§å°±æ˜¯   æ ‡è¯† ä¸ªæ•°,  å­˜å‚¨é‡å¤çš„,  å°±åŠ  è¿™ä¸ª å€¼





## ä¾‹å­--çœ‹æ•™å­¦å›¾

## ä¸ºä»€ä¹ˆå­—å…¸æ ‘æœç´¢å¿«

ä¼ ç»Ÿçš„ å¦‚æœç”¨é“¾è¡¨ å­˜å‚¨ æ¯ä¸ªå•è¯,  æ¯ä¸ªå•è¯ éƒ½ä¼š ä»å¤´å¼€å§‹æ¯”è¾ƒ
ä½†æ˜¯ å­—å…¸æ ‘ ä¸ä¼š, å…¬å…±å‰ç¼€, ä»ä¸Šä¸‹, åªæ¯”è¾ƒä¸€æ¬¡

## ä»£ç 

èŠ‚ç‚¹å­©å­ éƒ½æ˜¯ å­—ç¬¦,  æ¯å±‚æ’åº, å¯ä»¥æ›´å¿«çš„ æœç´¢

æ¯ä¸ªèŠ‚ç‚¹:  **char, int freqs(å•è¯æ¬¡æ•°), map<char, èŠ‚ç‚¹*>**   map çº¢é»‘æ ‘ æ’åº---->  map é‡Œ èŠ‚ç‚¹å­˜æŒ‡é’ˆ,  ä¸éœ€è¦å»æ‹·è´ä¸€ä¸ª

map è¿˜æœ‰ä¸€ä¸ªå¥½å¤„, é”®å€¼å­˜å‚¨  char, å¯ä»¥ç®€ä¾¿ æœç´¢ä»£ç 





æ³¨æ„ ç†è§£ å­èŠ‚ç‚¹ éƒ½æ˜¯æ€ä¹ˆå­˜çš„----->  map



### èŠ‚ç‚¹å®šä¹‰



```c++

private:
	// èŠ‚ç‚¹ç±»å‹å®šä¹‰
	struct TrieNode
	{
		TrieNode(char ch, int freqs)
			: ch_(ch)
			, freqs_(freqs)
		{}

		// èŠ‚ç‚¹å­˜å‚¨çš„å­—ç¬¦æ•°æ®
		char ch_;
		// å•è¯çš„æœ«å°¾å­—ç¬¦å­˜å‚¨å•è¯çš„æ•°é‡(é¢‘ç‡)
		int freqs_; 
		// å­˜å‚¨å­©å­èŠ‚ç‚¹å­—ç¬¦æ•°æ®å’ŒèŠ‚ç‚¹æŒ‡é’ˆçš„å¯¹åº”å…³ç³»
		map<char, TrieNode*> nodeMap_; 
	};

private:
	TrieNode* root_; // æŒ‡å‘æ ‘çš„æ ¹èŠ‚ç‚¹
```



### æ„é€ ä¸ææ„

```c++
public:
	TrieTree()
	{
		root_ = new TrieNode('\0', 0);
	}

	~TrieTree()
	{
		queue<TrieNode*> que;
		que.push(root_);

		while (!que.empty())
		{
			TrieNode* front = que.front();
			que.pop();
			// æŠŠå½“å‰èŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹å…¨éƒ¨å…¥é˜Ÿåˆ—
			for (auto& pair : front->nodeMap_)
			{
				que.push(pair.second);
			}
			// é‡Šæ”¾å½“å‰èŠ‚ç‚¹èµ„æº
			delete front;
		}
	}
```

### æ·»åŠ å•è¯

```c++
//æ€æƒ³   hello
1. å¦‚æœå­©å­æœ‰hå­—ç¬¦æ•°æ®çš„èŠ‚ç‚¹ï¼Œåˆ™ç»§ç»­ç§»åŠ¨curæŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼Œéå†ä¸‹ä¸€ä¸ªå­—ç¬¦
2. å¦‚æœæ²¡æœ‰å­©å­èŠ‚ç‚¹ï¼Œåˆ›å»ºç›¸åº”çš„èŠ‚ç‚¹, ç§»åŠ¨curæŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼Œéå†ä¸‹ä¸€ä¸ªå­—ç¬¦


```



```c++
// æ·»åŠ å•è¯--- å·§ç”¨map çš„æŸ¥æ‰¾
void add(const string& word)
{
	TrieNode* cur = root_;

	for (int i = 0; i < word.size(); i++)  // O(m)
	{
		auto childIt = cur->nodeMap_.find(word[i]);
		if (childIt == cur->nodeMap_.end())
		{
			// ç›¸åº”å­—ç¬¦çš„èŠ‚ç‚¹æ²¡æœ‰ï¼Œåˆ›å»ºå®ƒ
			TrieNode* child = new TrieNode(word[i], 0);
			cur->nodeMap_.emplace(word[i], child);
			cur = child;
		}
		else
		{
			// ç›¸åº”çš„å­—ç¬¦èŠ‚ç‚¹å·²ç»å­˜åœ¨ï¼Œç§»åŠ¨curæŒ‡å‘å¯¹åº”çš„å­—ç¬¦èŠ‚ç‚¹
			cur = childIt->second;
		}
	}

	// curæŒ‡å‘äº†wordå•è¯çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
	cur->freqs_++;
}
```

### æŸ¥è¯¢å•è¯-query

```c++
// æŸ¥è¯¢å•è¯
int query(const string& word)
{
	TrieNode* cur = root_;
	for (int i = 0; i < word.size(); i++) // O(m)
	{
		auto childIt = cur->nodeMap_.find(word[i]);
		if (childIt == cur->nodeMap_.end())
		{
			return 0;
		}
		// ç§»åŠ¨curæŒ‡å‘ä¸‹ä¸€ä¸ªå•è¯çš„å­—ç¬¦èŠ‚ç‚¹ä¸Š
		cur = childIt->second;
	}

	return cur->freqs_;
}
```



è¿™ä¸ª `nodeMap_` æ˜¯ä¸€ä¸ª **`map<char, TrieNode\*>`**ï¼Œå‡è®¾æ˜¯ï¼š

- `std::map`ï¼ˆåŸºäºçº¢é»‘æ ‘ï¼‰â†’ æŸ¥æ‰¾æ˜¯ `O(log Ïƒ)`
- `std::unordered_map`ï¼ˆå“ˆå¸Œè¡¨ï¼‰â†’ æŸ¥æ‰¾æ˜¯ `O(1)` å¹³å‡ï¼Œæœ€å `O(Ïƒ)`

å…¶ä¸­ `Ïƒ` æ˜¯å­—ç¬¦é›†å¤§å°ï¼Œæ¯”å¦‚åªå¤„ç†å°å†™å­—æ¯å°±æ˜¯ `26`ã€‚





### åˆ é™¤å•è¯-æ¯”è¾ƒå¤æ‚



ç‰¹æ®Šæƒ…å†µ:

1. åŒ…å«å…³ç³»ï¼š  åˆ é•¿çš„ï¼ˆæƒ…å†µ2ï¼‰ï¼Œ  åˆ å°çš„ï¼ˆæƒ…å†µ1ï¼‰
2. æœ‰å…¬å…±å‰ç¼€ï¼Œ å°±æ˜¯ å­èŠ‚ç‚¹ å¤šï¼ˆæƒ…å†µ3ï¼‰æ€ä¹ˆåˆ 







**vector deque è¿™ä¸¤ä¸ªçš„ erase åªèƒ½ è¿­ä»£å™¨,  list,mapç›¸å…³, setç›¸å…³å¯ä»¥å€¼,ä¹Ÿå¯ä»¥è¿­ä»£å™¨**



å†™ä»£ç ï¼Œ å…ˆè€ƒè™‘ä¸€èˆ¬ï¼Œ åœ¨è€ƒè™‘ ç‰¹æ®Š



é‡ç‚¹åœ¨äº:  **æ‰¾å‡†ä»å“ªé‡Œå¼€å§‹åˆ , åˆ åˆ°å“ªé‡Œ ç»“æŸ---**

```c++
// åˆ é™¤å•è¯
void remove(const string& word)
{
	TrieNode* cur = root_;
	TrieNode* del = root_; // ä»å“ªä¸ªèŠ‚ç‚¹å¼€å§‹åˆ é™¤
	char delch = word[0];

	for (int i = 0; i < word.size(); i++)
	{
		auto childIt = cur->nodeMap_.find(word[i]);
		if (childIt == cur->nodeMap_.end())    
		{
			return;
		}

		// pool  po æƒ…å†µ2å’Œæƒ…å†µ3
		if (cur->freqs_ > 0 || cur->nodeMap_.size() > 1)
		{
			del = cur;
			delch = word[i];
		}

		// curç§»åŠ¨åˆ°å­èŠ‚ç‚¹--- ä¸è¦ç†è§£å­ï¼Œ  è¿™å°±æ˜¯ ç§»åŠ¨åˆ°äº†æŸ¥åˆ°çš„ èŠ‚ç‚¹
		cur = childIt->second;
	}

	// curæŒ‡å‘äº†æœ«å°¾å­—ç¬¦èŠ‚ç‚¹ï¼›wordå•è¯æ˜¯å­˜åœ¨çš„
	if (cur->nodeMap_.empty())
	{
		// å¼€å§‹åˆ é™¤
		TrieNode* child = del->nodeMap_[delch];
		del->nodeMap_.erase(delch);

		// é‡Šæ”¾ç›¸åº”çš„èŠ‚ç‚¹å†…å­˜ ---  æ¥è‡ªäºææ„, ç›´æ¥å¤åˆ¶è¿‡æ¥çš„
		queue<TrieNode*> que;
		que.push(child);  // ä»å“ªé‡Œå¼€å§‹é‡Šæ”¾

		while (!que.empty())
		{
			TrieNode* front = que.front();
			que.pop();
			// æŠŠå½“å‰èŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹å…¨éƒ¨å…¥é˜Ÿåˆ—
			for (auto& pair : front->nodeMap_)
			{
				que.push(pair.second);
			}
			// é‡Šæ”¾å½“å‰èŠ‚ç‚¹èµ„æº
			delete front;
		}
	}
	else
	{
		// æƒ…å†µ1
		// å½“å‰å•è¯æœ«å°¾å­—ç¬¦åé¢è¿˜æœ‰å­—ç¬¦èŠ‚ç‚¹ï¼Œä¸åšä»»ä½•èŠ‚ç‚¹åˆ é™¤æ“ä½œ
		cur->freqs_ = 0;
	}
}
```



 

## åº”ç”¨åœºæ™¯

![image-20250410171825883](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å­—å…¸æ ‘-1.png)

### ä¸²æ’åºæ–¹é¢çš„åº”ç”¨

é¢˜ç›®è¦æ±‚å‰åºéå†äº†----å­—å…¸æœ¬èº« å·²ç»æ˜¯ å­—å…¸åºæ’åºäº†

**æ€æƒ³:**

```c++
éå†åˆ° freqs å‚æ•° >0,  è¡¨ç¤º æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ å•è¯

```







word æ˜¯ ä¸€ä¸ª å±€éƒ¨å˜é‡,  æ‰€ä»¥ å›æº¯å‰wordæ”¹å˜, ä¸å½±å“å›æº¯å, 

```c++
	// å‰åºéå†å­—å…¸æ ‘
	void preOrder()
	{
		string word;
		vector<string> wordList;
		preOrder(root_, word, wordList);
		for (auto word : wordList)
		{
			cout << word << endl;
		}
		cout << endl;
	}


void preOrder(TrieNode* cur, string word, vector<string> &wordlist)
{
	// å‰åºéå† VLR
	if (cur != root_)   // V
	{
		word.push_back(cur->ch_);
		if (cur->freqs_ > 0)
		{
			// å·²ç»éå†åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„å•è¯
			wordlist.emplace_back(word);
		}
	}

	// é€’å½’å¤„ç†å­©å­èŠ‚ç‚¹
	for (auto pair : cur->nodeMap_)
	{
		preOrder(pair.second, word, wordlist);
	}
}
```





### ä¸²çš„å‰ç¼€æœç´¢

å‰åºéå† é‚£é‡Œ æœ‰ä¸ªç»†èŠ‚, ç”±äº ä¹‹å‰å†™çš„ å‰åºéå† ä¼ å…¥çš„ word  æ˜¯å½“å‰èŠ‚ç‚¹çš„ å‰ä¸€ä¸ªèŠ‚ç‚¹,  æ‰€ä»¥ è¿™é‡Œ ä¸èƒ½ä¼  å‰ç¼€çš„æœ€åä¸€ä¸ª å­—ç¬¦,  ä¼ è¿›å»ä¼š åœ¨ wordé‡ŒåŠ è¿›å»,  å¯¼è‡´é‡å¤äº†

å› æ­¤ åœ¨ç»„åˆ å•è¯æ—¶,  ä¼ å…¥çš„ å‰ç¼€ è¦å°‘ä¸€ä½



æ—¶é—´æœ€é•¿ ä¸º å•è¯é•¿åº¦



**è¿™ä¸ªå°±æ˜¯  ç½‘é¡µæœç´¢æ¡†, æ‰“å‡ºä¸€ä¸¤ä¸ªå­—, ä¼šå‡ºæ¥å€™é€‰è¯çš„ æ ¸å¿ƒ, è¿˜æœ‰ä»£ç  å‡½æ•°åè‡ªåŠ¨è¡¥å……**







```c++
// ä¸²çš„å‰ç¼€æœç´¢
vector<string> queryPrefix(const string& prefix)
{
	TrieNode* cur = root_;
	for (int i = 0; i < prefix.size(); i++)
	{
		auto childIt = cur->nodeMap_.find(prefix[i]);
		if (childIt == cur->nodeMap_.end())
		{
			// vector<string> vec{};
			return {};
		}
		cur = childIt->second;
	}

	// curå°±æŒ‡å‘äº†å‰ç¼€çš„æœ€åä¸€ä¸ªå­—ç¬¦èŠ‚ç‚¹äº†
	vector<string> wordlist;
	preOrder(cur, prefix.substr(0, prefix.size()-1), wordlist);
	return wordlist;
}


```











# 3.sundayç®—æ³•--è‡ªå·±è¡¥å……



# 4.è·³è·ƒè¡¨-SkipList

## åŸºç¡€ç†è®º-pdf



è·³è·ƒè¡¨ï¼ˆSkip Listï¼‰æ˜¯ä¸€ç§**éšæœºåŒ–æ•°æ®ç»“æ„**ï¼Œç”¨æ¥ä»£æ›¿å¹³è¡¡æ ‘ï¼ˆå¦‚çº¢é»‘æ ‘ï¼‰å®ç°**æœ‰åºé›†åˆçš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œ**ã€‚

 **åŸºæœ¬æ€æƒ³**

è·³è·ƒè¡¨é€šè¿‡åœ¨é“¾è¡¨ä¸Šå¢åŠ â€œç´¢å¼•å±‚â€ï¼Œå®ç°**å¤šçº§é“¾è¡¨**ï¼Œä»è€ŒåŠ å¿«æŸ¥æ‰¾æ•ˆç‡ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º **O(log n)**ã€‚



**ä¼˜ç‚¹**

- å®ç°ç®€å•ï¼Œ**æ¯”å¹³è¡¡æ ‘æ›´å®¹æ˜“ç¼–ç **ï¼›
- æ’å…¥å’Œåˆ é™¤**ä¸éœ€è¦å¤æ‚çš„æ—‹è½¬**æ“ä½œï¼›
- æ›´å®¹æ˜“è¿›è¡Œ**å¹¶å‘**å¤„ç†ï¼›
- Redis çš„ `SortedSet`ï¼ˆæœ‰åºé›†åˆï¼‰åº•å±‚å°±æ˜¯è·³è·ƒè¡¨ + å“ˆå¸Œè¡¨ã€‚











1. å‰æ:  æœ‰åºé“¾è¡¨
2. è·³è·ƒè¡¨, å®é™…æ˜¯  å¯ä»¥ç›¸å½“äºé“¾è¡¨çš„ äºŒåˆ†æŸ¥æ‰¾
3. åœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œè·³è·ƒè¡¨åŠ é”çš„ç²’åº¦ä¼šæ›´å°ä¸€äº›ï¼Œå¹¶å‘èƒ½åŠ›æ›´å¼º---**æ¯”çº¢é»‘æ ‘å¥½**
4. ç›¸æ¯”äº çº¢é»‘æ ‘,  æ˜¯ç”¨ ç©ºé—´ æ¢æ—¶é—´
5. è·³è·ƒè¡¨çš„**å¢åŠ ã€åˆ é™¤ã€æŸ¥è¯¢**æ“ä½œæ—¶é—´å¤æ‚åº¦å’Œçº¢é»‘æ ‘ä¸€æ ·ï¼Œä¹Ÿæ˜¯**O(logn)**



## ä»£ç 

**æ³¨æ„ æ´¾ç”Ÿç±»(HeadNode) è½¬æ¢ä¸º åŸºç±»< Node>**

### èŠ‚ç‚¹å®šä¹‰

åªæœ‰å¤´ç»“ç‚¹  å­˜å‚¨ å±‚æ•°

```c++
private:
	// æ™®é€šèŠ‚ç‚¹ç±»å‹
	struct Node
	{
		Node(int data = int())
			: data_(data)
			, next_(nullptr)
			, down_(nullptr)
		{}
		int data_;     // æ•°æ®åŸŸ
		Node* next_;   // æŒ‡å‘åŒä¸€å±‚åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸ
		Node* down_;   // æŒ‡å‘ä¸‹ä¸€å±‚ç›¸åŒèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸ
	};

	// è·³è·ƒè¡¨çš„å¤´èŠ‚ç‚¹ç±»å‹
	struct HeadNode : public Node
	{
		HeadNode(int level)
			: level_(level)
		{}
		int level_; // è·³è·ƒè¡¨çš„å±‚æ•°
	};

private:
	HeadNode* head_;   // æŒ‡å‘è·³è¡¨æœ€ä¸Šé¢ä¸€å±‚é“¾è¡¨çš„å¤´èŠ‚ç‚¹


```





### æ„é€ 

```c++
public:
	SkipList()
	{
		head_ = new HeadNode(1);
	}
```





### æœç´¢æŸ¥æ‰¾

```c++
// æœç´¢æ•°æ®
bool find(int data)
{
	Node* pre = head_;
	Node* cur = pre->next_;

	for (;;)
	{
		if (cur != nullptr)
		{
			if (cur->data_ < data)
			{
				pre = cur;
				cur = cur->next_;
				continue;
			}
			else if (cur->data_ == data)
			{
				return true;
			}
		}

		// cur == nullpträº†
		if (pre->down_ == nullptr)
		{
			// preå’Œcurå·²ç»éå†åˆ°ç¬¬ä¸€å±‚çš„æœ«å°¾äº†
			break;
		}

		pre = pre->down_;   // åªæœ‰å¤§äºäº†, æ‰ä¼šåˆ°è¿™é‡Œ,å¯ä»¥è¿›å…¥ä¸‹ä¸€å±‚
		cur = pre->next_;
	}
	return false;
}
```





### ææ„

ä¸€å±‚ä¸€å±‚åˆ ,  å…ˆä¸è¦åŠ¨å¤´ç»“ç‚¹, æŠŠå¤´ç»“ç‚¹ åé¢çš„ åˆ äº†, æœ€ååˆ é™¤ å¤´ç»“ç‚¹,  åˆ é™¤å‰ , ä¿å­˜ ä¸‹ä¸€å±‚çš„ å¤´ç»“ç‚¹







```c++
~SkipList()
{
	int level = head_->level_;
	for (int i = 0; i < level; i++)
	{
		Node* cur = head_->next_;
		while (cur != nullptr)
		{
			Node* tmp = cur->next_;
			delete cur;
			cur = tmp;
		}
		cur = head_;
		head_ = static_cast<HeadNode*>(head_->down_);
		delete cur;
	}
}
```





### æ·»åŠ æ•°æ®

**æ’å…¥æ€æƒ³:**

1. æ•°æ®å­˜åœ¨ åˆ™ä¸æ·»åŠ 
2. æ•°æ®ä¸å­˜åœ¨:
   1. å…ˆå®šå¥½è¦ æ’å…¥çš„ ç¬¬ä¸€ä¸ªå±‚, ä½¿ç”¨éšæœºé€‰æ‹©
   2. å¦‚æœå¤§äºå½“å‰å±‚, ä»…éœ€è¦æ–°å»ºä¸€å±‚, æ–°å»ºå¤´ç»“ç‚¹, 
   3. ç”±äºä»é€‰æ‹©çš„ å±‚å¼€å§‹, åç»­å±‚ éƒ½éœ€è¦ åŠ è¿™ä¸ªå…ƒç´ , å› æ­¤ **ä½¿ç”¨æ•°ç»„ å­˜å‚¨ å¤šä¸ªå±‚çš„ èŠ‚ç‚¹æŒ‡é’ˆ**---->  å°±æ˜¯ å…ˆç”Ÿæˆ æ•°æ®ä¸€æ ·, æŒ‡é’ˆä¸ä¸€æ ·çš„ å¤šä¸ªèŠ‚ç‚¹, ç„¶å ä¸€ä¸ªä¸ªé€‰å‡ºæ¥ æ’å…¥å³å¯



```c++
// æ·»åŠ æ•°æ®
void add(int data)
{
	// å…ˆæŸ¥æ‰¾æ•°æ®æ˜¯å¦å­˜åœ¨
	if (find(data))
		return;

	// æŠ›ç¡¬å¸ï¼Œdataæ•°æ®æ·»åŠ å‡ å±‚
	int level = getLevel();
	if (level > head_->level_)
	{
		// levelè¿‡å¤§æ—¶ï¼ŒSkipListåªå¢é•¿ä¸€å±‚
		level = head_->level_ + 1;
		HeadNode* hnode = new HeadNode(level);
		hnode->down_ = head_;
		head_ = hnode;
	}

	// å…ˆåˆ›å»ºlevelå±‚çš„dataèŠ‚ç‚¹(levelé•¿åº¦çš„æ•°ç»„)ï¼Œä¿®æ”¹downæŒ‡é’ˆåŸŸ
	Node** nodeList = new Node * [level];

	// è¿™ä¸ªæ•°ç»„ ä¸‹æ ‡å’Œ è·³è·ƒè¡¨çš„ å±‚ æ˜¯åè¿‡æ¥çš„
	// åªæœ‰
	for (int i = level - 1; i >= 0; i--)
	{
		nodeList[i] = new Node(data);

		// ä¸‹æ ‡æœ€åä¸€ä¸ª, åœ¨ å±‚æ•°é‡Œæ˜¯ ç¬¬ä¸€å±‚
		if (i < level - 1)
		{
			// ä¸Šé¢èŠ‚ç‚¹çš„downæŒ‡é’ˆåŸŸï¼Œå­˜å‚¨ä¸‹é¢èŠ‚ç‚¹çš„åœ°å€
			nodeList[i]->down_ = nodeList[i + 1];
		}
	}

	Node* head = head_;
	for (int i = head_->level_; i > level; i--)
	{
		head = head->down_;
	}

	// headå°±æŒ‡å‘äº†è¦æ’å…¥èŠ‚ç‚¹çš„é“¾è¡¨äº†

	Node* pre = head;   // ä» é«˜å±‚å¼€å§‹æ’å…¥
	Node* cur = pre->next_;

	for (int i = 0; i < level; i++)  //è¿™ä¸ªiæ˜¯æ•°ç»„ä¸‹æ ‡, ä¸è¦ç†è§£æˆå±‚æ•°, å’Œå±‚æ•°ç›¸å
	{
		while (cur != nullptr && cur->data_ < data)
		{
			pre = cur;
			cur = cur->next_;
		}

		// æ–°èŠ‚ç‚¹æ’å…¥åˆ°preå’Œcurçš„ä¸­é—´
		nodeList[i]->next_ = cur;
		pre->next_ = nodeList[i];

		pre = pre->down_; // è¿›å…¥ä¸‹ä¸€å±‚(è·³è·ƒè¡¨çš„æ€§è´¨, å¯ä»¥ç›´æ¥è¿›å…¥ä¸‹ä¸€å±‚, ä¸éœ€è¦å†ä»å¤´ç»“ç‚¹æŸ¥æ‰¾)
		if (pre != nullptr)
			cur = pre->next_;
	}

	delete[]nodeList; // é‡Šæ”¾ä¸´æ—¶çš„ ä¸€ç»´æ•°ç»„, ä¸é‡Šæ”¾ å†…éƒ¨
	nodeList = nullptr;
}
```





```c++
private:
	int getLevel() const
	{
		int level = 1;
		while (rand() % 2 == 1)   // éœ€è¦æ­é… srand
			level++;
		return level;
	}
```



### æ‰“å°

```c++
// æ‰“å°
void show() const
{
	Node* head = head_;
	while (head != nullptr)
	{
		Node* cur = head->next_;
		while (cur != nullptr)
		{
			cout << cur->data_ << " ";
			cur = cur->next_;
		}
		cout << endl;
		head = head->down_;
	}
	cout << endl;
}
```





### åˆ é™¤--æ¯”çº¢é»‘æ ‘å¥½å¤ªå¤š



ä»æœ€é«˜å±‚å¼€å§‹

æ‰¾åˆ°å°±åˆ é™¤, æ²¡æ‰¾åˆ°å°±å»ä¸‹ä¸€å±‚, 

ç¬¬ä¸€å±‚  æ²¡æœ‰ å°± break



å¦‚æœåªæœ‰ä¸€å±‚, åªæœ‰åˆ é™¤çš„ é‚£ä¸ªèŠ‚ç‚¹,  è¯¥å±‚åˆ™éœ€è¦å…¨éƒ¨åˆ é™¤







```c++
// åˆ é™¤æ•°æ®
void remove(int data)
{
	Node* pre = head_;
	Node* cur = pre->next_;

	for (;;)
	{
		if (cur != nullptr)
		{
			if (cur->data_ < data)
			{
				pre = cur;
				cur = cur->next_;
				continue;
			}
			else if (cur->data_ == data)
			{
				// åˆ é™¤curæŒ‡å‘çš„èŠ‚ç‚¹
				pre->next_ = cur->next_;
				delete cur;
			}
		}

		if (pre->down_ == nullptr)
		{
			break;
		}

		pre = pre->down_;
		// cur == nullptr å½“å‰å±‚æ²¡æœ‰dataèŠ‚ç‚¹
		if (head_->next_ == nullptr)
		{
			delete head_;
			head_ = static_cast<HeadNode*>(pre);
		}
		cur = pre->next_;
	}
}
```





# 5.å€’æ’ç´¢å¼•-pdf

## åŸºç¡€ç†è®º

1.  å¸¸ç”¨äº **æœç´¢å¼•æ“**ä¸­
2. åè¯æœ¯è¯­-----pdf çœ‹çœ‹





## å€’æ’ç´¢å¼•åº”ç”¨åœºæ™¯--æ•™å­¦å›¾ç‰‡

1. æµè§ˆå™¨çš„ æœç´¢å¼•æ“

   ![image-20250414165249217](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å€’æ’ç´¢å¼•-1.png)

2. æœç´¢æœåŠ¡ - ç”µå•†---æ•°æ®æµ·é‡

   ä¸ä½¿ç”¨   Mysql

   è€Œæ˜¯ä½¿ç”¨ å…¨æ–‡æœç´¢å¼•æ“----**solr, elasticsearch**--ä½¿ç”¨äº† å€’æ’ç´¢å¼•

   ![image-20250414165413453](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å€’æ’ç´¢å¼•-2.png)

3. **æ­£æ’ç´¢å¼•** å’Œ **å€’æ’ç´¢å¼•**   ----->   å°±æ˜¯  **è¡Œåˆ—ç›¸å**

   æ­£æ’ç´¢å¼•ï¼šä»â€œæ–‡æ¡£â€å‡ºå‘ï¼Œè®°å½•æœ‰å“ªäº›è¯ã€‚
    å€’æ’ç´¢å¼•ï¼šä»â€œè¯â€å‡ºå‘ï¼Œè®°å½•å‡ºç°åœ¨å“ªäº›æ–‡æ¡£ä¸­ã€‚

4. ä½ æƒ³æ‰¾æ‰€æœ‰åŒ…å« "å¤©æ°”" çš„æ–‡ç« ã€‚

   - **æ­£æ’ç´¢å¼•åšæ³•**ï¼šéå†æ¯ä¸ªæ–‡æ¡£ï¼Œçœ‹è¯è¡¨é‡Œæœ‰æ²¡æœ‰â€œå¤©æ°”â€ã€‚ï¼ˆæ•ˆç‡ä½ï¼‰
   - **å€’æ’ç´¢å¼•åšæ³•**ï¼šç›´æ¥æŸ¥â€œå¤©æ°”â€å¯¹åº”çš„æ–‡æ¡£åˆ—è¡¨å³å¯ï¼ï¼ˆæ•ˆç‡é«˜ï¼‰

5. å€’æ’ç´¢å¼•  å¯ä»¥è®°å½• é¢å¤–çš„ä¿¡æ¯

   1. æ‰“åˆ†,  å‡ºç°æˆ–è€…è®¿é—®çš„è¶Šå¤š, åˆ†è¶Šé«˜
   2. ä½ç½®, åœ¨æ–‡æ¡£ä¸­çš„ä½ç½®,  ç¬¬å‡ ä¸ªå•è¯
   3. åœ¨ä½ç½®çš„  ç¬¬å‡ è¡Œ



![image-20250414172154489](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å€’æ’ç´¢å¼•-3.png)



## å€’æ’ç´¢å¼•ç»“æ„

1. è¯å…¸:   å•è¯
2. å€’æ’é¡¹: å•è¯æ‰€åœ¨æŸä¸ªæ–‡ä»¶çš„ æ–‡æ¡£çš„ä¿¡æ¯
3. å€’æ’åˆ—è¡¨: ç”±å¾ˆå¤š å€’æ’é¡¹ç»„æˆ----æ¯ä¸ªå•è¯ éƒ½æœ‰ä¸€ä¸ª å€’æ’åˆ—è¡¨
4. å€’æ’æ–‡ä»¶: æ‰€æœ‰å€’æ’åˆ—è¡¨çš„ é›†åˆ
5. **å€’æ’ç´¢å¼• = è¯å…¸ + å€’æ’æ–‡ä»¶**

æœ¬æ–‡æ‰€è®²çš„ éƒ½æ˜¯ **å†…å­˜ç´¢å¼•** çš„ å€’æ’ç´¢å¼•çš„å­˜å‚¨





![image-20250414173040574](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å€’æ’ç´¢å¼•-4.png)





![image-20250414174349729](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å€’æ’ç´¢å¼•-5.png)





## å®ç°æœ¬åœ°æœç´¢å¼•æ“ä»£ç 

æ•´ä½“å†™ä»£ç  æ—¶, å…ˆæŠŠ  å¤§çš„ æˆå‘˜å˜é‡å®šä¹‰å¥½(privateé‡Œçš„)

### æ„å»ºå€’æ’é¡¹-å›¾é‡Œçš„p

åœ¨æ¯ä¸ª **å‡ºç°çš„æ–‡æ¡£**é‡Œ æ·»åŠ äº† **å‡ºç°æ¬¡æ•°**, **å‡ºç°ä½ç½®**



ä½¿ç”¨list  å­˜å‚¨ å‡ºç°çš„ æ‰€æœ‰ä½ç½®



```c++
// å€’æ’é¡¹
struct InvertTerm
{
	InvertTerm(string docid, int freqs, int location)
		: docid_(docid)
		, freqs_(freqs)
	{
		locations_.emplace_back(location);
	}
	bool operator==(const InvertTerm& term) const
	{
		return docid_ == term.docid_;
	}
	bool operator<(const InvertTerm& term) const
	{
		return docid_ < term.docid_;
	}
	string docid_;        // å•è¯æ‰€åœ¨çš„æ–‡æ¡£
	int freqs_;           // å•è¯å‡ºç°çš„æ¬¡æ•°
	list<int> locations_; // å•è¯å‡ºç°çš„ä½ç½®
};
```



### æ„å»ºå€’æ’åˆ—è¡¨-å›¾é‡Œçš„p1,p2..

å€’æ’åˆ—è¡¨ æ˜¯ **æ‰€æœ‰å€’æ’é¡¹çš„é›†åˆ**,   ä½¿ç”¨  list å­˜å‚¨ æ¯ä¸€ä¸ª å€’æ’é¡¹



å€’æ’åˆ—è¡¨é‡Œ,  éœ€è¦å®ç°:
**1. æ·»åŠ å€’æ’é¡¹**

**2. è·å¾—  å€’æ’åˆ—è¡¨**





```c++
// å€’æ’åˆ—è¡¨
class InvertList
{
public:
	// æ·»åŠ å€’æ’é¡¹   #2
	void addTerm(string docid, int location)
	{
		for (auto& term : termList_)
		{
			if (term.docid_ == docid) // docidå·²ç»åˆ›å»ºäº†
			{
				term.freqs_++;
				term.locations_.emplace_back(location);
				return; //æœ¬æ¬¡æ·»åŠ å®Œæ¯•
			}
		}

		// ç¬¬ä¸€æ¬¡åˆ›å»ºdocidæ–‡æ¡£çš„å€’æ’é¡¹
		termList_.emplace_back(docid, 1, location);
	}

	// è·å–å€’æ’åˆ—è¡¨å†…å®¹
	const list<InvertTerm>& getInvertList() const
	{
		return termList_;
	}
    
private:     //#1
	list<InvertTerm> termList_;  // å­˜å‚¨å½“å‰å€’æ’åˆ—è¡¨æ‰€æœ‰çš„å€’æ’é¡¹
};
```





### æ„å»ºå€’æ’ç´¢å¼•



**å€’æ’ç´¢å¼• = è¯å…¸ + å€’æ’æ–‡ä»¶**---ä½¿ç”¨  map  å­˜å‚¨  é”®å€¼å¯¹



æ¯ä¸ªmapé‡Œ,  <å•è¯, å€’æ’åˆ—è¡¨>



```c++
unordered_map<string, InvertList> invertMap_; // è¯å…¸+å€’æ’åˆ—è¡¨ 


```





å¸Œæœ›ç”¨æˆ· ä¼ å…¥ä¸€ä¸ª æ–‡ä»¶å¤¹è·¯å¾„, åœ¨è¿™ä¸ªæ–‡ä»¶å¤¹é‡Œ æœç´¢,  å› æ­¤ å€’æ’ç´¢å¼• åŠ å…¥ä¸€ä¸ª å¯¹åº”æ¥å£

```c++
private:
	list<string> fileList_;  // å­˜å‚¨æ‰€æœ‰éœ€è¦å»ºç«‹å€’æ’çš„æ–‡ä»¶


public:
	// è®¾ç½®æ–‡æ¡£æœç´¢çš„æ ¹è·¯å¾„
void setSearchPath(string path)
{
	cout << "æœç´¢æ–‡ä»¶...";
	getAllFile(path.c_str());
	cout << "å®Œæˆ!" << endl;

	cout << "å¼€å§‹åˆ›å»ºå€’æ’ç´¢å¼•";
	createInvertIndex();
	cout << "å®Œæˆ!" << endl;
}
```



ç”±äº è¿™æ˜¯ winé‡Œé¢çš„ ç¯å¢ƒ, javaä»€ä¹ˆçš„ æä¾›äº† æœç´¢æ–‡ä»¶ å‡½æ•°

ä½†æ˜¯ c++ æ²¡æœ‰, è¿˜æ˜¯éœ€è¦ è°ƒç”¨ç³»ç»Ÿ api----è€å¸ˆç›´æ¥ç»™çš„å®Œæ•´ä»£ç 

å¿…é¡»åŠ  UNICODE :   winé‡Œ éƒ½æ˜¯ å®½å­—èŠ‚å­—ç¬¦,  æœ¬åœ°ä¼ çš„ éƒ½æ˜¯å•å­—èŠ‚å­—ç¬¦



è¿™æ®µæ˜¯ winçš„ ç³»ç»Ÿ api,  å…ˆä¸äº†è§£



```c++
#undef UNICODE   
#include <Windows.h>

private:
// é€’å½’æ‰«æè·¯å¾„ä¸‹é¢æ‰€æœ‰çš„æ–‡ä»¶
int getAllFile(const char* Path)
{
	char szFind[MAX_PATH];
	WIN32_FIND_DATA FindFileData;
	strcpy(szFind, Path);
	strcat(szFind, "\\*.*");
	HANDLE hFind = FindFirstFile(szFind, &FindFileData);
	if (INVALID_HANDLE_VALUE == hFind)
		return -1;

	do
	{
		if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			if (strcmp(FindFileData.cFileName, ".") != 0 && strcmp(FindFileData.cFileName, "..") != 0)
			{
				//å‘ç°å­ç›®å½•ï¼Œé€’å½’ä¹‹
				char szFile[MAX_PATH] = { 0 };
				strcpy(szFile, Path);
				strcat(szFile, "\\");
				strcat(szFile, FindFileData.cFileName);
				getAllFile(szFile);
			}
		}
		else
		{
			//æ‰¾åˆ°æ–‡ä»¶ï¼Œå¤„ç†ä¹‹
			string fileName(FindFileData.cFileName);
			int pos = fileName.find(suffix_);  // abcd.cpp   pos:4 +4 
			if (pos != string::npos && pos + suffix_.size() == fileName.size())
			{
				// std::cout << Path << "\\" << FindFileData.cFileName << std::endl;
				string filePath(Path);
				filePath.append("\\");
				filePath.append(fileName);
				fileList_.emplace_back(filePath);
			}
		}
	} while (FindNextFile(hFind, &FindFileData));

	FindClose(hFind);

	return 0;
}
```





### `npos` æ˜¯ä»€ä¹ˆï¼Ÿ

string.find("")   --->  æ‰¾ä¸åˆ°, å°±è¿”å›  string::npos  è¿™ä¸ªé™æ€ å¸¸é‡

- `npos` æ˜¯ `string` ç±»çš„ä¸€ä¸ª**é™æ€å¸¸é‡**ï¼Œè¡¨ç¤ºä¸€ä¸ªæ— æ•ˆçš„ä½ç½®ã€‚
- æœ¬è´¨ä¸Šæ˜¯ä¸ªè¶…å¤§çš„æ— ç¬¦å·æ•°ï¼ˆé€šå¸¸æ˜¯ `-1` è½¬æˆ `size_t`ï¼‰ã€‚
- æ‰€ä»¥ä½ æ°¸è¿œä¸ä¼šåœ¨æœ‰æ•ˆå­—ç¬¦ä¸²ä¸­è§åˆ° `npos` æ˜¯æ­£å¸¸çš„ç´¢å¼•ã€‚



### åˆ›å»ºå€’æ’ç´¢å¼•ç»“æ„--æ ¸å¿ƒ

æŒ‰ç…§ç©ºæ ¼åˆ†è¯:  split(c/c++é‡Œæ²¡æœ‰ è¿™ä¸ªæ¥å£) ,  strtok(cçš„, ä½†æ˜¯éœ€è¦ å¤šæ¬¡è°ƒç”¨)





```c++
private:
	// åˆ›å»ºå€’æ’ç´¢å¼•ç»“æ„
	void createInvertIndex()
	{
		for (string& filePath : fileList_)
		{
			cout << ".";
			FILE* pf = fopen(filePath.c_str(), "r");
			if (pf == nullptr)
			{
				cerr << filePath << " ......æ‰“å¼€å¤±è´¥ï¼" << endl;
				continue;
			}

			// æŒ‰è¡Œè¯»å–æ–‡ä»¶é‡Œé¢çš„å†…å®¹ï¼ŒæŒ‰ç…§" "ç©ºæ ¼è¿›è¡Œåˆ†è¯
			vector<string> wordList;
			int location = 0; // ä½ç½®ä¿¡æ¯
			const int LINE_SIZE = 2048;
			char line[LINE_SIZE] = { 0 };

			while (!feof(pf))  // feof(pf) è¡¨ç¤ºæ–‡ä»¶æ˜¯å¦è¯»å®Œ
			{
				// è¯»ä¸€è¡Œæ–‡ä»¶å†…å®¹
				fgets(line, LINE_SIZE, pf);

				// æŒ‰ç…§" "ç©ºæ ¼è¿›è¡Œåˆ†è¯ split   strtok
				char* word = strtok(line, " ");
				while (word != nullptr)
				{
					// è¿‡æ»¤ä¸€ä¸‹wordå‰åçš„å¤šä½™çš„ç©ºæ ¼  \t  \n
					word = trim(word);
					if (strlen(word) > 0)
					{
						wordList.emplace_back(word);
					}
					word = strtok(nullptr, " ");
				}

				// å¼€å§‹ç»™wordListé‡Œé¢çš„å•è¯åˆ›å»ºæˆ–è€…ä¿®æ”¹å€’æ’åˆ—è¡¨
				for (string& w : wordList)
				{
					location++;
					auto it = invertMap_.find(w);   //map
					if (it == invertMap_.end())
					{
						// æ–°å»ºwå•è¯çš„å€’æ’åˆ—è¡¨
						InvertList list;
						list.addTerm(filePath, location);
						invertMap_.emplace(w, list); // insert éœ€è¦{}
					}
					else
					{
						it->second.addTerm(filePath, location);
					}
				}
			}

			fclose(pf);
		}
	}
```





```c++
// å»æ‰åˆ†è¯å  å•è¯å‰åå¤šä½™çš„å­—ç¬¦ \t\t\tsdfads\t\n
char* trim(char* word)
{
	int i = 0;
	while (word[i] != '\0')
	{
		if (word[i] == ' ' || word[i] == '\t' || word[i] == '\n')
		{
			i++;
		}
		else
		{
			break;
		}
	}

	int j = i;
	while (word[j] != '\0')
	{
		if (word[j] == ' ' || word[j] == '\t' || word[j] == '\n')
		{
			break;
		}
		j++;
	}
	word[j] = '\0';

	return word + i;
}
```







### æŸ¥è¯¢æ¥å£

ä¼ å…¥ä¸€ä¸ª å¥å­, æŸ¥è¯¢ 



æ³¨æ„é‡Œé¢ æœ‰ä¸€ä¸ª å®¢æˆ·ç«¯ æ‹¦æˆªå°±å¯ä»¥å®ç°çš„ 

æŸ¥è¯¢å•ä¸ªå•è¯çš„ ç‰ˆæœ¬:



```c++
	// æŸ¥è¯¢æ¥å£
	void query(string phrase)
	{
		// å…ˆè¿›è¡Œå¥å­åˆ†è¯æ“ä½œ
		vector<string> wordList;
		char* word = strtok(const_cast<char*>(phrase.c_str()), " ");
		while (word != nullptr)
		{
			word = trim(word);
			if (strlen(word) > 0)
			{
				wordList.emplace_back(word);
			}
			word = strtok(nullptr, " ");
		}

		if (wordList.empty())   // è¿™æ®µåœ¨ å®é™… åšäº§å“æ—¶,  åœ¨å®¢æˆ·ç«¯å°±å¤„ç†æ‰,  å®¢æˆ·ç«¯å¤„  å‘ç° ç”¨æˆ·æ²¡æœ‰å¡«å†™, å°±æ‹¦æˆªäº†
			return;
		if (wordList.size() == 1)
		{
			auto it = invertMap_.find(wordList[0]);
			if (it == invertMap_.end())
			{
				cout << "æœªæœç´¢åˆ°ä»»ä½•åŒ¹é…çš„å†…å®¹!" << endl;
				return;
			}

			for (auto& term : it->second.getInvertList())
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
			}
		}
		
```







è¿›è¡Œ å¥å­ æŸ¥è¯¢:  ----> å¤šå•è¯----> æ±‚äº¤é›†

ä½¿ç”¨äº† **æ³›å‹ç®—æ³• æ±‚äº¤é›†** :   -->  **å¿…é¡»æœ‰åº **       `std::set_intersection`

`std::set_intersection` æ˜¯ä¸€ä¸ªä¸“é—¨ç”¨äºæ±‚**ä¸¤ä¸ªæ’åºå¥½**çš„é›†åˆäº¤é›†çš„ç®—æ³•ã€‚å®ƒéœ€è¦è¾“å…¥ä¸¤ä¸ª**å·²ç»æ’åºçš„å®¹å™¨**ï¼Œå¹¶å°†**äº¤é›†çš„ç»“æœè¾“å‡ºåˆ°ä¸€ä¸ªç›®æ ‡å®¹å™¨ä¸­**ã€‚

```c++
#include <algorithm>

```



ä¸ºäº† æ¯”è¾ƒ å€’æ’é¡¹, å› æ­¤ è¦ä¹ˆ åœ¨å€’æ’é¡¹é‡Œ å†™ è¿ç®—ç¬¦é‡è½½,  è¦ä¹ˆ ä¼ ä¸€ä¸ª å‡½æ•°å¯¹è±¡,  æœ¬è¯¾ç¨‹, è€å¸ˆ æ˜¯å†™äº† è¿ç®—ç¬¦é‡è½½







```c++
	// æŸ¥è¯¢æ¥å£
	void query(string phrase)
	{
		// å…ˆè¿›è¡Œå¥å­åˆ†è¯æ“ä½œ
		vector<string> wordList;
		char* word = strtok(const_cast<char*>(phrase.c_str()), " ");
		while (word != nullptr)
		{
			word = trim(word);
			if (strlen(word) > 0)
			{
				wordList.emplace_back(word);
			}
			word = strtok(nullptr, " ");
		}

		if (wordList.empty())   // è¿™æ®µåœ¨ å®é™… åšäº§å“æ—¶,  åœ¨å®¢æˆ·ç«¯å°±å¤„ç†æ‰,  å®¢æˆ·ç«¯å¤„  å‘ç° ç”¨æˆ·æ²¡æœ‰å¡«å†™, å°±æ‹¦æˆªäº†
			return;

		if (wordList.size() == 1)
		{
			auto it = invertMap_.find(wordList[0]);
			if (it == invertMap_.end())
			{
				cout << "æœªæœç´¢åˆ°ä»»ä½•åŒ¹é…çš„å†…å®¹!" << endl;
				return;
			}

			for (auto& term : it->second.getInvertList())
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
			}
		}
		else
		{
			// å¤šä¸ªå•è¯çš„æœç´¢ç»“æœè¿›è¡Œåˆå¹¶å¤„ç†
			vector<InvertList> invertList;
			for (int i = 0; i < wordList.size(); i++)
			{
				// invertList.emplace_back(invertMap_[wordList[i]]);
				auto it = invertMap_.find(wordList[i]);
				if (it != invertMap_.end())
				{
					invertList.emplace_back(it->second);
				}
			}

			// å¼€å§‹éå†æ‰€æœ‰çš„å€’æ’åˆ—è¡¨ï¼Œæ±‚é‡Œé¢å€’æ’é¡¹çš„äº¤é›†
			vector<InvertTerm> termShared;
			vector<InvertTerm> v1(invertList[0].getInvertList().begin(),
				invertList[0].getInvertList().end());
			for (int i = 1; i < invertList.size(); i++)
			{
				vector<InvertTerm> v2(invertList[i].getInvertList().begin(),
					invertList[i].getInvertList().end());

				sort(v1.begin(), v1.end());
				sort(v2.begin(), v2.end());

				// æ±‚ä¸¤ä¸ªå€’æ’åˆ—è¡¨é‡Œé¢å€’æ’é¡¹çš„äº¤é›†
				// set_intersectionæ±‚é›†åˆäº¤é›†æ—¶ï¼Œå¿…é¡»ä¿è¯v1å’Œv2æ˜¯æœ‰åºçš„
				set_intersection(v1.begin(), v1.end(),
					v2.begin(), v2.end(),
					back_inserter(termShared));

				v1.swap(termShared);  // æœ€å æ”¾å…¥ v1 é‡Œ
				termShared.clear();
			}

			// å¾—åˆ†æ’åæ¯”è¾ƒé«˜çš„å€’æ’é¡¹
			for (auto& term : v1)
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
				cout << "locations:";
				/*for (int pos : term.locations_)
				{
					cout << pos << " ";
				}
				cout << endl;*/
			}

			// æŠŠå‡ºç°éƒ¨åˆ†å•è¯çš„å€’æ’é¡¹å†…å®¹æ‰“å°å‡ºæ¥

		}
	}
```





### æ±‡æ€»

```c++
#include <iostream>
#include <string>
#include <list>
#include <unordered_map>
#include <algorithm>
using namespace std;

#undef UNICODE
#include <Windows.h>




// å€’æ’é¡¹
struct InvertTerm
{
	InvertTerm(string docid, int freqs, int location)
		: docid_(docid)
		, freqs_(freqs)
	{
		locations_.emplace_back(location);
	}
	bool operator==(const InvertTerm& term) const
	{
		return docid_ == term.docid_;
	}
	bool operator<(const InvertTerm& term) const
	{
		return docid_ < term.docid_;
	}
	string docid_;        // å•è¯æ‰€åœ¨çš„æ–‡æ¡£
	int freqs_;           // å•è¯å‡ºç°çš„æ¬¡æ•°
	list<int> locations_; // å•è¯å‡ºç°çš„ä½ç½®
};

// å€’æ’åˆ—è¡¨
class InvertList
{
public:
	// æ·»åŠ å€’æ’é¡¹   #2
	void addTerm(string docid, int location)
	{
		for (auto& term : termList_)
		{
			if (term.docid_ == docid) // docidå·²ç»åˆ›å»ºäº†
			{
				term.freqs_++;
				term.locations_.emplace_back(location);
				return; //æœ¬æ¬¡æ·»åŠ å®Œæ¯•
			}
		}

		// ç¬¬ä¸€æ¬¡åˆ›å»ºdocidæ–‡æ¡£çš„å€’æ’é¡¹
		termList_.emplace_back(docid, 1, location);
	}

	// è·å–å€’æ’åˆ—è¡¨å†…å®¹
	const list<InvertTerm>& getInvertList() const
	{
		return termList_;
	}

private:     //#1
	list<InvertTerm> termList_;  // å­˜å‚¨å½“å‰å€’æ’åˆ—è¡¨æ‰€æœ‰çš„å€’æ’é¡¹
};


// å€’æ’ç´¢å¼•
class InvertIndex
{
public:
	// è®¾ç½®æ–‡æ¡£æœç´¢çš„æ ¹è·¯å¾„
	void setSearchPath(string path)
	{
		cout << "æœç´¢æ–‡ä»¶...";
		getAllFile(path.c_str());
		cout << "å®Œæˆ!" << endl;

		cout << "å¼€å§‹åˆ›å»ºå€’æ’ç´¢å¼•";
		createInvertIndex();
		cout << "å®Œæˆ!" << endl;
	}


	// è®¾ç½®æ–‡æ¡£æœç´¢çš„åç¼€åè¿‡æ»¤
	void setSuffix(string suffix)
	{
		suffix_ = suffix;
	}

	// æŸ¥è¯¢æ¥å£
	void query(string phrase)
	{
		// å…ˆè¿›è¡Œå¥å­åˆ†è¯æ“ä½œ
		vector<string> wordList;
		char* word = strtok(const_cast<char*>(phrase.c_str()), " ");
		while (word != nullptr)
		{
			word = trim(word);
			if (strlen(word) > 0)
			{
				wordList.emplace_back(word);
			}
			word = strtok(nullptr, " ");
		}

		if (wordList.empty())   // è¿™æ®µåœ¨ å®é™… åšäº§å“æ—¶,  åœ¨å®¢æˆ·ç«¯å°±å¤„ç†æ‰,  å®¢æˆ·ç«¯å¤„  å‘ç° ç”¨æˆ·æ²¡æœ‰å¡«å†™, å°±æ‹¦æˆªäº†
			return;

		if (wordList.size() == 1)
		{
			auto it = invertMap_.find(wordList[0]);
			if (it == invertMap_.end())
			{
				cout << "æœªæœç´¢åˆ°ä»»ä½•åŒ¹é…çš„å†…å®¹!" << endl;
				return;
			}

			for (auto& term : it->second.getInvertList())
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
			}
		}
		else
		{
			// å¤šä¸ªå•è¯çš„æœç´¢ç»“æœè¿›è¡Œåˆå¹¶å¤„ç†
			vector<InvertList> invertList;
			for (int i = 0; i < wordList.size(); i++)
			{
				// invertList.emplace_back(invertMap_[wordList[i]]);
				auto it = invertMap_.find(wordList[i]);
				if (it != invertMap_.end())
				{
					invertList.emplace_back(it->second);
				}
			}

			// å¼€å§‹éå†æ‰€æœ‰çš„å€’æ’åˆ—è¡¨ï¼Œæ±‚é‡Œé¢å€’æ’é¡¹çš„äº¤é›†
			vector<InvertTerm> termShared;
			vector<InvertTerm> v1(invertList[0].getInvertList().begin(),
				invertList[0].getInvertList().end());
			for (int i = 1; i < invertList.size(); i++)
			{
				vector<InvertTerm> v2(invertList[i].getInvertList().begin(),
					invertList[i].getInvertList().end());

				sort(v1.begin(), v1.end());
				sort(v2.begin(), v2.end());

				// æ±‚ä¸¤ä¸ªå€’æ’åˆ—è¡¨é‡Œé¢å€’æ’é¡¹çš„äº¤é›†
				// set_intersectionæ±‚é›†åˆäº¤é›†æ—¶ï¼Œå¿…é¡»ä¿è¯v1å’Œv2æ˜¯æœ‰åºçš„
				set_intersection(v1.begin(), v1.end(),
					v2.begin(), v2.end(),
					back_inserter(termShared));

				v1.swap(termShared);  // æœ€å æ”¾å…¥ v1 é‡Œ
				termShared.clear();
			}

			// å¾—åˆ†æ’åæ¯”è¾ƒé«˜çš„å€’æ’é¡¹
			for (auto& term : v1)
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
				cout << "locations:";
				/*for (int pos : term.locations_)
				{
					cout << pos << " ";
				}
				cout << endl;*/
			}

			// æŠŠå‡ºç°éƒ¨åˆ†å•è¯çš„å€’æ’é¡¹å†…å®¹æ‰“å°å‡ºæ¥

		}
	}


private:
	// åˆ›å»ºå€’æ’ç´¢å¼•ç»“æ„
	void createInvertIndex()
	{
		for (string& filePath : fileList_)
		{
			cout << ".";
			FILE* pf = fopen(filePath.c_str(), "r");
			if (pf == nullptr)
			{
				cerr << filePath << " ......æ‰“å¼€å¤±è´¥ï¼" << endl;
				continue;
			}

			// æŒ‰è¡Œè¯»å–æ–‡ä»¶é‡Œé¢çš„å†…å®¹ï¼ŒæŒ‰ç…§" "ç©ºæ ¼è¿›è¡Œåˆ†è¯
			vector<string> wordList;
			int location = 0; 
			const int LINE_SIZE = 2048;
			char line[LINE_SIZE] = { 0 };

			while (!feof(pf))
			{
				// è¯»ä¸€è¡Œæ–‡ä»¶å†…å®¹
				fgets(line, LINE_SIZE, pf);

				// æŒ‰ç…§" "ç©ºæ ¼è¿›è¡Œåˆ†è¯ split   strtok
				char* word = strtok(line, " ");
				while (word != nullptr)
				{
					// è¿‡æ»¤ä¸€ä¸‹wordå‰åçš„å¤šä½™çš„ç©ºæ ¼  \t  \n
					word = trim(word);
					if (strlen(word) > 0)
					{
						wordList.emplace_back(word);
					}
					word = strtok(nullptr, " ");
				}

				// å¼€å§‹ç»™wordListé‡Œé¢çš„å•è¯åˆ›å»ºæˆ–è€…ä¿®æ”¹å€’æ’åˆ—è¡¨
				for (string& w : wordList)
				{
					location++;
					auto it = invertMap_.find(w);
					if (it == invertMap_.end())
					{
						// æ–°å»ºwå•è¯çš„å€’æ’åˆ—è¡¨
						InvertList list;
						list.addTerm(filePath, location);
						invertMap_.emplace(w, list);
					}
					else
					{
						it->second.addTerm(filePath, location);
					}
				}
			}

			fclose(pf);
		}
	}

	// å»æ‰åˆ†è¯å  å•è¯å‰åå¤šä½™çš„å­—ç¬¦ \t\t\tsdfads\t\n
	char* trim(char* word)
	{
		int i = 0;
		while (word[i] != '\0')
		{
			if (word[i] == ' ' || word[i] == '\t' || word[i] == '\n')
			{
				i++;
			}
			else
			{
				break;
			}
		}

		int j = i;
		while (word[j] != '\0')
		{
			if (word[j] == ' ' || word[j] == '\t' || word[j] == '\n')
			{
				break;
			}
			j++;
		}
		word[j] = '\0';

		return word + i;
	}

	 

	// é€’å½’æ‰«æè·¯å¾„ä¸‹é¢æ‰€æœ‰çš„æ–‡ä»¶
	int getAllFile(const char* Path)
	{
		char szFind[MAX_PATH];
		WIN32_FIND_DATA FindFileData;
		strcpy(szFind, Path);
		strcat(szFind, "\\*.*");
		HANDLE hFind = FindFirstFile(szFind, &FindFileData);
		if (INVALID_HANDLE_VALUE == hFind)
			return -1;

		do
		{
			if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				if (strcmp(FindFileData.cFileName, ".") != 0 && strcmp(FindFileData.cFileName, "..") != 0)
				{
					//å‘ç°å­ç›®å½•ï¼Œé€’å½’ä¹‹
					char szFile[MAX_PATH] = { 0 };
					strcpy(szFile, Path);
					strcat(szFile, "\\");
					strcat(szFile, FindFileData.cFileName);
					getAllFile(szFile);
				}
			}
			else
			{
				
				//æ‰¾åˆ°æ–‡ä»¶ï¼Œå¤„ç†ä¹‹
				string fileName(FindFileData.cFileName);
				int pos = fileName.find(suffix_);  // abcd.cpp   pos:4 +4 
				if (pos != string::npos && pos + suffix_.size() == fileName.size())
				{
					//std::cout << Path << "\\" << FindFileData.cFileName << std::endl;
					string filePath(Path);
					filePath.append("\\");
					filePath.append(fileName);
					fileList_.emplace_back(filePath);
				}
			}
		} while (FindNextFile(hFind, &FindFileData));

		FindClose(hFind);

		return 0;
	}




private:
	string suffix_;  // è¿‡æ»¤æ–‡æ¡£åç¼€   .cpp .cc .cxx .c
	list<string> fileList_;  // å­˜å‚¨æ‰€æœ‰éœ€è¦å»ºç«‹å€’æ’çš„æ–‡ä»¶
	unordered_map<string, InvertList> invertMap_; // è¯å…¸+å€’æ’åˆ—è¡¨ 
};



int main()
{
	InvertIndex index;
	index.setSuffix(".cpp");
	index.setSearchPath("C:\\Users\\hzh\\Desktop\\Cppå­¦ä¹ å¤§å…¨\\1-è‡ªå­¦ç¬”è®°\\3-æ–½ç£Šc++ç¬”è®°-æ±‡æ€»\\æ–½ç£Šæ ‘ç»“æ„ç¬”è®°\\C++å…¨å¥—æ•°æ®ç»“æ„ç®—æ³•ä»£ç ");

	for (;;)
	{
		char buf[128] = { 0 };
		cout << "æœç´¢å†…å®¹:";
		cin.getline(buf, 128);

		index.query(buf);  // grep
	}

	cout << endl;
	return 0;
}
```

























# 6.å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç --åç»­çœ‹

## åŸºç¡€ç†è®º-pdf

1. **å¸¦æƒè·¯å¾„é•¿åº¦**æœ€çŸ­çš„äºŒå‰æ ‘
2. å¸¸ç”¨äºæ•°æ®å‹ç¼©
3. **æ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦**: å°±æ˜¯æ ‘ä¸­**æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹çš„æƒå€¼ä¹˜ä»¥ å…¶åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦**





ä¸»è¦è§£å†³çš„é—®é¢˜:   

æ€ä¹ˆåŸºäºè¿™ç»„æƒå€¼æ„å»ºä¸€é¢—æœ€ä½³åˆ¤å®šæ ‘ã€æœ€ä¼˜äºŒå‰æ ‘ã€å“ˆå¤«æ›¼æ ‘ï¼ˆhuffmanTreeï¼‰å¸¦æƒè·¯å¾„é•¿åº¦å¯ä»¥è¾¾åˆ°



![image-20250415143126201](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/hafuman-1.png)





æŠ€å·§:  ä½¿ç”¨**æœ€å°å †**,  å°±å¯ä»¥æ‹¿åˆ° æ¯æ¬¡ åºåˆ—é‡Œ æœ€å°çš„å€¼





## å“ˆå¤«æ›¼ç¼–ç æ€§è´¨



1. ä¸åŒäºASCIIå’ŒUnicodeè¿™äº›å­—ç¬¦ç¼–ç ,  è¿™äº›å­—ç¬¦é›†ä¸­çš„ç é•¿éƒ½é‡‡ç”¨çš„æ˜¯é•¿åº¦ç›¸åŒçš„ç¼–ç 
2. å“ˆå¤«æ›¼ç¼–ç ä½¿ç”¨çš„æ˜¯å˜é•¿ç¼–ç 
3. æ»¡è¶³**ç«‹åˆ»å¯è§£ç æ€§**ï¼ˆå°±æ˜¯è¯´ä»»ä¸€å­—ç¬¦çš„ç¼–ç éƒ½**ä¸ä¼šæ˜¯**å¦ä¸€ä¸ªæ›´é•¿å­—ç¬¦ç¼–ç çš„**å‰ç¼€**ï¼‰

![image-20250415162243464](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/hafuman-2.png)

## å“ˆå¤«æ›¼æ ‘ä¸å“ˆå¤«æ›¼ç¼–ç ä»£ç 

### èŠ‚ç‚¹å®šä¹‰

```c++
public:
	HuffmanTree()
		: minHeap_([](Node* n1, Node* n2)->bool
			{return n1->weight_ > n2->weight_; })
		, root_(nullptr)
	{}



private:
	struct Node
	{
		Node(char data, uint weight)
			: data_(data)
			, weight_(weight)
			, left_(nullptr)
			, right_(nullptr)
		{}

		char data_;   // å­—ç¬¦æ•°æ®
		uint weight_; // èŠ‚ç‚¹çš„æƒå€¼
		Node* left_;  // æŒ‡å‘å·¦å­©å­èŠ‚ç‚¹
		Node* right_; // æŒ‡å‘å³å­©å­èŠ‚ç‚¹
	};


private:
	Node* root_; // æŒ‡å‘æ ¹èŠ‚ç‚¹
	unordered_map<char, string> codeMap_; // å­˜å‚¨å­—ç¬¦å¯¹åº”çš„å“ˆå¤«æ›¼ç¼–ç 

	using MinHeap = priority_queue<Node*, vector<Node*>, function<bool(Node*, Node*)>>;
	MinHeap minHeap_;
```





### åˆ›å»ºå“ˆå¤«æ›¼æ ‘-createæ¥å£



ä¼ å…¥  å­—ç¬¦ä¸²,  è¿›è¡Œåˆ›å»º



**ç”¨ map  å¾ˆç®€å•çš„  ç»Ÿè®¡æƒå€¼**





çµé­‚:

```c++
// ç”Ÿæˆçˆ¶èŠ‚ç‚¹
Node* node = new Node('\0', n1->weight_ + n2->weight_);

```



create()

```c++
// åˆ›å»ºå“ˆå¤«æ›¼æ ‘
void create(string str)
{
	// å…ˆç»Ÿè®¡å­—ç¬¦çš„æƒå€¼
	unordered_map<char, uint> dataMap;
	for (char ch : str)
	{
		dataMap[ch]++;
	}

	// ç”ŸæˆèŠ‚ç‚¹ï¼Œæ”¾å…¥å°æ ¹å †ä¸­
	for (auto& pair : dataMap)
	{
		minHeap_.push(new Node(pair.first, pair.second));
	}

	while (minHeap_.size() > 1)
	{
		// è·å–ä¸¤ä¸ªæƒå€¼æœ€å°çš„
		Node* n1 = minHeap_.top();
		minHeap_.pop();

		Node* n2 = minHeap_.top();
		minHeap_.pop();

		// ç”Ÿæˆçˆ¶èŠ‚ç‚¹
		Node* node = new Node('\0', n1->weight_ + n2->weight_);
		node->left_ = n1;
		node->right_ = n2;

		minHeap_.push(node);
	}

	root_ = minHeap_.top();
	minHeap_.pop();
}
```



### è¾“å‡ºå“ˆå¤«æ›¼ç¼–ç 





```c++
// è¾“å‡ºå“ˆå¤«æ›¼ç¼–ç 
void getHuffmanCode()
{
	string code;
	getHuffmanCode(root_, code);

	/*for (auto& pair : codeMap_)   // æµ‹è¯•
	{
		cout << pair.first << " : " << pair.second << endl;
	}
	cout << endl;*/
}

void getHuffmanCode(Node* root, string code)
{
	// VLR
	if (root->left_ == nullptr && root->right_ == nullptr)
	{
		codeMap_[root->data_] = code;
		return;
	}

	getHuffmanCode(root->left_, code + "0");
	getHuffmanCode(root->right_, code + "1");
}

```







### æ•°æ®å‹ç¼©  ä¸ è§£å‹ç¼©



```c++

// encode
string encode(string str)
{
	getHuffmanCode();

	string encode_str; 
	for (char ch : str)
	{
		encode_str.append(codeMap_[ch]);
	}
	return encode_str;
}
```





æ³¨æ„è§£ç çš„æ€æƒ³:   
åˆ©ç”¨å®Œæˆçš„ å“ˆå¤«æ›¼æ ‘,  ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†,  å¦ä¸€è¾¹ ä»encode é‡Œ éå†,  é‡åˆ°å­—ç¬¦0, å·¦èµ°, é‡åˆ° å­—ç¬¦1, å³èµ°

åˆ°è¾¾ å¶å­ç»“ç‚¹,  å°±æ˜¯è§£ç å‡ºæ¥ ä¸€ä¸ªå­—ç¬¦äº†

ç„¶å, ç»§ç»­ ä»æ ¹èŠ‚ç‚¹ å¼€å§‹,  å¦ä¸€è¾¹ åˆ™ æ¥ç€ ä¸Šæ¬¡ä½ç½®,  ç»§ç»­è§£ç 

```c++
// decode
string decode(string encode)
{
	string decode_str;
	Node* cur = root_;

	for (char ch : encode)
	{
		if (ch == '0')
		{
			cur = cur->left_;
		}
		else
		{
			cur = cur->right_;
		}

		if (cur->left_ == nullptr && cur->right_ == nullptr)
		{
			decode_str.push_back(cur->data_);
			cur = root_;
		}
	}
	return decode_str;
}
```





è¿™æ®µä»£ç  ç¼ºå°‘ ææ„, è¦æ³¨æ„, å±‚åºéå† é‡Šæ”¾

## æ€»ç»“



ä¸ºä»€ä¹ˆ å‹ç¼©åçš„ æœ‰æ—¶å€™(å°æ–‡ä»¶ä¼šå‡ºç°) åè€Œæ›´å¤§äº†?







![image-20250415170540575](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/hafuman-3.png)















# 7.å›¾

## åŸºç¡€ç†è®º-æ•™å­¦å›¾ç‰‡+pdf



1. åè¯: **é¡¶ç‚¹, è¾¹,  å‡ºè¾¹, å…¥è¾¹, åº¦, å‡ºåº¦, å…¥åº¦**

2. æœ‰å‘å›¾å’Œ æ— å‘å›¾ 

   æ— å‘å›¾ æ²¡æœ‰ å‡ºè¾¹å’Œ å…¥è¾¹ è¿™ä¸ªæ¦‚å¿µ

   æ— å‘å›¾ ä¸èƒ½ è‡ªå·±åˆ°è‡ªå·±

3. å›¾çš„è¡¨ç¤ºæ–¹å¼: **é‚»æ¥çŸ©é˜µ   å’Œ  é‚»æ¥è¡¨**

   æœ‰å‘å›¾ **æ›´å¥½çš„**  è¿˜æœ‰  **åå­—é“¾è¡¨**

   æ— å‘å›¾ **æ›´å¥½çš„**  è¿˜æœ‰ **é‚»æ¥å¤šé‡è¡¨(è¾¹åˆ—è¡¨)**

![image-20250411113603882](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å›¾-1.png)

## é‚»æ¥çŸ©é˜µ

æŒ‡çš„æ˜¯   ç›´è¾¾



![image-20250411120723129](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å›¾-2.png)



å€’æ’ç´¢å¼•

## é‚»æ¥è¡¨



ç»“æ„å’Œ é“¾å¼å“ˆå¸Œ ä¸€æ ·,



é‚»æ¥è¡¨(å‡ºåº¦) å’Œ  é€†é‚»æ¥è¡¨(å…¥åº¦)

**ç¼ºç‚¹: ** å°±æ˜¯  å‡ºå…¥åº¦ æ— æ³• ç›´æ¥å¾—åˆ°, æ¯ç§é‚»æ¥è¡¨   åªèƒ½å¾—åˆ°ä¸€ç§åº¦



**æ— å‘å›¾ çš„  é‚»æ¥è¡¨,  è¿˜ä¼š å¯¼è‡´ å†—ä½™ å­˜å‚¨**



![image-20250411122058637](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å›¾-3.png)





## åå­—é“¾è¡¨--æœ‰å‘å›¾



è¦æ˜ç™½, æ’å…¥ ä¸€ä¸ª èŠ‚ç‚¹æ—¶,  ä¸€å…±åšäº†å“ªäº›äº‹



èŠ‚ç‚¹ç»“æ„:

1. é¡¶ç‚¹ æ–°å¢äº† firstin
2. è¾¹è¡¨èŠ‚ç‚¹  æ–°å¢äº† tailvex, hlink





é€šä¿—æ¥è®²:   **é¡¶ç‚¹** æœ‰äº† **æ‰€æœ‰ å‡ºè¾¹** å’Œ  **æ‰€æœ‰ å…¥è¾¹**,   **è¾¹è¡¨èŠ‚ç‚¹** æœ‰äº† è¾¹çš„ **èµ·ç‚¹å’Œç»ˆç‚¹**(èŠ‚ç‚¹æ•°æ®åŸŸ) ä¿¡æ¯, è¿˜æœ‰ **åŒèµ·ç‚¹çš„ å…¶ä»–è¾¹**(èŠ‚ç‚¹æŒ‡é’ˆåŸŸ -é“¾è¡¨),  **åŒç»ˆç‚¹çš„ å…¶ä»–è¾¹**(èŠ‚ç‚¹æŒ‡é’ˆåŸŸ -é“¾è¡¨)





![image-20250411134725934](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å›¾-4.png)



## é‚»æ¥å¤šé‡è¡¨(å˜åˆ—è¡¨)--æ— å‘å›¾

mark  ä¸€èˆ¬ æ˜¯ç”¨äº è¡¨ç¤º è¯¥é¡¶ç‚¹ æ˜¯å¦è¢«è®°å½•è¿‡



![image-20250411144622049](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å›¾-5.png)





## æ·±åº¦-å¹¿åº¦ä¼˜å…ˆéå†-å›¾-ç†è®º

å¹¿åº¦éå† éœ€è¦å€ŸåŠ© é˜Ÿåˆ—----> å¯ä»¥å‚è€ƒ æ ‘çš„ å¹¿åº¦éå†



æ·±åº¦ä¼˜å…ˆç›¸å½“äº  æ ‘çš„ å‰åºéå†





## æœ‰å‘å›¾é‚»æ¥è¡¨-ä»£ç 

è¿™ä¸ªä»£ç å‘¢,  ç»™ é¡¶ç‚¹ éƒ½ç¼–å·äº†, èŠ‚ç‚¹æ•°æ®åŸŸ å­˜å‚¨ **é¡¶ç‚¹å®é™…å­—ç¬¦**

é‚»æ¥è¡¨é‡Œ, ä½¿ç”¨  **å­—ç¬¦çš„ç¼–å·** è¡¨ç¤º è¿æ¥äº† å“ªäº›é¡¶ç‚¹ 

åŒæ—¶ ä½¿ç”¨äº† å¤§é‡å®¹å™¨, ä¸éœ€è¦æ‰‹åŠ¨ç»´æŠ¤



### èŠ‚ç‚¹ç»“æ„

```c++
private:
	// é¡¶ç‚¹ç±»å‹
	struct Vertic
	{
		Vertic(string data)
			: data_(data)
		{
		}
		string data_;       // å­˜å‚¨é¡¶ç‚¹çš„ä¿¡æ¯
		list<int> adjList_; // é‚»æ¥é“¾è¡¨ç»“æ„
	};

private:
	vector<Vertic> vertics; // é‚»æ¥è¡¨ç»“æ„
```



### ä»é…ç½®æ–‡ä»¶è¯»å–å›¾çš„ä¿¡æ¯

å¯ä»¥è¯•ç€ æŠŠ è¯»æ–‡ä»¶ ç”¨ c++ é£æ ¼å†™ä¸€ä¸‹, std::fstream



vector.back()è®¿é—®æœ€åä¸€ä¸ªå…ƒç´ , ä½†æ˜¯å¿…é¡»  **ä¿è¯ vector éç©º, å¦åˆ™ ä¼šæŠ¥é”™**



atoi--> ascii to int   ä¸å®‰å…¨, cé£æ ¼



```c++
// ä»é…ç½®æ–‡ä»¶è¯»å…¥é¡¶ç‚¹å’Œè¾¹çš„ä¿¡æ¯ï¼Œç”Ÿæˆé‚»æ¥è¡¨
void readFile(string filePath)
{
	// fopen ä¼ å…¥çš„æ˜¯ const char*
	// c_str----string è½¬æ¢æˆ const char*
	FILE* pf = fopen(filePath.c_str(), "r");
	if (pf == nullptr)
	{
		throw filePath + " not exists!";
	}

	// å ç”¨ç¬¬0å·ä½ç½®,  è®© å›¾ä» 1 å¼€å§‹
	vertics.emplace_back("");

	while (!feof(pf))
	{
		char line[1024] = { 0 };
		fgets(line, 1024, pf);
		// å¢åŠ ä¸€ä¸ªèŠ‚ç‚¹ä¿¡æ¯
		string linestr(line);
		vertics.emplace_back(linestr.substr(0, linestr.size() - 1));  // åªè¯»ä¸€ä¸ª, ä¸ç„¶ä¼šæœ‰æ¢è¡Œç¬¦ \n

		fgets(line, 1024, pf);
		char* vertic_no = strtok(line, ",");
		while (vertic_no != nullptr)
		{
			int vex = atoi(vertic_no);
			if (vex > 0) // ç»†èŠ‚å¤„ç†, ä¸‹æ ‡å¿…é¡»å¤§äº0, æ„Ÿè§‰è¿˜èƒ½åŠ ä¸€ä¸ª å°äº, ä¸è¿‡è¿™ä¼šç”±äº å…ƒç´ æ²¡åŠ å®Œ, å¾—ä¸åˆ°æœ€ç»ˆçš„ é•¿åº¦
			{
				vertics.back().adjList_.emplace_back(vex);
			}
			vertic_no = strtok(nullptr, ",");// è¿™æ˜¯strtokç»§ç»­åˆ†å‰²,  æ³¨æ„ è¦ä¼šç”¨
		}
	}

	fclose(pf);
}
```





### è¾“å‡ºæ‰“å°é‚»æ¥è¡¨

```c++
// è¾“å‡ºé‚»æ¥è¡¨ä¿¡æ¯
void show() const
{
	for (int i = 1; i < vertics.size(); i++)  // ä¸ç”¨foreach, ä¸æ‰“å° ç¬¬ä¸€ä¸ª
	{
		cout << vertics[i].data_ << " : ";
		for (auto no : vertics[i].adjList_)
		{
			cout << no << " ";
		}
		cout << endl;
	}
	cout << endl;
}
```





### æœ‰å‘å›¾ æ·±åº¦ä¼˜å…ˆéå†

```c++
// å›¾çš„æ·±åº¦ä¼˜å…ˆéå†
void dfs()
{
	vector<bool> visited(vertics.size(), false); // vectoråˆå§‹åŒ–, æŒ‡å®šå¤§å°å’ŒæŒ‡å®šé»˜è®¤å€¼
	dfs(1, visited);  // 1æ˜¯ä¸‹æ ‡
	cout << endl;
}
```





```c++
// æ·±åº¦ä¼˜å…ˆéå†çš„é€’å½’æ¥å£
void dfs(int start, vector<bool>& visited)   // startæ˜¯ä¸‹æ ‡
{
	// è¯¥starté¡¶ç‚¹å·²ç»éå†è¿‡äº†
	if (visited[start])
	{
		return;
	}

	cout << vertics[start].data_ << " ";
	visited[start] = true;

	// é€’å½’éå†ä¸‹ä¸€å±‚èŠ‚ç‚¹
	for (auto no : vertics[start].adjList_)
	{
		dfs(no, visited);
	}
}
```







### æœ‰å‘å›¾å¹¿åº¦ä¼˜å…ˆ

é˜Ÿåˆ—å®ç°



```c++
// å¹¿åº¦ä¼˜å…ˆéå†
void bfs()
{
	vector<bool> visited(vertics.size(), false);
	queue<int> que;

	que.push(1);
	visited[1] = true;

	while (!que.empty())
	{
		int cur_no = que.front();  // ç¼–å·
		que.pop();

		cout << vertics[cur_no].data_ << " ";

		for (auto no : vertics[cur_no].adjList_)
		{
			if (!visited[no])
			{
				que.push(no);
				visited[no] = true;
			}
		}
	}
	cout << endl;
}
```







# å›¾çš„æœ€çŸ­è·¯å¾„ç®—æ³•

## ä¸å¸¦æƒå€¼çš„æœ€çŸ­è·¯å¾„ç®—æ³•-æœ‰å‘å›¾-å¹¿åº¦

**æ³¨æ„:  è¿™æ˜¯ ä¸å¸¦æƒå€¼, é¢è¯•è¦æ³¨æ„**



**åˆ©ç”¨å¹¿åº¦ä¼˜å…ˆéå†**-----å¹¿åº¦ä¼˜å…ˆçš„  ä¸€ä¸ª å…¸å‹åº”ç”¨åœºæ™¯



**æ¯ä¸ª é¡¶ç‚¹è®°å½•ä¸€ä¸‹  ä»å“ªä¸ªé¡¶ç‚¹ è¿‡æ¥çš„-**---> ä¹Ÿå°±æ˜¯ åœ¨ä¸Šé¢å¹¿åº¦ä¼˜å…ˆçš„ åŸºç¡€ä¸Š, å†**é¢å¤– å»ºç«‹ä¸€ä¸ª æ•°ç»„**, æ ‡è¯† è¿™ä¸ª



ç›´æ¥åœ¨ å¹¿åº¦ ä¼˜å…ˆçš„ ä»£ç ä¸Šè¿›è¡Œä¿®æ”¹å³å¯



```c++
// æ±‚ä¸å¸¦æƒå€¼çš„æœ€çŸ­è·¯å¾„é—®é¢˜ - å¹¿åº¦ä¼˜å…ˆéå†
void shortPath(int start, int end)   // ä¼ å…¥çš„æ˜¯è¦å¯»æ‰¾çš„æœ€çŸ­è·¯å¾„çš„ èµ·å§‹ å’Œ ç»ˆç‚¹, 
{
	vector<bool> visited(vertics.size(), false);
	queue<int> que;
	// è®°å½•é¡¶ç‚¹åœ¨éå†è¿‡ç¨‹ä¸­çš„å‰åéå†å…³ç³»----ä¿®æ”¹1
	vector<int> path(vertics.size(), 0);

	que.push(start);
	visited[start] = true;

	while (!que.empty())
	{
		int cur_no = que.front();
		if (cur_no == end  // ä¿®æ”¹-3   åˆ°ç»ˆç‚¹, å°±é€€å‡º
		{
			// æ‰¾åˆ°endæœ«å°¾èŠ‚ç‚¹
			break;
		}
		que.pop();

		//cout << vertics[cur_no].data_ << " ";

		for (auto no : vertics[cur_no].adjList_)
		{
			if (!visited[no])
			{
				que.push(no);
				visited[no] = true;
				// å½“å‰èŠ‚ç‚¹å¤„ï¼Œè®°å½•æ˜¯ä»å“ªä¸€ä¸ªèŠ‚ç‚¹è¿‡æ¥çš„  --- ä¿®æ”¹2
				path[no] = cur_no;
			}
		}
	}
	
    // ä¿®æ”¹-4        
	if (!que.empty())
	{
		// å­˜åœ¨ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼Œæ€ä¹ˆè¾“å‡ºï¼Ÿ
		/*while (end != 0) // ä»åå¾€å‰ æ‰“å°çš„
		{
			cout << vertics[end].data_ << " <= ";
			end = path[end];  // å›åˆ°ä¸Šä¸€ä¸ª ç‚¹çš„ ç¼–å·
		}*/
		showPath(end, path);  // æ­£å‘è¾“å‡º, é€’åˆ°ç¬¬ä¸€ä¸ª, å†å¾€åæ‰“å°
	}
	else
	{
		cout << "ä¸å­˜åœ¨æœ‰æ•ˆçš„æœ€çŸ­è·¯å¾„!" << endl;
	}
	cout << endl;
}
```





å°è£…çš„  **æ­£å‘æ‰“å°** è·¯å¾„çš„  å‡½æ•°---é€’å½’



```c++
// è¾“å‡ºæœ€çŸ­è·¯å¾„ä¿¡æ¯
void showPath(int end, vector<int>& path)
{
	if (end == 0)  // å·²ç»å›æº¯åˆ°èµ·å§‹èŠ‚ç‚¹äº†
		return;

	showPath(path[end], path);
	cout << vertics[end].data_ << " ";
}
```





## Dijkstraæœ€çŸ­è·¯å¾„-æœ‰æƒå€¼

**è´ªå¿ƒç®—æ³•çš„  å…¸å‹åº”ç”¨åœºæ™¯-----å•æºæœ€çŸ­è·¯å¾„**



è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•åº”ç”¨---å¯¼èˆª,é€é¤ç­‰



å…·ä½“ æ¦‚å¿µå’Œ ä¾‹å­------->  å‚è€ƒ æ•™å­¦å›¾ç‰‡





**é‡å¤§ç¼ºé™·---ä¸èƒ½å¤„ç† è´Ÿæƒè¾¹**---ä¸‹é¢è¿™ä¸ªä¾‹å­:
aåˆ°b çš„ æœ€çŸ­åº”è¯¥æ˜¯  6-3=3,  ä¸æ˜¯4

ä½†æ˜¯ç”±äº é›†åˆ æ˜¯å…ˆå¤„ç† B, å¯¼è‡´ å¾—ä¸åˆ° æœ€ä¼˜

å…¶æ ¹æœ¬åœ¨äº--->  **æœ‰äº† è´Ÿæƒè¾¹, å±€éƒ¨æœ€ä¼˜å°±ä¸æ˜¯ æ•´ä½“æœ€ä¼˜äº†**





![image-20250411184356547](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å›¾-6.png)





## Dijkstraä»£ç -æ‰‹æ’•

è·Ÿåœ°å›¾æœ‰å…³çš„,  é¢è¯• å¯èƒ½ä¼š æ‰‹æ’•



### main



```c++
using uint = unsigned int;
const uint INF = INT_MAX;  // ä½¿ç”¨æ— ç¬¦å·ç±»å‹, æ˜¯ä¾¿äº INFè¿˜å¯ä»¥è¿›è¡Œç›¸åŠ , é˜²æ­¢è¶Šç•Œ

```

INT_MAX----> æ˜¯ä¸€ä¸ªå®, æœ‰ç¬¦å·æ ‘ æœ€å¤§å€¼  21äº¿å·¦å³



ä½¿ç”¨ äºŒç»´æ•°ç»„, å­˜å‚¨ä¸€ä¸ª æœ‰æƒå€¼çš„ çš„å›¾



```c++
vector<vector<uint>> graph =
{
	{0, 6, 3, INF, INF, INF},
	{6, 0, 2, 5, INF, INF},
	{3, 2, 0, 3, 4, INF},
	{INF, 5, 3, 0, 2, 3},
	{INF, INF, 4, 2, 0, 5},
	{INF, INF, INF, 3, 5, 0},
};
```





### Dijkstraå‡½æ•°

æ³¨æ„,  ä»è€å¸ˆè®²çš„ æ¥çœ‹,  Sé›†åˆ å­˜æ”¾çš„æ˜¯ å·²ç¡®å®šçš„æœ€çŸ­è·ç¦» çš„èŠ‚ç‚¹,  Ué›†åˆ é‡Œæ˜¯ å¾…ç¡®å®šçš„ èŠ‚ç‚¹



**ä½†æ˜¯ ä»£ç  å’Œ è®²çš„ ç¨å¾®ä¸ä¸€æ ·**

Sé›†åˆ å­˜æ”¾çš„ ä¸€ç›´æ˜¯ æ‰€æœ‰èŠ‚ç‚¹çš„ æœ€çŸ­è·ç¦», åˆå€¼éƒ½ä¸º0

Ué›†åˆ ä½¿ç”¨ bool , true è¡¨ç¤º è¯¥ç¼–å·å·²ç»ç¡®å®šäº†æœ€çŸ­è·ç¦», false è¡¨ç¤º è¿˜æœªç¡®å®š

ç”±äº ç¬¬ä¸€ä¸ª èŠ‚ç‚¹ åˆ°æœ¬èº«å¼€å§‹å°±æ˜¯0, æ˜¯ç¡®å®šçš„, æ‰€ä»¥ U ä» ç¼–å·1 å¼€å§‹, è€Œä¸æ˜¯ 0å¼€å§‹



ç¼–å·, å°±æ˜¯ æ•°ç»„ä¸‹æ ‡



**ä¸€å®šè¦åœ¨ æ¯æ¬¡ç¡®å®šä¸€ä¸ªç‚¹å,  æ›´æ–° è·ç¦», å†å¾ªç¯åˆ¤æ–­**

å¯ä»¥ è‡ªè¡ŒåŠ å…¥  ---  è¡Œèµ°è¿‡ç¨‹, æ‰“å°è·¯å¾„(å°±åƒ ä¸å¸¦æƒå€¼çš„  pathæ•°ç»„, å­˜å‚¨ ä¸Šä¸€ä¸ªèŠ‚ç‚¹ç¼–å·)





```c++
// è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•æ¥å£
int Dijkstra(vector<vector<uint>>& graph,
			 int start,  // èµ·ç‚¹ 
			 int end)    // ç»ˆç‚¹
{
	const int N = graph.size();
	// å­˜å‚¨å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„(æœ€å°æƒå€¼)
	vector<uint> dis(N, 0);   // Sé›†åˆ,
	vector<bool> use(N, false);// Ué›†åˆ

	// æŠŠstartæ”¾å…¥Sé›†åˆ
	use[start] = true;  // æ”¾å…¥ ç¬¬ä¸€ä¸ªäº†
	// åˆå§‹åŒ–startåˆ°å…¶å®ƒUé›†åˆé¡¶ç‚¹æƒå€¼-------Sé›†åˆé‡Œé¢çš„ è·ç¦»éƒ½æ›´æ–°äº†, ä¸å†æ˜¯0, è€Œæ˜¯ äºŒç»´æ•°ç»„é‡Œçš„ ç›´è¾¾è·ç¦»
	for (int i = 0; i < N; i++)
	{
		dis[i] = graph[start][i];  // è¿™æ˜¯ ç›´è¾¾çš„ è·ç¦»
	}

	// æŠŠUé›†åˆä¸­çš„é¡¶ç‚¹å¤„ç†å®Œ  i=0 å·²æ”¾å…¥,ä¸éœ€è¦ç®¡
	for (int i = 1; i < N; i++)    // O(n)
	{
		// å…ˆä»Ué›†åˆä¸­æ‰¾åˆ°æƒå€¼æœ€å°çš„é¡¶ç‚¹   
		int k = -1;  // ä¸‹æ ‡, ç”¨äºåœ¨Sé›†åˆ ä¿®æ”¹å¯¹åº”ç‚¹çš„æœ€å°å€¼
		int min = INF;
		for (int j = 0; j < N; j++)  // O(n)  éå†U, æ‰¾æœ€å°
		{
			if (!use[j] && min > dis[j]) // Ué›†åˆçš„é¡¶ç‚¹
			{
				min = dis[j];
				k = j;  // æ›´æ–°ä¸‹æ ‡
			}
		}

		if (k == -1)  // æ²¡æœ‰æ›´æ–°, ä¹Ÿå°±æ˜¯ åˆ°è¾¾ä¸äº†, ä¸€ç›´æ˜¯INF
		{
			break;  // ç›´æ¥é€€å‡º
		}

		// æŠŠé€‰å‡ºçš„é¡¶ç‚¹åŠ å…¥åˆ°Sé›†åˆä¸­
		use[k] = true;

		// æŠŠUé›†åˆä¸­å‰©ä½™é¡¶ç‚¹çš„æƒå€¼ä¿¡æ¯æ›´æ–°ä¸€ä¸‹(åœ¨Sé‡Œæ›´æ–°)
		for (int j = 0; j < N; j++)
		{
			if (!use[j] && min + graph[k][j] < dis[j]) // Ué›†åˆ
			{
				dis[j] = min + graph[k][j];
			}
		}
	}

	// æµ‹è¯•æ‰“å°
	for (int d : dis)
	{
		cout << d << " ";
	}
	cout << endl;

	return dis[end];
}


int main()
{
	vector<vector<uint>> graph =
	{
		{0, 6, 3, INF, INF, INF},
		{6, 0, 2, 5, INF, INF},
		{3, 2, 0, 3, 4, INF},
		{INF, 5, 3, 0, 2, 3},
		{INF, INF, 4, 2, 0, 5},
		{INF, INF, INF, 3, 5, 0},
	};

	int distance = Dijkstra(graph, 0, 1);
	if (distance == INF)
	{
		cout << "ä¸å­˜åœ¨æœ‰æ•ˆè·¯å¾„!" << endl;
	}
	else
	{
		cout << "distance:" << distance << endl;
	}
}
```





### Dijkstraå‡½æ•°---ä¼˜åŒ–(å°æ ¹å †)

ä¸ä¼˜åŒ–, æ˜¯O(n^2)



**ä¼˜å…ˆé˜Ÿåˆ—---æ¢æˆå°æ ¹å †**   ---  å°†éå† Ué›†åˆæ‰¾æœ€å°, ä» O(n)ä¼˜åŒ–ä¸ºO(logn)



æ‰¾æƒå€¼æœ€å°, å°æ ¹å †(ä¸éœ€è¦æ’åºä¹Ÿæ˜¯å¯ä»¥çš„)---è¦æ³¨æ„**è¦èƒ½æ‰¾åˆ° ç¼–å·**



æ³¨æ„, ä¼˜å…ˆé˜Ÿåˆ—é‡Œé¢ç”¨ pair é”®å€¼å¯¹æ—¶,  å¤§å°æ ¹å †, æ˜¯ æŒ‰é”®æ’åº, è€Œä¸æ˜¯ å€¼

å› æ­¤, pair é‡Œé¢ åº”è¯¥æ˜¯ **<æƒå€¼, ç¼–å·>**  è¿™æ ·å®šä¹‰



**æ³¨æ„ç»†èŠ‚, å¤„ç†å’Œä¸Šé¢çš„ æœ‰ç‚¹ä¸åŒ----å°¤å…¶æ˜¯ æ›´æ–° Ué›†åˆé¡¶ç‚¹çš„æƒå€¼, æ— æ³•éå†å¾—åˆ°----åªèƒ½é‡å¤æ·»åŠ (åªé‡å¤æ·»åŠ  æœªå¤„ç†è¿‡çš„)**



å›é¡¾ä¸€ä¸‹, STLçš„ ä¸€äº›é€šç”¨ å‡½æ•°å

ä¸‰å¤§æœ€åŸºæœ¬çš„  vector, deque, list   éƒ½æ˜¯ push_back, åä¸¤ä¸ªè¿˜æœ‰ push_front,  å› ä¸ºæ˜¯ä¸€ä¸ªæ˜¯ åŒç«¯é˜Ÿåˆ—, ä¸€ä¸ªæ˜¯ åŒå‘é“¾è¡¨



å‰©ä¸‹çš„ éƒ½æ˜¯ push



è€Œä¸” emplace-----ä¸€èˆ¬æ˜¯ push...å’Œinsert æ”¹ä¸ºemplaceå³å¯

è€Œä¸”, emplace  åœ¨ æ„å»ºpairç±»æ—¶,   push...å’Œ insert  éœ€è¦{}æˆ–è€…make_pair

ä½†æ˜¯ emplaceä¸ç”¨,  ç›´æ¥(... , ...) å³å¯







```c++
// è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•æ¥å£-ä¼˜åŒ–
int Dijkstra(vector<vector<uint>>& graph,
	int start,  // èµ·ç‚¹ 
	int end)    // ç»ˆç‚¹
{
	const int N = graph.size();
	// å­˜å‚¨å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„(æœ€å°æƒå€¼)
	vector<uint> dis(N, 0);
	vector<bool> use(N, false);

	// å®šä¹‰å°æ ¹å †
	priority_queue<pair<uint, int>, vector<pair<uint, int>>, greater<pair<uint, int>>> que;

	// æŠŠstartæ”¾å…¥Sé›†åˆ
	use[start] = true;
	// åˆå§‹åŒ–startåˆ°å…¶å®ƒUé›†åˆé¡¶ç‚¹æƒå€¼
	for (int i = 0; i < N; i++)
	{
		dis[i] = graph[start][i];
		// æŠŠé™¤starté¡¶ç‚¹çš„å…¶å®ƒé¡¶ç‚¹å…¨éƒ¨æ”¾å…¥Ué›†åˆå°æ ¹å †ä¸­
		if (i != start)
		{
			que.emplace(graph[start][i], i);
		}
	}

	// æŠŠUé›†åˆä¸­çš„é¡¶ç‚¹å¤„ç†å®Œ  
	while (!que.empty())    // O(n)
	{
		// ç”¨å°æ ¹å †æ‰¾æƒå€¼æœ€å°çš„é¡¶ç‚¹    O(logn)   pair<æƒå€¼ï¼Œé¡¶ç‚¹ç¼–å·>
		// å…ˆä»Ué›†åˆä¸­æ‰¾åˆ°æƒå€¼æœ€å°çš„é¡¶ç‚¹   
		auto pair = que.top();
		que.pop();
		if (pair.first == INF)  
		{
			break;
		}
		int k = pair.second;
		int min = pair.first;

		if (use[k])  // å¿…é¡»æ˜¯æ²¡å¤„ç†è¿‡çš„
			continue;  // ä¼šå¼¹å‡º
		// æŠŠé€‰å‡ºçš„é¡¶ç‚¹åŠ å…¥åˆ°Sé›†åˆä¸­
		use[k] = true;

		// æŠŠUé›†åˆä¸­å‰©ä½™é¡¶ç‚¹çš„æƒå€¼ä¿¡æ¯æ›´æ–°ä¸€ä¸‹
		for (int j = 0; j < N; j++)
		{
			if (!use[j] && min + graph[k][j] < dis[j]) // Ué›†åˆ
			{
				dis[j] = min + graph[k][j];
				// æ›´æ–°Ué›†åˆä¸­é¡¶ç‚¹çš„æƒå€¼ï¼
				que.emplace(dis[j], j); // jä¼šæœ‰é‡å¤, ä¹Ÿå°±æ˜¯queé‡Œå­˜çš„ä¸œè¥¿ å¤§äº Ué›†åˆfalseçš„å¤§å°, ä½†ä¸å½±å“, æœ‰æ ‡è¯†å¤„ç†äº†æ²¡æœ‰
			}
		}
	}

	// æµ‹è¯•æ‰“å°
	for (int d : dis)
	{
		cout << d << " ";
	}
	cout << endl;

	return dis[end];
}
```



## Floyd-å¼—æ´›ä¼Šå¾·-ä»£ç å·¨ç®€å•

**å¤šæºæœ€çŸ­è·¯å¾„!!**----->   Dijkstraæœ¬èº«æ˜¯ å•æºæœ€çŸ­è·¯å¾„,  è€Œè¦æ˜¯ æ¯ä¸ªé¡¶ç‚¹è¿ç”¨ä¸€æ¬¡ Dijkstra , ä¹Ÿç®—æ˜¯  å¤šæºæœ€çŸ­è·¯å¾„---> ä¹Ÿæ˜¯ O(n^3) 

è¿ç”¨äº† **åŠ¨æ€è§„åˆ’**

O(n^3)---->  ä¼˜ç‚¹å°±æ˜¯  **è´Ÿæƒå€¼**,  ä»£ç  æ›´ç®€å•, æ¯”Dijkstra æ›´ç®€å•!!





![image-20250411215422831](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å›¾-7.png)



ä»£ç å·¨ç®€å•,  æ ¸å¿ƒå°±æ˜¯  ä¸‰å±‚forå¾ªç¯+ ä¸€ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹



```c++
#include <iostream>
#include <vector>
using namespace std;

using uint = unsigned int;
const uint INF = INT_MAX;

int main()
{
	vector<vector<uint>> graph =
	{
		{0, 6, 3, INF, INF, INF},
		{6, 0, 2, 5, INF, INF},
		{3, 2, 0, 3, 4, INF},
		{INF, 5, 3, 0, 2, 3},
		{INF, INF, 4, 2, 0, 5},
		{INF, INF, INF, 3, 5, 0},
	};

	// ä¸€æ¬¡æŠŠæ¯ä¸€ä¸ªé¡¶ç‚¹åŠ å…¥
	for (int k = 0; k < graph.size(); k++)
	{
		// éƒ½éœ€è¦éå†é‚»æ¥çŸ©é˜µ
		for (int i = 0; i < graph.size(); i++)
		{
			for (int j = 0; j < graph.size(); j++)
			{
				graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j]);
			}
		}
	}

	for (auto line : graph)
	{
		for (auto dis : line)
		{
			cout << dis << " ";
		}
		cout << endl;
	}

	// cout << graph[start][end] << endl;
}
```





# å¹¶æŸ¥é›†

## 1.åŸºç¡€ç†è®º-pdf

1. **æ ‘å½¢ç»“æ„**
2. è§£å†³  **å…ƒç´ åˆ†ç»„é—®é¢˜**,  å¤„ç†  **ä¸ç›¸äº¤é›†åˆçš„**   **åˆå¹¶å’ŒæŸ¥è¯¢ç­‰**
3. ç”¨ä¸€ä¸ªæ•°ç»„ è¡¨ç¤º  æ•´ç‰‡æ£®æ—,  æ ‘çš„æ ¹èŠ‚ç‚¹ å”¯ä¸€æ ‡è¯† ä¸€ä¸ªé›†åˆ



## å¹¶æŸ¥é›†æ„å»ºè¿‡ç¨‹

![image-20250414085440926](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å¹¶æŸ¥é›†-1.png)

--ä¸ç†è§£ å°±çœ‹è¯¾



**åˆå¹¶:**

å°†è‹¥å¹²å…ƒç´ åˆå¹¶åˆ°ä¸€ä¸ªæˆ–è€…å¤šä¸ªé›†åˆï¼ˆ**æ„æˆä¸€æ£µæ ‘æˆ–å¤šæ£µæ ‘**ï¼‰ï¼Œå°†å¤šä¸ªé›†åˆåˆå¹¶ï¼ˆå¤šé¢—æ ‘åˆå¹¶ä¸ºä¸€æ£µæ ‘ï¼‰





**æŸ¥è¯¢:**

æŸ¥è¯¢ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­-----**å°±çœ‹åœ¨ä¸åœ¨ä¸€ä¸ªæ ‘ä¸­**





è®¡ç®—å…±æœ‰**å‡ ä¸ªé›†åˆ**ï¼ˆ**å‡ æ£µæ ‘**ï¼‰







## å¹¶æŸ¥é›†ä»£ç 



é‡ç‚¹:   **å¹¶æŸ¥é›† å¿…é¡» ä¾èµ–äº æ•°ç»„**



**ä¸»è¦æ€æƒ³ï¼š**æ¯ä¸€ä¸ªèŠ‚ç‚¹å¯¹åº”çš„æ•°ç»„å…ƒç´ ä½ç½®ï¼Œå­˜å‚¨å®ƒ**çˆ¶èŠ‚ç‚¹çš„ç¼–å·**å³å¯ï¼





ä¸»è¦æ˜¯:  ç”¨æ•°ç»„ä¸‹æ ‡ ä»£è¡¨å…ƒç´ ,  æ•°ç»„é‡Œ å­˜çš„æ˜¯ å…ƒç´ å¯¹åº”çš„ **çˆ¶èŠ‚ç‚¹**



![image-20250414091522037](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/å¹¶æŸ¥é›†-2.png)

### 1.æ•°ç»„åˆå§‹åŒ–

```c++
const int SIZE = 9;
int parent[SIZE]; // è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹(ç»è¿‡ä¼˜åŒ–åè®°å½•æ ‘çš„æ ¹èŠ‚ç‚¹ç¼–å·)
int rank[SIZE];   // è®°å½•èŠ‚ç‚¹çš„å±‚é«˜


int main()
{
	// æ•°ç»„åˆå§‹åŒ–ï¼Œå­˜å‚¨å½“å‰èŠ‚ç‚¹è‡ªå·±çš„ç¼–å·
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
		rank[i] = 1;  
	}
}
```





### æŸ¥è¯¢--åˆå¹¶è¦ç”¨åˆ°

å‡å®šå·²ç»  å¾—åˆ°äº† å®Œæ•´çš„  å¹¶æŸ¥é›† æ•°ç»„





```c++
// å¹¶æŸ¥é›†-æŸ¥è¯¢æ–¹æ³•ã€‚è¿”å›å‚æ•°xèŠ‚ç‚¹æ‰€åœ¨æ ‘çš„æ ¹èŠ‚ç‚¹çš„ç¼–å·
int non_find(int x)
{
	while (x != parent[x])  //æ‰¾ä¸åˆ°æ ¹, åªæœ‰ç›¸ç­‰ æ‰æ˜¯æ ¹èŠ‚ç‚¹
	{
		// xæ›´æ–°æˆå…¶çˆ¶èŠ‚ç‚¹çš„ç¼–å·
		x = parent[x];
	}
	return x;
}
```



```c++
// å¹¶æŸ¥é›†-æŸ¥è¯¢æ–¹æ³•ã€‚é€’å½’ç‰ˆæœ¬å®ç°
int find(int x)
{
	if (x == parent[x])
	{
		return x;
	}
	return find(parent[x]);
}


```





### åˆå¹¶--ä»å¤´å¼€å§‹



```c++
// å¹¶æŸ¥é›†-unionåˆå¹¶æ–¹æ³•
// xå’ŒyåŸæ¥ä¸åœ¨ä¸€ä¸ªé›†åˆä¸­ï¼Œæ‰éœ€è¦åˆå¹¶ï¼›å¦‚æœå·²ç»åœ¨ä¸€ä¸ªé›†åˆä¸­äº†ï¼Œä¸éœ€è¦åˆå¹¶
void merge(int x, int y)
{
	x = find(x);  // æŸ¥å…¶æ ¹èŠ‚ç‚¹
	y = find(y);
	if (x != y)
	{
        // åˆå¹¶ä¸¤ä¸ªé›†åˆ
		parent[x] = y;//æˆ–è€…åè¿‡æ¥æŒ‚
		
	}
}
```





### æµ‹è¯•

```c++
int main()
{
	// æ•°ç»„åˆå§‹åŒ–ï¼Œå­˜å‚¨å½“å‰èŠ‚ç‚¹è‡ªå·±çš„ç¼–å·
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
	}

	/*
1 3
1 2
5 4
2 4
6 8
8 7
	*/
	int x, y;
	for (int i = 0; i < 6; i++)
	{
		cin >> x >> y;
		merge(x, y);
	}

	cout << (find(2) == find(4) ? "OK" : "NO") << endl;
}
```





## å¹¶æŸ¥é›†è·¯å¾„å‹ç¼©ä¸åŠ æƒæ ‡è®°-findä¼˜åŒ–

### è·¯å¾„å‹ç¼©ä»£ç 

å› ä¸ºæ˜¯æ ‘,  ä¸ºäº†æŸ¥è¯¢æ›´å¿«,  åº”è¯¥è®©å…¶ æ›´çª„, æ›´çŸ­



 å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œåœ¨æŸ¥è¯¢è¿‡ç¨‹ä¸­**åªå…³å¿ƒæ ¹èŠ‚ç‚¹æ˜¯ä»€ä¹ˆï¼Œå¹¶ä¸å…³ç³»è¿™æ£µæ ‘çš„å½¢æ€**ï¼Œå› æ­¤åœ¨æŸ¥è¯¢æ“ä½œçš„æ—¶å€™**å°†è®¿é—®è¿‡çš„æ¯ä¸ªç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿®æ”¹æˆæ ‘æ ¹**ï¼Œè¿™æ ·çš„æ–¹æ³•å«åš**è·¯å¾„å‹ç¼©**ã€‚             

ä¸»è¦ å­¦ä¼šé€’å½’ä¼˜åŒ–, å¾ˆæ–¹ä¾¿,  ä»…ä¿®æ”¹äº† æœ€åä¸€è¡Œ





```c++
// å¹¶æŸ¥é›†-æŸ¥è¯¢æ–¹æ³•ã€‚è¿”å›å‚æ•°xèŠ‚ç‚¹æ‰€åœ¨æ ‘çš„æ ¹èŠ‚ç‚¹çš„ç¼–å·
int non_find(int x)
{
	// int pos = x;
	while (x != parent[x])
	{
		// xæ›´æ–°æˆå…¶çˆ¶èŠ‚ç‚¹çš„ç¼–å·
		x = parent[x];
	}

	// æ ‘æ ¹æ˜¯xã€‚æŠŠæ‰§è¡ŒæŸ¥è¯¢æ“ä½œçš„æ—¶å€™å°†è®¿é—®è¿‡çš„æ¯ä¸ªç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿®æ”¹æˆæ ‘æ ¹
	// parent[pos] = x;

	return x;
}
```







åœ¨ C/C++ ä¸­ï¼Œèµ‹å€¼è¯­å¥ä¸ä»…å®Œæˆèµ‹å€¼æ“ä½œï¼Œè¿˜**è¿”å›è¢«èµ‹å€¼çš„é‚£ä¸ªå€¼**ã€‚

**é€’å½’---é‡ç‚¹**

```c++
// å¹¶æŸ¥é›†-æŸ¥è¯¢æ–¹æ³•ã€‚é€’å½’ç‰ˆæœ¬å®ç°
int find(int x)
{
	if (x == parent[x])
	{
		return x;
	}
	// æŠŠæ‰§è¡ŒæŸ¥è¯¢æ“ä½œçš„æ—¶å€™å°†è®¿é—®è¿‡çš„æ¯ä¸ªç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿®æ”¹æˆæ ‘æ ¹
	return parent[x] = find(parent[x]);
}

```





### è·¯å¾„å‹ç¼©ç‰¹æ€§

è·¯å¾„å‹ç¼© çš„ ä¸€äº›ç‰¹æ€§:

1. ç¬¬ä¸€æ¬¡ find æ•ˆç‡ä¸é«˜, åªè¦ findè¿‡, å°±å¾ˆé«˜
2. ç‰µä¸€å‘è€ŒåŠ¨å…¨èº«----> mergeé‡Œ æœ‰ find, åˆå¹¶çš„è¿‡ç¨‹å°±ä¼š find,  åˆå¹¶å®Œæˆ,  findæ•ˆç‡å°±å¾ˆé«˜äº†



### åŠ æƒæ ‡è®°--å¤§æ•°æ®-mergeä¼˜åŒ–

1. å¤§æ•°æ®  å®¹æ˜“å‡ºç°  æ ‘ç‰¹åˆ«é«˜çš„ æƒ…å†µ
2. ä½¿ç”¨æ ‡è®°, è®°å½• æ¯ä¸ªæ ¹å¯¹åº”æ ‘çš„  é«˜åº¦ä¿¡æ¯, 
3. æŠŠé«˜åº¦ å°çš„ æŒ‚åˆ°  é«˜åº¦ä½çš„æ ‘ä¸Š-->  æ˜¯ åˆå¹¶çš„æ ‘  å°½å¯èƒ½ä½
4. **å°çš„ æŒ‚åˆ° å¤§çš„, ä¸ç”¨å˜, å¤§çš„ æ ‘é«˜æ²¡å˜**
5. **ç›¸ç­‰, éšä¾¿æŒ‚ä¸€ä¸ª, è¢«æŒ‚çš„ è¦ åŠ ä¸€å±‚ ,** 



```c++
// æ•°ç»„åˆå§‹åŒ–ï¼Œå­˜å‚¨å½“å‰èŠ‚ç‚¹è‡ªå·±çš„ç¼–å·
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
        rank[i] = 1;  //  ç»™ ä¸€ä¸ªåˆå€¼ 1,  åˆå¹¶ ä¼šæ›´æ–°
	}




// å¹¶æŸ¥é›†-unionåˆå¹¶æ–¹æ³•
// xå’ŒyåŸæ¥ä¸åœ¨ä¸€ä¸ªé›†åˆä¸­ï¼Œæ‰éœ€è¦åˆå¹¶ï¼›å¦‚æœå·²ç»åœ¨ä¸€ä¸ªé›†åˆä¸­äº†ï¼Œä¸éœ€è¦åˆå¹¶
void merge(int x, int y)
{
	x = find(x);
	y = find(y);
	if (x != y)
	{
		if (rank[x] > rank[y])
		{
			parent[y] = x;
		}
		else
		{
			if (rank[x] == rank[y])
			{
				// yä½œä¸ºåˆå¹¶ä»¥åçš„é›†åˆæ ‘çš„æ ¹ï¼Œrankå€¼è¦+1
				rank[y]++;
			}
			// åˆå¹¶ä¸¤ä¸ªé›†åˆ
			parent[x] = y;
		}
	}
}



```







## åº”ç”¨-æœ€å°ç”Ÿæˆæ ‘-Kruskal

### åŸºç¡€ç†è®º-pdf

1. åè¯:  è¿é€šå›¾,  å¼ºè¿é€šå›¾, è¿é€šç½‘, ç”Ÿæˆæ ‘, æœ€å°ç”Ÿæˆæ ‘--->  è¿™å‡ ä¸ªåè¯ æ¦‚å¿µè¦ç‰¹åˆ«æ¸…æ™°
2. å…‹é²æ–¯å¡å°”ç®—æ³•(åŠ è¾¹æ³•)--->æ±‚ æœ€å°ç”Ÿæˆæ ‘---> ç‚¹å¤šè¾¹å°‘--ç¨€ç–å›¾
3. åŠ ç‚¹æ³•(Primç®—æ³•)----> ç¨ å¯†å›¾

### Kruskalæ­¥éª¤

Kruskalç®—æ³•ï¼šæ­¤ç®—æ³•å¯ä»¥ç§°ä¸ºâ€œåŠ è¾¹æ³•â€ï¼Œ**åˆå§‹æœ€å°ç”Ÿæˆæ ‘è¾¹æ•°ä¸º0**ï¼Œæ¯**è¿­ä»£ä¸€æ¬¡**å°±**é€‰æ‹©ä¸€æ¡æ»¡è¶³æ¡ä»¶çš„**æœ€å°ä»£ä»·è¾¹ï¼ŒåŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘çš„è¾¹é›†åˆé‡Œï¼Œæ­¥éª¤å¦‚ä¸‹ï¼š



1. æŠŠå›¾ä¸­çš„æ‰€æœ‰è¾¹æŒ‰æƒå€¼**ä»å°åˆ°å¤§æ’åº**ï¼ŒæŠŠå›¾ä¸­çš„nä¸ªé¡¶ç‚¹çœ‹æˆç‹¬ç«‹çš„né¢—æ ‘ç»„æˆçš„æ£®æ—
2. æŒ‰æƒå€¼**ä»å°åˆ°å¤§**é€‰æ‹©è¾¹ï¼Œæ‰€é€‰çš„è¾¹è¿æ¥çš„ä¸¤ä¸ªé¡¶ç‚¹Viå’ŒVj **åº”å±äº**ä¸¤é¢—**ä¸åŒ**çš„æ ‘ï¼Œåˆ™ç§°ä¸ºæœ€å°ç”Ÿæˆæ ‘ä¸­çš„ä¸€æ¡è¾¹ï¼Œå¹¶åˆå¹¶æˆä¸€æ£µæ ‘
3. é‡å¤æ­¥éª¤2ï¼Œç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½åœ¨ä¸€æ£µæ ‘å†…æˆ–è€…æœ‰n-1æ¡è¾¹ä¸ºæ­¢ã€‚

**ä¾‹å­  è§ pdf**



### Kruskalä»£ç 

æœ¬ä»£ç :  char  éšå¼è½¬æ¢æˆ  intäº†

#### ç¬¬ä¸€æ­¥:åŠ å…¥ç‚¹å’Œè¾¹,å¹¶æ’åº

```c++
// è¾¹ç±»å‹
struct Edge
{
	Edge(int s, int e, int c)
		: start(s)
		, end(e)
		, cost(c)
	{}
	int start; // èµ·å§‹çš„èŠ‚ç‚¹
	int end;   // æœ«å°¾èŠ‚ç‚¹
	int cost;  // è¾¹çš„æƒå€¼
};
const int SIZE = 1000;
int parent[SIZE];



int main()
{
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
	}
    // å®šä¹‰ä¸€ä¸ªè¾¹æ•°ç»„
	vector<Edge> edges;
	int n;
	cin >> n;
    char s, e;
	int c;
    for (int i = 0; i < n; i++)
	{
		cin >> s >> e >> c;
		// è¯»å–è¾¹çš„ä¿¡æ¯ï¼Œæ·»åŠ åˆ°è¾¹æ•°ç»„ä¸­
		edges.emplace_back(s, e, c);
	}	
    
    // æ‰€æœ‰çš„è¾¹æŒ‰æƒå€¼å°åˆ°å¤§è¿›è¡Œæ’åº
	sort(edges.begin(), edges.end(),
		[](auto& a, auto& b)->bool {
			return a.cost < b.cost;
		});
    
    //å¼€å§‹é€‰è¾¹
    
    
}

```





#### ç¬¬äºŒæ­¥:ä»å°åˆ°å¤§é€‰è¾¹



```c++
// å¼€å§‹é€‰è¾¹ï¼ˆæŒ‰å°åˆ°å¤§è¿›è¡Œé€‰æ‹©ï¼‰
for (int i = 0; i < edges.size(); i++)
{
	// æ‰€è°“é€‰æ‹©è¾¹ï¼Œå°±æ˜¯åˆå¹¶è¿™æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œä½†æ˜¯å‰ææ˜¯
	// è¿™ä¸¤ä¸ªé¡¶ç‚¹ä¹‹å‰ä¸åœ¨ä¸€é¢—æ ‘ä¸Š(ä¸åœ¨ä¸€ä¸ªé›†åˆä¸­)
	int a = find(edges[i].start);  //å¹¶æŸ¥é›†çš„æŸ¥è¯¢
	int b = find(edges[i].end);
	if (a != b)  // ä¸åœ¨ä¸€æ£µæ ‘, å¯ä»¥åˆå¹¶
	{
		// å¯ä»¥è¿›è¡Œåˆå¹¶-----éšä¾¿æŒ‚
		parent[a] = b;
		printf("%c -> %c cost:%d \n", edges[i].start,
			edges[i].end, edges[i].cost);
	}
}
```





## é¢˜ç›®:èº²é¿æ‹¥å µçš„æœ€ä½³è·¯çº¿

![image-20250414121234557](./2-æ•°æ®ç»“æ„(äº”å¤§ç®—æ³•ä¹‹å).assets/æœ€å°ç”Ÿæˆæ ‘-1.png)



```c++
3 3 1 3
1 2 2
2 3 1
1 3 3
```





æ³¨æ„æ˜¯æ‰¾ s->tçš„è·¯å¾„!!!!

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int SIZE = 1000;
int parent[SIZE];


struct Edge
{
	Edge(int a, int b, int c)
		:_u(a),
		_v(b),
		_w(c)
	{ }

	int _u;
	int _v;
	int _w;
};

vector<Edge> vec;  // næ¡è¾¹


int find(int n)
{
	if (n == parent[n])
	{
		return n;
	}
	return parent[n] = find(parent[n]);
}

int main()
{
	int m, n, s, t;
	cin >> m >> n >> s >> t;

	// åˆå§‹åŒ– å¹¶æŸ¥é›†çš„ æ•°ç»„
	for (int i = 0; i < n; ++i)
	{
		parent[i] = i;  
	}


	int u, v, w;

	//è¾¹ä¿¡æ¯
	for (int i = 1; i <= m; ++i)
	{
		cin >> u >> v >> w;
		vec.push_back({ u, v, w });
	}
	//æ’åºè¾¹
	sort(vec.begin(), vec.end(), [](Edge& a, Edge& b)->bool {
		return a._w < b._w;
		});


	//é€‰è¾¹
	for (int i = 0; i < vec.size(); ++i)
	{
		int a = find(vec[i]._u);
		int b = find(vec[i]._v);
		if (a != b)
		{
			//åˆå¹¶
			parent[a] = b;
			/*cout << vec[i]._u << "--->" << vec[i]._v << endl;*/

			//æ ¹æ®æœ€å°ç”Ÿæˆæ ‘, ç¬¬ä¸€æ¬¡å‡ºç°é€šè·¯, å°±æ˜¯ è·¯å¾„æ‹¥æŒ¤åº¦çš„æœ€å¤§å€¼æœ€å°çš„æ—¶å€™
			if (find(s) == find(t))
			{
				cout << vec[i]._w << endl;
				break;
			}
			/*if (vec[i]._w > maxmin)
			{
				maxmin = vec[i]._w;
			}*/
		}


	}

	return 0;
}
```



