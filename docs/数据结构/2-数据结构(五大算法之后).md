

# 1.串操作-配合图

## 基本理论

**大数据量,  不使用KMP , 而是  字典树 或者 倒排索引----搜索引擎**



A B C D E F G ----- 主串

A B D ---- 子串/模式串



1. 子串在 主串里面的 搜索过程/操作 也称为 **模式匹配**





## BF串的朴素算法

1. BF（Brute Force）就是“暴力搜索”的意思。它的做法非常直白：

   **在主串中，从头到尾、一个字符一个字符地去试探，看子串是不是从这里开始完全匹配。**

2. 假设：

   - 主串 S 的长度是 n
   - 模式串 P 的长度是 m

   步骤如下：

   1. 从主串的第 `i=0` 位开始，尝试匹配模式串 P；
   2. 如果**匹配失败**，就把 **`i` 往后移动**一位(不是相对于现在i的位置, 而是 相比 上次i开始的位置)，再**重新从 P 的第一个**字符开始比；
   3. 一直尝试到主串剩下的字符不足以匹配模式串（即 `i <= n - m`）为止。

```c++
// 分支限界算法.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <queue>
using namespace std;

// BF算法    时间复杂度：O(n)*O(m) =  O(n*m)   空间复杂度： O(1)
int BF(string s, string t)
{
	int i = 0;
	int j = 0;

	while (i < s.size() && j < t.size())  // O(n)
	{
		if (s[i] == t[j])
		{
			i++;
			j++;
		}
		else
		{
			i = i - j + 1; // 复位i，指向之前开始匹配字符的下一个字符  O(m)
			j = 0;
		}
	}

	if (j == t.size()) // 找到了
	{
		return i - j;
	}
	else
	{
		return -1;
	}
}

int main()
{
	string s = "abcabdefabcabc"; //"ABCDCABDEFG";
	string t = "abcabc"; //"ABD";

	int pos = BF(s, t);
	cout << pos << endl;
}

```







## KMP算法

### 基础



1. 利用“已匹配信息”来避免重复匹配，做到**不回退主串指针**。

2. 它的核心就是提前给模式串建一个 **“部分匹配表”**（又叫：**next 数组**、**前缀函数**）
    这个表告诉我们：如果当前字符不匹配了，模式串应该跳到哪？

3. 举个例子：   **注意, j位置看前后缀, 不包含j位置**

   📌 模式串：P = "ababaca"

   我们要构建 `next` 表（也称 prefix table），表示每个位置前的**最长相等前后缀**的长度。

   | 位置 (j) | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
   | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 字符     | a    | b    | a    | b    | a    | c    | a    |
   | next[j]  | -1   | 0    | 0    | 1    | 2    | 3    | 0    |

   ✅ 结论：

   - 所以正确的 next 表应该是：
   
   ```python
   next = [-1, 0, 0, 1, 2, 3, 0]
   ```
   


### KMP思考核心-了解

1. KMP的**核心 是   怎么求这个 next数组**

2. 子串第 0个 位置 next[0]=-1,   这是 特殊情况,   因为  第一个 都不匹配了,  就把  **主和子 串  都后移**------巧妙地 处理

3. next数组 示意图:

   ![image-20250408092246365](./2-数据结构(五大算法之后).assets/KMP-1.png)

4. 在 上面的 情况下, next[ j+1 ] 可以看一下,  next[j]  和 next[k]的值,  如果相等, 那么就可以  next[ j+1 ] =  next[ j] +1

5. 那不相等呢, 就需要 回退 k,  在 前缀里, 找 到 与j 相等的 地方, 这里很巧妙!!

   思考一下:

   > 1. 现在是 找 next[j+1]的值, 而 j 与 k 不相等, 但是 之前 已经算过 前面的 公共前后缀了(`0---k-1,  j-k----j-1`)
   > 2. 现在要得到 0----k,  与 j-k-----j的公共前后缀
   > 3. j 和 k 不相等, 那实际上,  就是 找 `0---k-1` 前缀  和  `j-k----j`后缀 相等的地方
   > 4. 那首先找到  `0---k-1` (k回退)里面 与 j 相等的 地方
   > 5. 找到后,设为m, 再看 `0----m`  (相当于 `j-k----j-m+1` )与 `j-m+1----j-1` ,  而由于 0---m----k 已经是已知的了,  直接用即可

6. 上面 这点 思考 不重要, **重点是:   j != k,   则  k = next[k]**



### KMP重点 代码:

1.   j != k,   则  k回退,  k = next[k]

2.  j = k, 则 next[j+1] =  next[j]+1(next[j]=k)--->对应代码:

   ```c++
   if (-1 == k || str[k] == str[j])
   		{
   			j++;
   			k++;
   			next[j] = k;
   		}
   ```

3. 重大核心:    --- 形成 next数组

   ```c++
   if (-1 == k || str[k] == str[j])
   		{
   			j++;
   			k++;
   			next[j] = k;
   		}
   		else
   		{
   			k = next[k]; // 做k值回溯，继续找最长的公共前后缀
   		}
   ```

   



在BF 的 基础上 ,  加入 next 数组, i不回退,  再改改细节



**注意细节:   .size返回的 size_t 是无符号类型, -1进去, 会变为1**



```c++
#include <iostream>
#include <memory>
using namespace std;


// KMP算法求解子串的next数组
int* getNext(string str)
{
	int* next = new int[str.size()];
	int j = 0; // j用来遍历子串
	int k = -1; // k表示公共前后缀的长度
	next[j] = k;   

	while (j < str.size() - 1)   // O(m)
	{
		if (-1 == k || str[k] == str[j])
		{
			j++;
			k++;
			next[j] = k;
		}
		else
		{
			k = next[k]; // 做k值回溯，继续找最长的公共前后缀
		}
	}

	return next;
}

// KMP算法  时间复杂度：O(n) + O(m) = O(n+m)  空间复杂度：O(m)
int KMP(string s, string t)
{
	int i = 0;
	int j = 0;

	// 计算一个子串对应的next数组
	int* next = getNext(t);
	unique_ptr<int> ptr(next);  // delete操作

	cout << t << " : ";
	for (int m = 0; m < t.size(); m++)
	{
		cout << next[m] << " ";
	}
	cout << endl;

	// j < t.size() 有问题！！！ j = -1 11111111111  size_t  unsigned int
	int size1 = s.size();
	int size2 = t.size();
	while (i < size1 && j < size2)   // O(n)
	{
		if (-1 == j || s[i] == t[j])
		{
			i++;
			j++;
		}
		else
		{
			// KMP的核心是不回退i，只回退j值 
			j = next[j];  // 如果首字母匹配失败，这里j == -1

			//i = i - j + 1; 
			//j = 0;
		}
	}

	if (j == t.size()) // 找到了
	{
		return i - j;
	}
	else
	{
		return -1;
	}
}

int main()
{
	string s = "abcabdefababaca"; //"ABCDCABDEFG";
	string t = "ababaca"; //"ABD";

	int pos = KMP(s, t);
	cout << pos << endl;
}
```



### KMP优化

1. 针对 **子串 有重复**,  可能导致, 回退后, 继续回退

2. 子串   a   b  c a b c     :

   next:-1 0 0 0 1 2

   最后一个c不匹配 会回退到 上一个c, 此时又要回退

3. 优化点:  优化掉 第一次回退, 直接回退 一步到位

4. 第一次 会回退到 下标 k这个位置,  优化掉,  就回退到 next[k]的位置

5. 例子:   都是下标

   到 5 (next--2)不匹配, 会回退到 2(next -- 0), 又不一样, 会回退到 -1 

   优化后:  到 5 (next---- 0)不匹配, 回退到 -1 

核心代码  小修改一下: 

```c++
if (-1 == k || str[k] == str[j])
{
	j++;
	k++;
	if (str[k] == str[j]) // 连续有重复的
	{
		// kmp算法的优化
		next[j] = next[k];
	}
	else
	{
		next[j] = k;
	}
}
else
{
	k = next[k]; // 做k值回溯，继续找最长的公共前后缀
}
```







# 2.trie字典树(串操作)

**“检索”**（re**trie**val）操作的一种缩写

## 基础理论-pdf

> 本质 是一棵  **多叉树**



1. BF与KMP 是 模式匹配, 主串里 搜索 子串
2. trie字典树---->**不适用于 模式匹配, 适用于 搜索串, 前缀搜索等**
3. 不止是 字母, 还有别的 字符类



## 字典树的性质-重点

**基本性质：**
1、**根节点不包含字符**，除根节点外每一个节点都**只包含一个**字符
2、从根节点到某一结点，路径上经过的**字符连接起来**，为该节点对应的字符串
3、每个**节点的所有子节点**包含的字符**都不相同**







**节点运用**:

实际应用中, 在 每个单词的 末尾,即一条路径上的 节点,  在叶子结点 存储  **isend** 标识------->  **hell    hello    需要在 l 处标识, 就可以存 两个单词**





还有一种就是   标识 个数,  存储重复的,  就加 这个 值





## 例子--看教学图

## 为什么字典树搜索快

传统的 如果用链表 存储 每个单词,  每个单词 都会 从头开始比较
但是 字典树 不会, 公共前缀, 从上下, 只比较一次

## 代码

节点孩子 都是 字符,  每层排序, 可以更快的 搜索

每个节点:  **char, int freqs(单词次数), map<char, 节点*>**   map 红黑树 排序---->  map 里 节点存指针,  不需要去拷贝一个

map 还有一个好处, 键值存储  char, 可以简便 搜索代码





注意 理解 子节点 都是怎么存的----->  map



### 节点定义



```c++

private:
	// 节点类型定义
	struct TrieNode
	{
		TrieNode(char ch, int freqs)
			: ch_(ch)
			, freqs_(freqs)
		{}

		// 节点存储的字符数据
		char ch_;
		// 单词的末尾字符存储单词的数量(频率)
		int freqs_; 
		// 存储孩子节点字符数据和节点指针的对应关系
		map<char, TrieNode*> nodeMap_; 
	};

private:
	TrieNode* root_; // 指向树的根节点
```



### 构造与析构

```c++
public:
	TrieTree()
	{
		root_ = new TrieNode('\0', 0);
	}

	~TrieTree()
	{
		queue<TrieNode*> que;
		que.push(root_);

		while (!que.empty())
		{
			TrieNode* front = que.front();
			que.pop();
			// 把当前节点的孩子节点全部入队列
			for (auto& pair : front->nodeMap_)
			{
				que.push(pair.second);
			}
			// 释放当前节点资源
			delete front;
		}
	}
```

### 添加单词

```c++
//思想   hello
1. 如果孩子有h字符数据的节点，则继续移动cur指向当前节点，遍历下一个字符
2. 如果没有孩子节点，创建相应的节点, 移动cur指向当前节点，遍历下一个字符


```



```c++
// 添加单词--- 巧用map 的查找
void add(const string& word)
{
	TrieNode* cur = root_;

	for (int i = 0; i < word.size(); i++)  // O(m)
	{
		auto childIt = cur->nodeMap_.find(word[i]);
		if (childIt == cur->nodeMap_.end())
		{
			// 相应字符的节点没有，创建它
			TrieNode* child = new TrieNode(word[i], 0);
			cur->nodeMap_.emplace(word[i], child);
			cur = child;
		}
		else
		{
			// 相应的字符节点已经存在，移动cur指向对应的字符节点
			cur = childIt->second;
		}
	}

	// cur指向了word单词的最后一个节点
	cur->freqs_++;
}
```

### 查询单词-query

```c++
// 查询单词
int query(const string& word)
{
	TrieNode* cur = root_;
	for (int i = 0; i < word.size(); i++) // O(m)
	{
		auto childIt = cur->nodeMap_.find(word[i]);
		if (childIt == cur->nodeMap_.end())
		{
			return 0;
		}
		// 移动cur指向下一个单词的字符节点上
		cur = childIt->second;
	}

	return cur->freqs_;
}
```



这个 `nodeMap_` 是一个 **`map<char, TrieNode\*>`**，假设是：

- `std::map`（基于红黑树）→ 查找是 `O(log σ)`
- `std::unordered_map`（哈希表）→ 查找是 `O(1)` 平均，最坏 `O(σ)`

其中 `σ` 是字符集大小，比如只处理小写字母就是 `26`。





### 删除单词-比较复杂



特殊情况:

1. 包含关系：  删长的（情况2），  删小的（情况1）
2. 有公共前缀， 就是 子节点 多（情况3）怎么删







**vector deque 这两个的 erase 只能 迭代器,  list,map相关, set相关可以值,也可以迭代器**



写代码， 先考虑一般， 在考虑 特殊



重点在于:  **找准从哪里开始删, 删到哪里 结束---**

```c++
// 删除单词
void remove(const string& word)
{
	TrieNode* cur = root_;
	TrieNode* del = root_; // 从哪个节点开始删除
	char delch = word[0];

	for (int i = 0; i < word.size(); i++)
	{
		auto childIt = cur->nodeMap_.find(word[i]);
		if (childIt == cur->nodeMap_.end())    
		{
			return;
		}

		// pool  po 情况2和情况3
		if (cur->freqs_ > 0 || cur->nodeMap_.size() > 1)
		{
			del = cur;
			delch = word[i];
		}

		// cur移动到子节点--- 不要理解子，  这就是 移动到了查到的 节点
		cur = childIt->second;
	}

	// cur指向了末尾字符节点；word单词是存在的
	if (cur->nodeMap_.empty())
	{
		// 开始删除
		TrieNode* child = del->nodeMap_[delch];
		del->nodeMap_.erase(delch);

		// 释放相应的节点内存 ---  来自于析构, 直接复制过来的
		queue<TrieNode*> que;
		que.push(child);  // 从哪里开始释放

		while (!que.empty())
		{
			TrieNode* front = que.front();
			que.pop();
			// 把当前节点的孩子节点全部入队列
			for (auto& pair : front->nodeMap_)
			{
				que.push(pair.second);
			}
			// 释放当前节点资源
			delete front;
		}
	}
	else
	{
		// 情况1
		// 当前单词末尾字符后面还有字符节点，不做任何节点删除操作
		cur->freqs_ = 0;
	}
}
```



 

## 应用场景

![image-20250410171825883](./2-数据结构(五大算法之后).assets/字典树-1.png)

### 串排序方面的应用

题目要求前序遍历了----字典本身 已经是 字典序排序了

**思想:**

```c++
遍历到 freqs 参数 >0,  表示 是一个有效的 单词

```







word 是 一个 局部变量,  所以 回溯前word改变, 不影响回溯后, 

```c++
	// 前序遍历字典树
	void preOrder()
	{
		string word;
		vector<string> wordList;
		preOrder(root_, word, wordList);
		for (auto word : wordList)
		{
			cout << word << endl;
		}
		cout << endl;
	}


void preOrder(TrieNode* cur, string word, vector<string> &wordlist)
{
	// 前序遍历 VLR
	if (cur != root_)   // V
	{
		word.push_back(cur->ch_);
		if (cur->freqs_ > 0)
		{
			// 已经遍历到一个有效的单词
			wordlist.emplace_back(word);
		}
	}

	// 递归处理孩子节点
	for (auto pair : cur->nodeMap_)
	{
		preOrder(pair.second, word, wordlist);
	}
}
```





### 串的前缀搜索

前序遍历 那里 有个细节, 由于 之前写的 前序遍历 传入的 word  是当前节点的 前一个节点,  所以 这里 不能传 前缀的最后一个 字符,  传进去会 在 word里加进去,  导致重复了

因此 在组合 单词时,  传入的 前缀 要少一位



时间最长 为 单词长度



**这个就是  网页搜索框, 打出一两个字, 会出来候选词的 核心, 还有代码 函数名自动补充**







```c++
// 串的前缀搜索
vector<string> queryPrefix(const string& prefix)
{
	TrieNode* cur = root_;
	for (int i = 0; i < prefix.size(); i++)
	{
		auto childIt = cur->nodeMap_.find(prefix[i]);
		if (childIt == cur->nodeMap_.end())
		{
			// vector<string> vec{};
			return {};
		}
		cur = childIt->second;
	}

	// cur就指向了前缀的最后一个字符节点了
	vector<string> wordlist;
	preOrder(cur, prefix.substr(0, prefix.size()-1), wordlist);
	return wordlist;
}


```











# 3.sunday算法--自己补充



# 4.跳跃表-SkipList

## 基础理论-pdf



跳跃表（Skip List）是一种**随机化数据结构**，用来代替平衡树（如红黑树）实现**有序集合的查找、插入和删除操作**。

 **基本思想**

跳跃表通过在链表上增加“索引层”，实现**多级链表**，从而加快查找效率，平均时间复杂度为 **O(log n)**。



**优点**

- 实现简单，**比平衡树更容易编码**；
- 插入和删除**不需要复杂的旋转**操作；
- 更容易进行**并发**处理；
- Redis 的 `SortedSet`（有序集合）底层就是跳跃表 + 哈希表。











1. 前提:  有序链表
2. 跳跃表, 实际是  可以相当于链表的 二分查找
3. 在并发环境下，跳跃表加锁的粒度会更小一些，并发能力更强---**比红黑树好**
4. 相比于 红黑树,  是用 空间 换时间
5. 跳跃表的**增加、删除、查询**操作时间复杂度和红黑树一样，也是**O(logn)**



## 代码

**注意 派生类(HeadNode) 转换为 基类< Node>**

### 节点定义

只有头结点  存储 层数

```c++
private:
	// 普通节点类型
	struct Node
	{
		Node(int data = int())
			: data_(data)
			, next_(nullptr)
			, down_(nullptr)
		{}
		int data_;     // 数据域
		Node* next_;   // 指向同一层后一个节点的指针域
		Node* down_;   // 指向下一层相同节点的指针域
	};

	// 跳跃表的头节点类型
	struct HeadNode : public Node
	{
		HeadNode(int level)
			: level_(level)
		{}
		int level_; // 跳跃表的层数
	};

private:
	HeadNode* head_;   // 指向跳表最上面一层链表的头节点


```





### 构造

```c++
public:
	SkipList()
	{
		head_ = new HeadNode(1);
	}
```





### 搜索查找

```c++
// 搜索数据
bool find(int data)
{
	Node* pre = head_;
	Node* cur = pre->next_;

	for (;;)
	{
		if (cur != nullptr)
		{
			if (cur->data_ < data)
			{
				pre = cur;
				cur = cur->next_;
				continue;
			}
			else if (cur->data_ == data)
			{
				return true;
			}
		}

		// cur == nullptr了
		if (pre->down_ == nullptr)
		{
			// pre和cur已经遍历到第一层的末尾了
			break;
		}

		pre = pre->down_;   // 只有大于了, 才会到这里,可以进入下一层
		cur = pre->next_;
	}
	return false;
}
```





### 析构

一层一层删,  先不要动头结点, 把头结点 后面的 删了, 最后删除 头结点,  删除前 , 保存 下一层的 头结点







```c++
~SkipList()
{
	int level = head_->level_;
	for (int i = 0; i < level; i++)
	{
		Node* cur = head_->next_;
		while (cur != nullptr)
		{
			Node* tmp = cur->next_;
			delete cur;
			cur = tmp;
		}
		cur = head_;
		head_ = static_cast<HeadNode*>(head_->down_);
		delete cur;
	}
}
```





### 添加数据

**插入思想:**

1. 数据存在 则不添加
2. 数据不存在:
   1. 先定好要 插入的 第一个层, 使用随机选择
   2. 如果大于当前层, 仅需要新建一层, 新建头结点, 
   3. 由于从选择的 层开始, 后续层 都需要 加这个元素, 因此 **使用数组 存储 多个层的 节点指针**---->  就是 先生成 数据一样, 指针不一样的 多个节点, 然后 一个个选出来 插入即可



```c++
// 添加数据
void add(int data)
{
	// 先查找数据是否存在
	if (find(data))
		return;

	// 抛硬币，data数据添加几层
	int level = getLevel();
	if (level > head_->level_)
	{
		// level过大时，SkipList只增长一层
		level = head_->level_ + 1;
		HeadNode* hnode = new HeadNode(level);
		hnode->down_ = head_;
		head_ = hnode;
	}

	// 先创建level层的data节点(level长度的数组)，修改down指针域
	Node** nodeList = new Node * [level];

	// 这个数组 下标和 跳跃表的 层 是反过来的
	// 只有
	for (int i = level - 1; i >= 0; i--)
	{
		nodeList[i] = new Node(data);

		// 下标最后一个, 在 层数里是 第一层
		if (i < level - 1)
		{
			// 上面节点的down指针域，存储下面节点的地址
			nodeList[i]->down_ = nodeList[i + 1];
		}
	}

	Node* head = head_;
	for (int i = head_->level_; i > level; i--)
	{
		head = head->down_;
	}

	// head就指向了要插入节点的链表了

	Node* pre = head;   // 从 高层开始插入
	Node* cur = pre->next_;

	for (int i = 0; i < level; i++)  //这个i是数组下标, 不要理解成层数, 和层数相反
	{
		while (cur != nullptr && cur->data_ < data)
		{
			pre = cur;
			cur = cur->next_;
		}

		// 新节点插入到pre和cur的中间
		nodeList[i]->next_ = cur;
		pre->next_ = nodeList[i];

		pre = pre->down_; // 进入下一层(跳跃表的性质, 可以直接进入下一层, 不需要再从头结点查找)
		if (pre != nullptr)
			cur = pre->next_;
	}

	delete[]nodeList; // 释放临时的 一维数组, 不释放 内部
	nodeList = nullptr;
}
```





```c++
private:
	int getLevel() const
	{
		int level = 1;
		while (rand() % 2 == 1)   // 需要搭配 srand
			level++;
		return level;
	}
```



### 打印

```c++
// 打印
void show() const
{
	Node* head = head_;
	while (head != nullptr)
	{
		Node* cur = head->next_;
		while (cur != nullptr)
		{
			cout << cur->data_ << " ";
			cur = cur->next_;
		}
		cout << endl;
		head = head->down_;
	}
	cout << endl;
}
```





### 删除--比红黑树好太多



从最高层开始

找到就删除, 没找到就去下一层, 

第一层  没有 就 break



如果只有一层, 只有删除的 那个节点,  该层则需要全部删除







```c++
// 删除数据
void remove(int data)
{
	Node* pre = head_;
	Node* cur = pre->next_;

	for (;;)
	{
		if (cur != nullptr)
		{
			if (cur->data_ < data)
			{
				pre = cur;
				cur = cur->next_;
				continue;
			}
			else if (cur->data_ == data)
			{
				// 删除cur指向的节点
				pre->next_ = cur->next_;
				delete cur;
			}
		}

		if (pre->down_ == nullptr)
		{
			break;
		}

		pre = pre->down_;
		// cur == nullptr 当前层没有data节点
		if (head_->next_ == nullptr)
		{
			delete head_;
			head_ = static_cast<HeadNode*>(pre);
		}
		cur = pre->next_;
	}
}
```





# 5.倒排索引-pdf

## 基础理论

1.  常用于 **搜索引擎**中
2. 名词术语-----pdf 看看





## 倒排索引应用场景--教学图片

1. 浏览器的 搜索引擎

   ![image-20250414165249217](./2-数据结构(五大算法之后).assets/倒排索引-1.png)

2. 搜索服务 - 电商---数据海量

   不使用   Mysql

   而是使用 全文搜索引擎----**solr, elasticsearch**--使用了 倒排索引

   ![image-20250414165413453](./2-数据结构(五大算法之后).assets/倒排索引-2.png)

3. **正排索引** 和 **倒排索引**   ----->   就是  **行列相反**

   正排索引：从“文档”出发，记录有哪些词。
    倒排索引：从“词”出发，记录出现在哪些文档中。

4. 你想找所有包含 "天气" 的文章。

   - **正排索引做法**：遍历每个文档，看词表里有没有“天气”。（效率低）
   - **倒排索引做法**：直接查“天气”对应的文档列表即可！（效率高）

5. 倒排索引  可以记录 额外的信息

   1. 打分,  出现或者访问的越多, 分越高
   2. 位置, 在文档中的位置,  第几个单词
   3. 在位置的  第几行



![image-20250414172154489](./2-数据结构(五大算法之后).assets/倒排索引-3.png)



## 倒排索引结构

1. 词典:   单词
2. 倒排项: 单词所在某个文件的 文档的信息
3. 倒排列表: 由很多 倒排项组成----每个单词 都有一个 倒排列表
4. 倒排文件: 所有倒排列表的 集合
5. **倒排索引 = 词典 + 倒排文件**

本文所讲的 都是 **内存索引** 的 倒排索引的存储





![image-20250414173040574](./2-数据结构(五大算法之后).assets/倒排索引-4.png)





![image-20250414174349729](./2-数据结构(五大算法之后).assets/倒排索引-5.png)





## 实现本地搜索引擎代码

整体写代码 时, 先把  大的 成员变量定义好(private里的)

### 构建倒排项-图里的p

在每个 **出现的文档**里 添加了 **出现次数**, **出现位置**



使用list  存储 出现的 所有位置



```c++
// 倒排项
struct InvertTerm
{
	InvertTerm(string docid, int freqs, int location)
		: docid_(docid)
		, freqs_(freqs)
	{
		locations_.emplace_back(location);
	}
	bool operator==(const InvertTerm& term) const
	{
		return docid_ == term.docid_;
	}
	bool operator<(const InvertTerm& term) const
	{
		return docid_ < term.docid_;
	}
	string docid_;        // 单词所在的文档
	int freqs_;           // 单词出现的次数
	list<int> locations_; // 单词出现的位置
};
```



### 构建倒排列表-图里的p1,p2..

倒排列表 是 **所有倒排项的集合**,   使用  list 存储 每一个 倒排项



倒排列表里,  需要实现:
**1. 添加倒排项**

**2. 获得  倒排列表**





```c++
// 倒排列表
class InvertList
{
public:
	// 添加倒排项   #2
	void addTerm(string docid, int location)
	{
		for (auto& term : termList_)
		{
			if (term.docid_ == docid) // docid已经创建了
			{
				term.freqs_++;
				term.locations_.emplace_back(location);
				return; //本次添加完毕
			}
		}

		// 第一次创建docid文档的倒排项
		termList_.emplace_back(docid, 1, location);
	}

	// 获取倒排列表内容
	const list<InvertTerm>& getInvertList() const
	{
		return termList_;
	}
    
private:     //#1
	list<InvertTerm> termList_;  // 存储当前倒排列表所有的倒排项
};
```





### 构建倒排索引



**倒排索引 = 词典 + 倒排文件**---使用  map  存储  键值对



每个map里,  <单词, 倒排列表>



```c++
unordered_map<string, InvertList> invertMap_; // 词典+倒排列表 


```





希望用户 传入一个 文件夹路径, 在这个文件夹里 搜索,  因此 倒排索引 加入一个 对应接口

```c++
private:
	list<string> fileList_;  // 存储所有需要建立倒排的文件


public:
	// 设置文档搜索的根路径
void setSearchPath(string path)
{
	cout << "搜索文件...";
	getAllFile(path.c_str());
	cout << "完成!" << endl;

	cout << "开始创建倒排索引";
	createInvertIndex();
	cout << "完成!" << endl;
}
```



由于 这是 win里面的 环境, java什么的 提供了 搜索文件 函数

但是 c++ 没有, 还是需要 调用系统 api----老师直接给的完整代码

必须加 UNICODE :   win里 都是 宽字节字符,  本地传的 都是单字节字符



这段是 win的 系统 api,  先不了解



```c++
#undef UNICODE   
#include <Windows.h>

private:
// 递归扫描路径下面所有的文件
int getAllFile(const char* Path)
{
	char szFind[MAX_PATH];
	WIN32_FIND_DATA FindFileData;
	strcpy(szFind, Path);
	strcat(szFind, "\\*.*");
	HANDLE hFind = FindFirstFile(szFind, &FindFileData);
	if (INVALID_HANDLE_VALUE == hFind)
		return -1;

	do
	{
		if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			if (strcmp(FindFileData.cFileName, ".") != 0 && strcmp(FindFileData.cFileName, "..") != 0)
			{
				//发现子目录，递归之
				char szFile[MAX_PATH] = { 0 };
				strcpy(szFile, Path);
				strcat(szFile, "\\");
				strcat(szFile, FindFileData.cFileName);
				getAllFile(szFile);
			}
		}
		else
		{
			//找到文件，处理之
			string fileName(FindFileData.cFileName);
			int pos = fileName.find(suffix_);  // abcd.cpp   pos:4 +4 
			if (pos != string::npos && pos + suffix_.size() == fileName.size())
			{
				// std::cout << Path << "\\" << FindFileData.cFileName << std::endl;
				string filePath(Path);
				filePath.append("\\");
				filePath.append(fileName);
				fileList_.emplace_back(filePath);
			}
		}
	} while (FindNextFile(hFind, &FindFileData));

	FindClose(hFind);

	return 0;
}
```





### `npos` 是什么？

string.find("")   --->  找不到, 就返回  string::npos  这个静态 常量

- `npos` 是 `string` 类的一个**静态常量**，表示一个无效的位置。
- 本质上是个超大的无符号数（通常是 `-1` 转成 `size_t`）。
- 所以你永远不会在有效字符串中见到 `npos` 是正常的索引。



### 创建倒排索引结构--核心

按照空格分词:  split(c/c++里没有 这个接口) ,  strtok(c的, 但是需要 多次调用)





```c++
private:
	// 创建倒排索引结构
	void createInvertIndex()
	{
		for (string& filePath : fileList_)
		{
			cout << ".";
			FILE* pf = fopen(filePath.c_str(), "r");
			if (pf == nullptr)
			{
				cerr << filePath << " ......打开失败！" << endl;
				continue;
			}

			// 按行读取文件里面的内容，按照" "空格进行分词
			vector<string> wordList;
			int location = 0; // 位置信息
			const int LINE_SIZE = 2048;
			char line[LINE_SIZE] = { 0 };

			while (!feof(pf))  // feof(pf) 表示文件是否读完
			{
				// 读一行文件内容
				fgets(line, LINE_SIZE, pf);

				// 按照" "空格进行分词 split   strtok
				char* word = strtok(line, " ");
				while (word != nullptr)
				{
					// 过滤一下word前后的多余的空格  \t  \n
					word = trim(word);
					if (strlen(word) > 0)
					{
						wordList.emplace_back(word);
					}
					word = strtok(nullptr, " ");
				}

				// 开始给wordList里面的单词创建或者修改倒排列表
				for (string& w : wordList)
				{
					location++;
					auto it = invertMap_.find(w);   //map
					if (it == invertMap_.end())
					{
						// 新建w单词的倒排列表
						InvertList list;
						list.addTerm(filePath, location);
						invertMap_.emplace(w, list); // insert 需要{}
					}
					else
					{
						it->second.addTerm(filePath, location);
					}
				}
			}

			fclose(pf);
		}
	}
```





```c++
// 去掉分词后  单词前后多余的字符 \t\t\tsdfads\t\n
char* trim(char* word)
{
	int i = 0;
	while (word[i] != '\0')
	{
		if (word[i] == ' ' || word[i] == '\t' || word[i] == '\n')
		{
			i++;
		}
		else
		{
			break;
		}
	}

	int j = i;
	while (word[j] != '\0')
	{
		if (word[j] == ' ' || word[j] == '\t' || word[j] == '\n')
		{
			break;
		}
		j++;
	}
	word[j] = '\0';

	return word + i;
}
```







### 查询接口

传入一个 句子, 查询 



注意里面 有一个 客户端 拦截就可以实现的 

查询单个单词的 版本:



```c++
	// 查询接口
	void query(string phrase)
	{
		// 先进行句子分词操作
		vector<string> wordList;
		char* word = strtok(const_cast<char*>(phrase.c_str()), " ");
		while (word != nullptr)
		{
			word = trim(word);
			if (strlen(word) > 0)
			{
				wordList.emplace_back(word);
			}
			word = strtok(nullptr, " ");
		}

		if (wordList.empty())   // 这段在 实际 做产品时,  在客户端就处理掉,  客户端处  发现 用户没有填写, 就拦截了
			return;
		if (wordList.size() == 1)
		{
			auto it = invertMap_.find(wordList[0]);
			if (it == invertMap_.end())
			{
				cout << "未搜索到任何匹配的内容!" << endl;
				return;
			}

			for (auto& term : it->second.getInvertList())
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
			}
		}
		
```







进行 句子 查询:  ----> 多单词----> 求交集

使用了 **泛型算法 求交集** :   -->  **必须有序 **       `std::set_intersection`

`std::set_intersection` 是一个专门用于求**两个排序好**的集合交集的算法。它需要输入两个**已经排序的容器**，并将**交集的结果输出到一个目标容器中**。

```c++
#include <algorithm>

```



为了 比较 倒排项, 因此 要么 在倒排项里 写 运算符重载,  要么 传一个 函数对象,  本课程, 老师 是写了 运算符重载







```c++
	// 查询接口
	void query(string phrase)
	{
		// 先进行句子分词操作
		vector<string> wordList;
		char* word = strtok(const_cast<char*>(phrase.c_str()), " ");
		while (word != nullptr)
		{
			word = trim(word);
			if (strlen(word) > 0)
			{
				wordList.emplace_back(word);
			}
			word = strtok(nullptr, " ");
		}

		if (wordList.empty())   // 这段在 实际 做产品时,  在客户端就处理掉,  客户端处  发现 用户没有填写, 就拦截了
			return;

		if (wordList.size() == 1)
		{
			auto it = invertMap_.find(wordList[0]);
			if (it == invertMap_.end())
			{
				cout << "未搜索到任何匹配的内容!" << endl;
				return;
			}

			for (auto& term : it->second.getInvertList())
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
			}
		}
		else
		{
			// 多个单词的搜索结果进行合并处理
			vector<InvertList> invertList;
			for (int i = 0; i < wordList.size(); i++)
			{
				// invertList.emplace_back(invertMap_[wordList[i]]);
				auto it = invertMap_.find(wordList[i]);
				if (it != invertMap_.end())
				{
					invertList.emplace_back(it->second);
				}
			}

			// 开始遍历所有的倒排列表，求里面倒排项的交集
			vector<InvertTerm> termShared;
			vector<InvertTerm> v1(invertList[0].getInvertList().begin(),
				invertList[0].getInvertList().end());
			for (int i = 1; i < invertList.size(); i++)
			{
				vector<InvertTerm> v2(invertList[i].getInvertList().begin(),
					invertList[i].getInvertList().end());

				sort(v1.begin(), v1.end());
				sort(v2.begin(), v2.end());

				// 求两个倒排列表里面倒排项的交集
				// set_intersection求集合交集时，必须保证v1和v2是有序的
				set_intersection(v1.begin(), v1.end(),
					v2.begin(), v2.end(),
					back_inserter(termShared));

				v1.swap(termShared);  // 最后 放入 v1 里
				termShared.clear();
			}

			// 得分排名比较高的倒排项
			for (auto& term : v1)
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
				cout << "locations:";
				/*for (int pos : term.locations_)
				{
					cout << pos << " ";
				}
				cout << endl;*/
			}

			// 把出现部分单词的倒排项内容打印出来

		}
	}
```





### 汇总

```c++
#include <iostream>
#include <string>
#include <list>
#include <unordered_map>
#include <algorithm>
using namespace std;

#undef UNICODE
#include <Windows.h>




// 倒排项
struct InvertTerm
{
	InvertTerm(string docid, int freqs, int location)
		: docid_(docid)
		, freqs_(freqs)
	{
		locations_.emplace_back(location);
	}
	bool operator==(const InvertTerm& term) const
	{
		return docid_ == term.docid_;
	}
	bool operator<(const InvertTerm& term) const
	{
		return docid_ < term.docid_;
	}
	string docid_;        // 单词所在的文档
	int freqs_;           // 单词出现的次数
	list<int> locations_; // 单词出现的位置
};

// 倒排列表
class InvertList
{
public:
	// 添加倒排项   #2
	void addTerm(string docid, int location)
	{
		for (auto& term : termList_)
		{
			if (term.docid_ == docid) // docid已经创建了
			{
				term.freqs_++;
				term.locations_.emplace_back(location);
				return; //本次添加完毕
			}
		}

		// 第一次创建docid文档的倒排项
		termList_.emplace_back(docid, 1, location);
	}

	// 获取倒排列表内容
	const list<InvertTerm>& getInvertList() const
	{
		return termList_;
	}

private:     //#1
	list<InvertTerm> termList_;  // 存储当前倒排列表所有的倒排项
};


// 倒排索引
class InvertIndex
{
public:
	// 设置文档搜索的根路径
	void setSearchPath(string path)
	{
		cout << "搜索文件...";
		getAllFile(path.c_str());
		cout << "完成!" << endl;

		cout << "开始创建倒排索引";
		createInvertIndex();
		cout << "完成!" << endl;
	}


	// 设置文档搜索的后缀名过滤
	void setSuffix(string suffix)
	{
		suffix_ = suffix;
	}

	// 查询接口
	void query(string phrase)
	{
		// 先进行句子分词操作
		vector<string> wordList;
		char* word = strtok(const_cast<char*>(phrase.c_str()), " ");
		while (word != nullptr)
		{
			word = trim(word);
			if (strlen(word) > 0)
			{
				wordList.emplace_back(word);
			}
			word = strtok(nullptr, " ");
		}

		if (wordList.empty())   // 这段在 实际 做产品时,  在客户端就处理掉,  客户端处  发现 用户没有填写, 就拦截了
			return;

		if (wordList.size() == 1)
		{
			auto it = invertMap_.find(wordList[0]);
			if (it == invertMap_.end())
			{
				cout << "未搜索到任何匹配的内容!" << endl;
				return;
			}

			for (auto& term : it->second.getInvertList())
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
			}
		}
		else
		{
			// 多个单词的搜索结果进行合并处理
			vector<InvertList> invertList;
			for (int i = 0; i < wordList.size(); i++)
			{
				// invertList.emplace_back(invertMap_[wordList[i]]);
				auto it = invertMap_.find(wordList[i]);
				if (it != invertMap_.end())
				{
					invertList.emplace_back(it->second);
				}
			}

			// 开始遍历所有的倒排列表，求里面倒排项的交集
			vector<InvertTerm> termShared;
			vector<InvertTerm> v1(invertList[0].getInvertList().begin(),
				invertList[0].getInvertList().end());
			for (int i = 1; i < invertList.size(); i++)
			{
				vector<InvertTerm> v2(invertList[i].getInvertList().begin(),
					invertList[i].getInvertList().end());

				sort(v1.begin(), v1.end());
				sort(v2.begin(), v2.end());

				// 求两个倒排列表里面倒排项的交集
				// set_intersection求集合交集时，必须保证v1和v2是有序的
				set_intersection(v1.begin(), v1.end(),
					v2.begin(), v2.end(),
					back_inserter(termShared));

				v1.swap(termShared);  // 最后 放入 v1 里
				termShared.clear();
			}

			// 得分排名比较高的倒排项
			for (auto& term : v1)
			{
				cout << term.docid_ << " freqs:" << term.freqs_ << endl;
				cout << "locations:";
				/*for (int pos : term.locations_)
				{
					cout << pos << " ";
				}
				cout << endl;*/
			}

			// 把出现部分单词的倒排项内容打印出来

		}
	}


private:
	// 创建倒排索引结构
	void createInvertIndex()
	{
		for (string& filePath : fileList_)
		{
			cout << ".";
			FILE* pf = fopen(filePath.c_str(), "r");
			if (pf == nullptr)
			{
				cerr << filePath << " ......打开失败！" << endl;
				continue;
			}

			// 按行读取文件里面的内容，按照" "空格进行分词
			vector<string> wordList;
			int location = 0; 
			const int LINE_SIZE = 2048;
			char line[LINE_SIZE] = { 0 };

			while (!feof(pf))
			{
				// 读一行文件内容
				fgets(line, LINE_SIZE, pf);

				// 按照" "空格进行分词 split   strtok
				char* word = strtok(line, " ");
				while (word != nullptr)
				{
					// 过滤一下word前后的多余的空格  \t  \n
					word = trim(word);
					if (strlen(word) > 0)
					{
						wordList.emplace_back(word);
					}
					word = strtok(nullptr, " ");
				}

				// 开始给wordList里面的单词创建或者修改倒排列表
				for (string& w : wordList)
				{
					location++;
					auto it = invertMap_.find(w);
					if (it == invertMap_.end())
					{
						// 新建w单词的倒排列表
						InvertList list;
						list.addTerm(filePath, location);
						invertMap_.emplace(w, list);
					}
					else
					{
						it->second.addTerm(filePath, location);
					}
				}
			}

			fclose(pf);
		}
	}

	// 去掉分词后  单词前后多余的字符 \t\t\tsdfads\t\n
	char* trim(char* word)
	{
		int i = 0;
		while (word[i] != '\0')
		{
			if (word[i] == ' ' || word[i] == '\t' || word[i] == '\n')
			{
				i++;
			}
			else
			{
				break;
			}
		}

		int j = i;
		while (word[j] != '\0')
		{
			if (word[j] == ' ' || word[j] == '\t' || word[j] == '\n')
			{
				break;
			}
			j++;
		}
		word[j] = '\0';

		return word + i;
	}

	 

	// 递归扫描路径下面所有的文件
	int getAllFile(const char* Path)
	{
		char szFind[MAX_PATH];
		WIN32_FIND_DATA FindFileData;
		strcpy(szFind, Path);
		strcat(szFind, "\\*.*");
		HANDLE hFind = FindFirstFile(szFind, &FindFileData);
		if (INVALID_HANDLE_VALUE == hFind)
			return -1;

		do
		{
			if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				if (strcmp(FindFileData.cFileName, ".") != 0 && strcmp(FindFileData.cFileName, "..") != 0)
				{
					//发现子目录，递归之
					char szFile[MAX_PATH] = { 0 };
					strcpy(szFile, Path);
					strcat(szFile, "\\");
					strcat(szFile, FindFileData.cFileName);
					getAllFile(szFile);
				}
			}
			else
			{
				
				//找到文件，处理之
				string fileName(FindFileData.cFileName);
				int pos = fileName.find(suffix_);  // abcd.cpp   pos:4 +4 
				if (pos != string::npos && pos + suffix_.size() == fileName.size())
				{
					//std::cout << Path << "\\" << FindFileData.cFileName << std::endl;
					string filePath(Path);
					filePath.append("\\");
					filePath.append(fileName);
					fileList_.emplace_back(filePath);
				}
			}
		} while (FindNextFile(hFind, &FindFileData));

		FindClose(hFind);

		return 0;
	}




private:
	string suffix_;  // 过滤文档后缀   .cpp .cc .cxx .c
	list<string> fileList_;  // 存储所有需要建立倒排的文件
	unordered_map<string, InvertList> invertMap_; // 词典+倒排列表 
};



int main()
{
	InvertIndex index;
	index.setSuffix(".cpp");
	index.setSearchPath("C:\\Users\\hzh\\Desktop\\Cpp学习大全\\1-自学笔记\\3-施磊c++笔记-汇总\\施磊树结构笔记\\C++全套数据结构算法代码");

	for (;;)
	{
		char buf[128] = { 0 };
		cout << "搜索内容:";
		cin.getline(buf, 128);

		index.query(buf);  // grep
	}

	cout << endl;
	return 0;
}
```

























# 6.哈夫曼树和哈夫曼编码--后续看

## 基础理论-pdf

1. **带权路径长度**最短的二叉树
2. 常用于数据压缩
3. **树的带权路径长度**: 就是树中**所有的叶子节点的权值乘以 其到根节点的路径长度**





主要解决的问题:   

怎么基于这组权值构建一颗最佳判定树、最优二叉树、哈夫曼树（huffmanTree）带权路径长度可以达到



![image-20250415143126201](./2-数据结构(五大算法之后).assets/hafuman-1.png)





技巧:  使用**最小堆**,  就可以拿到 每次 序列里 最小的值





## 哈夫曼编码性质



1. 不同于ASCII和Unicode这些字符编码,  这些字符集中的码长都采用的是长度相同的编码
2. 哈夫曼编码使用的是变长编码
3. 满足**立刻可解码性**（就是说任一字符的编码都**不会是**另一个更长字符编码的**前缀**）

![image-20250415162243464](./2-数据结构(五大算法之后).assets/hafuman-2.png)

## 哈夫曼树与哈夫曼编码代码

### 节点定义

```c++
public:
	HuffmanTree()
		: minHeap_([](Node* n1, Node* n2)->bool
			{return n1->weight_ > n2->weight_; })
		, root_(nullptr)
	{}



private:
	struct Node
	{
		Node(char data, uint weight)
			: data_(data)
			, weight_(weight)
			, left_(nullptr)
			, right_(nullptr)
		{}

		char data_;   // 字符数据
		uint weight_; // 节点的权值
		Node* left_;  // 指向左孩子节点
		Node* right_; // 指向右孩子节点
	};


private:
	Node* root_; // 指向根节点
	unordered_map<char, string> codeMap_; // 存储字符对应的哈夫曼编码

	using MinHeap = priority_queue<Node*, vector<Node*>, function<bool(Node*, Node*)>>;
	MinHeap minHeap_;
```





### 创建哈夫曼树-create接口



传入  字符串,  进行创建



**用 map  很简单的  统计权值**





灵魂:

```c++
// 生成父节点
Node* node = new Node('\0', n1->weight_ + n2->weight_);

```



create()

```c++
// 创建哈夫曼树
void create(string str)
{
	// 先统计字符的权值
	unordered_map<char, uint> dataMap;
	for (char ch : str)
	{
		dataMap[ch]++;
	}

	// 生成节点，放入小根堆中
	for (auto& pair : dataMap)
	{
		minHeap_.push(new Node(pair.first, pair.second));
	}

	while (minHeap_.size() > 1)
	{
		// 获取两个权值最小的
		Node* n1 = minHeap_.top();
		minHeap_.pop();

		Node* n2 = minHeap_.top();
		minHeap_.pop();

		// 生成父节点
		Node* node = new Node('\0', n1->weight_ + n2->weight_);
		node->left_ = n1;
		node->right_ = n2;

		minHeap_.push(node);
	}

	root_ = minHeap_.top();
	minHeap_.pop();
}
```



### 输出哈夫曼编码





```c++
// 输出哈夫曼编码
void getHuffmanCode()
{
	string code;
	getHuffmanCode(root_, code);

	/*for (auto& pair : codeMap_)   // 测试
	{
		cout << pair.first << " : " << pair.second << endl;
	}
	cout << endl;*/
}

void getHuffmanCode(Node* root, string code)
{
	// VLR
	if (root->left_ == nullptr && root->right_ == nullptr)
	{
		codeMap_[root->data_] = code;
		return;
	}

	getHuffmanCode(root->left_, code + "0");
	getHuffmanCode(root->right_, code + "1");
}

```







### 数据压缩  与 解压缩



```c++

// encode
string encode(string str)
{
	getHuffmanCode();

	string encode_str; 
	for (char ch : str)
	{
		encode_str.append(codeMap_[ch]);
	}
	return encode_str;
}
```





注意解码的思想:   
利用完成的 哈夫曼树,  从根节点开始遍历,  另一边 从encode 里 遍历,  遇到字符0, 左走, 遇到 字符1, 右走

到达 叶子结点,  就是解码出来 一个字符了

然后, 继续 从根节点 开始,  另一边 则 接着 上次位置,  继续解码

```c++
// decode
string decode(string encode)
{
	string decode_str;
	Node* cur = root_;

	for (char ch : encode)
	{
		if (ch == '0')
		{
			cur = cur->left_;
		}
		else
		{
			cur = cur->right_;
		}

		if (cur->left_ == nullptr && cur->right_ == nullptr)
		{
			decode_str.push_back(cur->data_);
			cur = root_;
		}
	}
	return decode_str;
}
```





这段代码 缺少 析构, 要注意, 层序遍历 释放

## 总结



为什么 压缩后的 有时候(小文件会出现) 反而更大了?







![image-20250415170540575](./2-数据结构(五大算法之后).assets/hafuman-3.png)















# 7.图

## 基础理论-教学图片+pdf



1. 名词: **顶点, 边,  出边, 入边, 度, 出度, 入度**

2. 有向图和 无向图 

   无向图 没有 出边和 入边 这个概念

   无向图 不能 自己到自己

3. 图的表示方式: **邻接矩阵   和  邻接表**

   有向图 **更好的**  还有  **十字链表**

   无向图 **更好的**  还有 **邻接多重表(边列表)**

![image-20250411113603882](./2-数据结构(五大算法之后).assets/图-1.png)

## 邻接矩阵

指的是   直达



![image-20250411120723129](./2-数据结构(五大算法之后).assets/图-2.png)



倒排索引

## 邻接表



结构和 链式哈希 一样,



邻接表(出度) 和  逆邻接表(入度)

**缺点: ** 就是  出入度 无法 直接得到, 每种邻接表   只能得到一种度



**无向图 的  邻接表,  还会 导致 冗余 存储**



![image-20250411122058637](./2-数据结构(五大算法之后).assets/图-3.png)





## 十字链表--有向图



要明白, 插入 一个 节点时,  一共做了哪些事



节点结构:

1. 顶点 新增了 firstin
2. 边表节点  新增了 tailvex, hlink





通俗来讲:   **顶点** 有了 **所有 出边** 和  **所有 入边**,   **边表节点** 有了 边的 **起点和终点**(节点数据域) 信息, 还有 **同起点的 其他边**(节点指针域 -链表),  **同终点的 其他边**(节点指针域 -链表)





![image-20250411134725934](./2-数据结构(五大算法之后).assets/图-4.png)



## 邻接多重表(变列表)--无向图

mark  一般 是用于 表示 该顶点 是否被记录过



![image-20250411144622049](./2-数据结构(五大算法之后).assets/图-5.png)





## 深度-广度优先遍历-图-理论

广度遍历 需要借助 队列----> 可以参考 树的 广度遍历



深度优先相当于  树的 前序遍历





## 有向图邻接表-代码

这个代码呢,  给 顶点 都编号了, 节点数据域 存储 **顶点实际字符**

邻接表里, 使用  **字符的编号** 表示 连接了 哪些顶点 

同时 使用了 大量容器, 不需要手动维护



### 节点结构

```c++
private:
	// 顶点类型
	struct Vertic
	{
		Vertic(string data)
			: data_(data)
		{
		}
		string data_;       // 存储顶点的信息
		list<int> adjList_; // 邻接链表结构
	};

private:
	vector<Vertic> vertics; // 邻接表结构
```



### 从配置文件读取图的信息

可以试着 把 读文件 用 c++ 风格写一下, std::fstream



vector.back()访问最后一个元素, 但是必须  **保证 vector 非空, 否则 会报错**



atoi--> ascii to int   不安全, c风格



```c++
// 从配置文件读入顶点和边的信息，生成邻接表
void readFile(string filePath)
{
	// fopen 传入的是 const char*
	// c_str----string 转换成 const char*
	FILE* pf = fopen(filePath.c_str(), "r");
	if (pf == nullptr)
	{
		throw filePath + " not exists!";
	}

	// 占用第0号位置,  让 图从 1 开始
	vertics.emplace_back("");

	while (!feof(pf))
	{
		char line[1024] = { 0 };
		fgets(line, 1024, pf);
		// 增加一个节点信息
		string linestr(line);
		vertics.emplace_back(linestr.substr(0, linestr.size() - 1));  // 只读一个, 不然会有换行符 \n

		fgets(line, 1024, pf);
		char* vertic_no = strtok(line, ",");
		while (vertic_no != nullptr)
		{
			int vex = atoi(vertic_no);
			if (vex > 0) // 细节处理, 下标必须大于0, 感觉还能加一个 小于, 不过这会由于 元素没加完, 得不到最终的 长度
			{
				vertics.back().adjList_.emplace_back(vex);
			}
			vertic_no = strtok(nullptr, ",");// 这是strtok继续分割,  注意 要会用
		}
	}

	fclose(pf);
}
```





### 输出打印邻接表

```c++
// 输出邻接表信息
void show() const
{
	for (int i = 1; i < vertics.size(); i++)  // 不用foreach, 不打印 第一个
	{
		cout << vertics[i].data_ << " : ";
		for (auto no : vertics[i].adjList_)
		{
			cout << no << " ";
		}
		cout << endl;
	}
	cout << endl;
}
```





### 有向图 深度优先遍历

```c++
// 图的深度优先遍历
void dfs()
{
	vector<bool> visited(vertics.size(), false); // vector初始化, 指定大小和指定默认值
	dfs(1, visited);  // 1是下标
	cout << endl;
}
```





```c++
// 深度优先遍历的递归接口
void dfs(int start, vector<bool>& visited)   // start是下标
{
	// 该start顶点已经遍历过了
	if (visited[start])
	{
		return;
	}

	cout << vertics[start].data_ << " ";
	visited[start] = true;

	// 递归遍历下一层节点
	for (auto no : vertics[start].adjList_)
	{
		dfs(no, visited);
	}
}
```







### 有向图广度优先

队列实现



```c++
// 广度优先遍历
void bfs()
{
	vector<bool> visited(vertics.size(), false);
	queue<int> que;

	que.push(1);
	visited[1] = true;

	while (!que.empty())
	{
		int cur_no = que.front();  // 编号
		que.pop();

		cout << vertics[cur_no].data_ << " ";

		for (auto no : vertics[cur_no].adjList_)
		{
			if (!visited[no])
			{
				que.push(no);
				visited[no] = true;
			}
		}
	}
	cout << endl;
}
```







# 图的最短路径算法

## 不带权值的最短路径算法-有向图-广度

**注意:  这是 不带权值, 面试要注意**



**利用广度优先遍历**-----广度优先的  一个 典型应用场景



**每个 顶点记录一下  从哪个顶点 过来的-**---> 也就是 在上面广度优先的 基础上, 再**额外 建立一个 数组**, 标识 这个



直接在 广度 优先的 代码上进行修改即可



```c++
// 求不带权值的最短路径问题 - 广度优先遍历
void shortPath(int start, int end)   // 传入的是要寻找的最短路径的 起始 和 终点, 
{
	vector<bool> visited(vertics.size(), false);
	queue<int> que;
	// 记录顶点在遍历过程中的前后遍历关系----修改1
	vector<int> path(vertics.size(), 0);

	que.push(start);
	visited[start] = true;

	while (!que.empty())
	{
		int cur_no = que.front();
		if (cur_no == end  // 修改-3   到终点, 就退出
		{
			// 找到end末尾节点
			break;
		}
		que.pop();

		//cout << vertics[cur_no].data_ << " ";

		for (auto no : vertics[cur_no].adjList_)
		{
			if (!visited[no])
			{
				que.push(no);
				visited[no] = true;
				// 当前节点处，记录是从哪一个节点过来的  --- 修改2
				path[no] = cur_no;
			}
		}
	}
	
    // 修改-4        
	if (!que.empty())
	{
		// 存在一条最短路径，怎么输出？
		/*while (end != 0) // 从后往前 打印的
		{
			cout << vertics[end].data_ << " <= ";
			end = path[end];  // 回到上一个 点的 编号
		}*/
		showPath(end, path);  // 正向输出, 递到第一个, 再往后打印
	}
	else
	{
		cout << "不存在有效的最短路径!" << endl;
	}
	cout << endl;
}
```





封装的  **正向打印** 路径的  函数---递归



```c++
// 输出最短路径信息
void showPath(int end, vector<int>& path)
{
	if (end == 0)  // 已经回溯到起始节点了
		return;

	showPath(path[end], path);
	cout << vertics[end].data_ << " ";
}
```





## Dijkstra最短路径-有权值

**贪心算法的  典型应用场景-----单源最短路径**



迪杰斯特拉算法应用---导航,送餐等



具体 概念和 例子------->  参考 教学图片





**重大缺陷---不能处理 负权边**---下面这个例子:
a到b 的 最短应该是  6-3=3,  不是4

但是由于 集合 是先处理 B, 导致 得不到 最优

其根本在于--->  **有了 负权边, 局部最优就不是 整体最优了**





![image-20250411184356547](./2-数据结构(五大算法之后).assets/图-6.png)





## Dijkstra代码-手撕

跟地图有关的,  面试 可能会 手撕



### main



```c++
using uint = unsigned int;
const uint INF = INT_MAX;  // 使用无符号类型, 是便于 INF还可以进行相加, 防止越界

```

INT_MAX----> 是一个宏, 有符号树 最大值  21亿左右



使用 二维数组, 存储一个 有权值的 的图



```c++
vector<vector<uint>> graph =
{
	{0, 6, 3, INF, INF, INF},
	{6, 0, 2, 5, INF, INF},
	{3, 2, 0, 3, 4, INF},
	{INF, 5, 3, 0, 2, 3},
	{INF, INF, 4, 2, 0, 5},
	{INF, INF, INF, 3, 5, 0},
};
```





### Dijkstra函数

注意,  从老师讲的 来看,  S集合 存放的是 已确定的最短距离 的节点,  U集合 里是 待确定的 节点



**但是 代码 和 讲的 稍微不一样**

S集合 存放的 一直是 所有节点的 最短距离, 初值都为0

U集合 使用 bool , true 表示 该编号已经确定了最短距离, false 表示 还未确定

由于 第一个 节点 到本身开始就是0, 是确定的, 所以 U 从 编号1 开始, 而不是 0开始



编号, 就是 数组下标



**一定要在 每次确定一个点后,  更新 距离, 再循环判断**

可以 自行加入  ---  行走过程, 打印路径(就像 不带权值的  path数组, 存储 上一个节点编号)





```c++
// 迪杰斯特拉算法接口
int Dijkstra(vector<vector<uint>>& graph,
			 int start,  // 起点 
			 int end)    // 终点
{
	const int N = graph.size();
	// 存储各个顶点的最短路径(最小权值)
	vector<uint> dis(N, 0);   // S集合,
	vector<bool> use(N, false);// U集合

	// 把start放入S集合
	use[start] = true;  // 放入 第一个了
	// 初始化start到其它U集合顶点权值-------S集合里面的 距离都更新了, 不再是0, 而是 二维数组里的 直达距离
	for (int i = 0; i < N; i++)
	{
		dis[i] = graph[start][i];  // 这是 直达的 距离
	}

	// 把U集合中的顶点处理完  i=0 已放入,不需要管
	for (int i = 1; i < N; i++)    // O(n)
	{
		// 先从U集合中找到权值最小的顶点   
		int k = -1;  // 下标, 用于在S集合 修改对应点的最小值
		int min = INF;
		for (int j = 0; j < N; j++)  // O(n)  遍历U, 找最小
		{
			if (!use[j] && min > dis[j]) // U集合的顶点
			{
				min = dis[j];
				k = j;  // 更新下标
			}
		}

		if (k == -1)  // 没有更新, 也就是 到达不了, 一直是INF
		{
			break;  // 直接退出
		}

		// 把选出的顶点加入到S集合中
		use[k] = true;

		// 把U集合中剩余顶点的权值信息更新一下(在S里更新)
		for (int j = 0; j < N; j++)
		{
			if (!use[j] && min + graph[k][j] < dis[j]) // U集合
			{
				dis[j] = min + graph[k][j];
			}
		}
	}

	// 测试打印
	for (int d : dis)
	{
		cout << d << " ";
	}
	cout << endl;

	return dis[end];
}


int main()
{
	vector<vector<uint>> graph =
	{
		{0, 6, 3, INF, INF, INF},
		{6, 0, 2, 5, INF, INF},
		{3, 2, 0, 3, 4, INF},
		{INF, 5, 3, 0, 2, 3},
		{INF, INF, 4, 2, 0, 5},
		{INF, INF, INF, 3, 5, 0},
	};

	int distance = Dijkstra(graph, 0, 1);
	if (distance == INF)
	{
		cout << "不存在有效路径!" << endl;
	}
	else
	{
		cout << "distance:" << distance << endl;
	}
}
```





### Dijkstra函数---优化(小根堆)

不优化, 是O(n^2)



**优先队列---换成小根堆**   ---  将遍历 U集合找最小, 从 O(n)优化为O(logn)



找权值最小, 小根堆(不需要排序也是可以的)---要注意**要能找到 编号**



注意, 优先队列里面用 pair 键值对时,  大小根堆, 是 按键排序, 而不是 值

因此, pair 里面 应该是 **<权值, 编号>**  这样定义



**注意细节, 处理和上面的 有点不同----尤其是 更新 U集合顶点的权值, 无法遍历得到----只能重复添加(只重复添加 未处理过的)**



回顾一下, STL的 一些通用 函数名

三大最基本的  vector, deque, list   都是 push_back, 后两个还有 push_front,  因为是一个是 双端队列, 一个是 双向链表



剩下的 都是 push



而且 emplace-----一般是 push...和insert 改为emplace即可

而且, emplace  在 构建pair类时,   push...和 insert  需要{}或者make_pair

但是 emplace不用,  直接(... , ...) 即可







```c++
// 迪杰斯特拉算法接口-优化
int Dijkstra(vector<vector<uint>>& graph,
	int start,  // 起点 
	int end)    // 终点
{
	const int N = graph.size();
	// 存储各个顶点的最短路径(最小权值)
	vector<uint> dis(N, 0);
	vector<bool> use(N, false);

	// 定义小根堆
	priority_queue<pair<uint, int>, vector<pair<uint, int>>, greater<pair<uint, int>>> que;

	// 把start放入S集合
	use[start] = true;
	// 初始化start到其它U集合顶点权值
	for (int i = 0; i < N; i++)
	{
		dis[i] = graph[start][i];
		// 把除start顶点的其它顶点全部放入U集合小根堆中
		if (i != start)
		{
			que.emplace(graph[start][i], i);
		}
	}

	// 把U集合中的顶点处理完  
	while (!que.empty())    // O(n)
	{
		// 用小根堆找权值最小的顶点    O(logn)   pair<权值，顶点编号>
		// 先从U集合中找到权值最小的顶点   
		auto pair = que.top();
		que.pop();
		if (pair.first == INF)  
		{
			break;
		}
		int k = pair.second;
		int min = pair.first;

		if (use[k])  // 必须是没处理过的
			continue;  // 会弹出
		// 把选出的顶点加入到S集合中
		use[k] = true;

		// 把U集合中剩余顶点的权值信息更新一下
		for (int j = 0; j < N; j++)
		{
			if (!use[j] && min + graph[k][j] < dis[j]) // U集合
			{
				dis[j] = min + graph[k][j];
				// 更新U集合中顶点的权值！
				que.emplace(dis[j], j); // j会有重复, 也就是que里存的东西 大于 U集合false的大小, 但不影响, 有标识处理了没有
			}
		}
	}

	// 测试打印
	for (int d : dis)
	{
		cout << d << " ";
	}
	cout << endl;

	return dis[end];
}
```



## Floyd-弗洛伊德-代码巨简单

**多源最短路径!!**----->   Dijkstra本身是 单源最短路径,  而要是 每个顶点运用一次 Dijkstra , 也算是  多源最短路径---> 也是 O(n^3) 

运用了 **动态规划**

O(n^3)---->  优点就是  **负权值**,  代码 更简单, 比Dijkstra 更简单!!





![image-20250411215422831](./2-数据结构(五大算法之后).assets/图-7.png)



代码巨简单,  核心就是  三层for循环+ 一个状态转移方程



```c++
#include <iostream>
#include <vector>
using namespace std;

using uint = unsigned int;
const uint INF = INT_MAX;

int main()
{
	vector<vector<uint>> graph =
	{
		{0, 6, 3, INF, INF, INF},
		{6, 0, 2, 5, INF, INF},
		{3, 2, 0, 3, 4, INF},
		{INF, 5, 3, 0, 2, 3},
		{INF, INF, 4, 2, 0, 5},
		{INF, INF, INF, 3, 5, 0},
	};

	// 一次把每一个顶点加入
	for (int k = 0; k < graph.size(); k++)
	{
		// 都需要遍历邻接矩阵
		for (int i = 0; i < graph.size(); i++)
		{
			for (int j = 0; j < graph.size(); j++)
			{
				graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j]);
			}
		}
	}

	for (auto line : graph)
	{
		for (auto dis : line)
		{
			cout << dis << " ";
		}
		cout << endl;
	}

	// cout << graph[start][end] << endl;
}
```





# 并查集

## 1.基础理论-pdf

1. **树形结构**
2. 解决  **元素分组问题**,  处理  **不相交集合的**   **合并和查询等**
3. 用一个数组 表示  整片森林,  树的根节点 唯一标识 一个集合



## 并查集构建过程

![image-20250414085440926](./2-数据结构(五大算法之后).assets/并查集-1.png)

--不理解 就看课



**合并:**

将若干元素合并到一个或者多个集合（**构成一棵树或多棵树**），将多个集合合并（多颗树合并为一棵树）





**查询:**

查询两个元素是否在同一个集合中-----**就看在不在一个树中**





计算共有**几个集合**（**几棵树**）







## 并查集代码



重点:   **并查集 必须 依赖于 数组**



**主要思想：**每一个节点对应的数组元素位置，存储它**父节点的编号**即可！





主要是:  用数组下标 代表元素,  数组里 存的是 元素对应的 **父节点**



![image-20250414091522037](./2-数据结构(五大算法之后).assets/并查集-2.png)

### 1.数组初始化

```c++
const int SIZE = 9;
int parent[SIZE]; // 记录每个节点的父节点(经过优化后记录树的根节点编号)
int rank[SIZE];   // 记录节点的层高


int main()
{
	// 数组初始化，存储当前节点自己的编号
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
		rank[i] = 1;  
	}
}
```





### 查询--合并要用到

假定已经  得到了 完整的  并查集 数组





```c++
// 并查集-查询方法。返回参数x节点所在树的根节点的编号
int non_find(int x)
{
	while (x != parent[x])  //找不到根, 只有相等 才是根节点
	{
		// x更新成其父节点的编号
		x = parent[x];
	}
	return x;
}
```



```c++
// 并查集-查询方法。递归版本实现
int find(int x)
{
	if (x == parent[x])
	{
		return x;
	}
	return find(parent[x]);
}


```





### 合并--从头开始



```c++
// 并查集-union合并方法
// x和y原来不在一个集合中，才需要合并；如果已经在一个集合中了，不需要合并
void merge(int x, int y)
{
	x = find(x);  // 查其根节点
	y = find(y);
	if (x != y)
	{
        // 合并两个集合
		parent[x] = y;//或者反过来挂
		
	}
}
```





### 测试

```c++
int main()
{
	// 数组初始化，存储当前节点自己的编号
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
	}

	/*
1 3
1 2
5 4
2 4
6 8
8 7
	*/
	int x, y;
	for (int i = 0; i < 6; i++)
	{
		cin >> x >> y;
		merge(x, y);
	}

	cout << (find(2) == find(4) ? "OK" : "NO") << endl;
}
```





## 并查集路径压缩与加权标记-find优化

### 路径压缩代码

因为是树,  为了查询更快,  应该让其 更窄, 更短



 大多数情况下，在查询过程中**只关心根节点是什么，并不关系这棵树的形态**，因此在查询操作的时候**将访问过的每个点的父节点修改成树根**，这样的方法叫做**路径压缩**。             

主要 学会递归优化, 很方便,  仅修改了 最后一行





```c++
// 并查集-查询方法。返回参数x节点所在树的根节点的编号
int non_find(int x)
{
	// int pos = x;
	while (x != parent[x])
	{
		// x更新成其父节点的编号
		x = parent[x];
	}

	// 树根是x。把执行查询操作的时候将访问过的每个点的父节点修改成树根
	// parent[pos] = x;

	return x;
}
```







在 C/C++ 中，赋值语句不仅完成赋值操作，还**返回被赋值的那个值**。

**递归---重点**

```c++
// 并查集-查询方法。递归版本实现
int find(int x)
{
	if (x == parent[x])
	{
		return x;
	}
	// 把执行查询操作的时候将访问过的每个点的父节点修改成树根
	return parent[x] = find(parent[x]);
}

```





### 路径压缩特性

路径压缩 的 一些特性:

1. 第一次 find 效率不高, 只要 find过, 就很高
2. 牵一发而动全身----> merge里 有 find, 合并的过程就会 find,  合并完成,  find效率就很高了



### 加权标记--大数据-merge优化

1. 大数据  容易出现  树特别高的 情况
2. 使用标记, 记录 每个根对应树的  高度信息, 
3. 把高度 小的 挂到  高度低的树上-->  是 合并的树  尽可能低
4. **小的 挂到 大的, 不用变, 大的 树高没变**
5. **相等, 随便挂一个, 被挂的 要 加一层 ,** 



```c++
// 数组初始化，存储当前节点自己的编号
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
        rank[i] = 1;  //  给 一个初值 1,  合并 会更新
	}




// 并查集-union合并方法
// x和y原来不在一个集合中，才需要合并；如果已经在一个集合中了，不需要合并
void merge(int x, int y)
{
	x = find(x);
	y = find(y);
	if (x != y)
	{
		if (rank[x] > rank[y])
		{
			parent[y] = x;
		}
		else
		{
			if (rank[x] == rank[y])
			{
				// y作为合并以后的集合树的根，rank值要+1
				rank[y]++;
			}
			// 合并两个集合
			parent[x] = y;
		}
	}
}



```







## 应用-最小生成树-Kruskal

### 基础理论-pdf

1. 名词:  连通图,  强连通图, 连通网, 生成树, 最小生成树--->  这几个名词 概念要特别清晰
2. 克鲁斯卡尔算法(加边法)--->求 最小生成树---> 点多边少--稀疏图
3. 加点法(Prim算法)----> 稠密图

### Kruskal步骤

Kruskal算法：此算法可以称为“加边法”，**初始最小生成树边数为0**，每**迭代一次**就**选择一条满足条件的**最小代价边，加入到最小生成树的边集合里，步骤如下：



1. 把图中的所有边按权值**从小到大排序**，把图中的n个顶点看成独立的n颗树组成的森林
2. 按权值**从小到大**选择边，所选的边连接的两个顶点Vi和Vj **应属于**两颗**不同**的树，则称为最小生成树中的一条边，并合并成一棵树
3. 重复步骤2，直到所有顶点都在一棵树内或者有n-1条边为止。

**例子  见 pdf**



### Kruskal代码

本代码:  char  隐式转换成  int了

#### 第一步:加入点和边,并排序

```c++
// 边类型
struct Edge
{
	Edge(int s, int e, int c)
		: start(s)
		, end(e)
		, cost(c)
	{}
	int start; // 起始的节点
	int end;   // 末尾节点
	int cost;  // 边的权值
};
const int SIZE = 1000;
int parent[SIZE];



int main()
{
	for (int i = 0; i < SIZE; i++)
	{
		parent[i] = i;
	}
    // 定义一个边数组
	vector<Edge> edges;
	int n;
	cin >> n;
    char s, e;
	int c;
    for (int i = 0; i < n; i++)
	{
		cin >> s >> e >> c;
		// 读取边的信息，添加到边数组中
		edges.emplace_back(s, e, c);
	}	
    
    // 所有的边按权值小到大进行排序
	sort(edges.begin(), edges.end(),
		[](auto& a, auto& b)->bool {
			return a.cost < b.cost;
		});
    
    //开始选边
    
    
}

```





#### 第二步:从小到大选边



```c++
// 开始选边（按小到大进行选择）
for (int i = 0; i < edges.size(); i++)
{
	// 所谓选择边，就是合并这条边的两个顶点，但是前提是
	// 这两个顶点之前不在一颗树上(不在一个集合中)
	int a = find(edges[i].start);  //并查集的查询
	int b = find(edges[i].end);
	if (a != b)  // 不在一棵树, 可以合并
	{
		// 可以进行合并-----随便挂
		parent[a] = b;
		printf("%c -> %c cost:%d \n", edges[i].start,
			edges[i].end, edges[i].cost);
	}
}
```





## 题目:躲避拥堵的最佳路线

![image-20250414121234557](./2-数据结构(五大算法之后).assets/最小生成树-1.png)



```c++
3 3 1 3
1 2 2
2 3 1
1 3 3
```





注意是找 s->t的路径!!!!

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int SIZE = 1000;
int parent[SIZE];


struct Edge
{
	Edge(int a, int b, int c)
		:_u(a),
		_v(b),
		_w(c)
	{ }

	int _u;
	int _v;
	int _w;
};

vector<Edge> vec;  // n条边


int find(int n)
{
	if (n == parent[n])
	{
		return n;
	}
	return parent[n] = find(parent[n]);
}

int main()
{
	int m, n, s, t;
	cin >> m >> n >> s >> t;

	// 初始化 并查集的 数组
	for (int i = 0; i < n; ++i)
	{
		parent[i] = i;  
	}


	int u, v, w;

	//边信息
	for (int i = 1; i <= m; ++i)
	{
		cin >> u >> v >> w;
		vec.push_back({ u, v, w });
	}
	//排序边
	sort(vec.begin(), vec.end(), [](Edge& a, Edge& b)->bool {
		return a._w < b._w;
		});


	//选边
	for (int i = 0; i < vec.size(); ++i)
	{
		int a = find(vec[i]._u);
		int b = find(vec[i]._v);
		if (a != b)
		{
			//合并
			parent[a] = b;
			/*cout << vec[i]._u << "--->" << vec[i]._v << endl;*/

			//根据最小生成树, 第一次出现通路, 就是 路径拥挤度的最大值最小的时候
			if (find(s) == find(t))
			{
				cout << vec[i]._w << endl;
				break;
			}
			/*if (vec[i]._w > maxmin)
			{
				maxmin = vec[i]._w;
			}*/
		}


	}

	return 0;
}
```



