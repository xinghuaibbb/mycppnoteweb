# C++之基础语法

## 1、在main执行之前和之后执行的代码可能是什么？

**main函数执行之前**，主要就是初始化系统相关资源：

+ 设置栈指针
+ 初始化静态`static`变量和`global`全局变量，即`.data`段的内容
+ 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容     
+ 全局对象初始化，在`main`之前调用构造函数，这是可能会执行前的一些代码
+ 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
+ `__attribute__((constructor))`

**main函数执行之后**：  

+ 全局对象的析构函数会在main函数之后执行； 
+ 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
+ `__attribute__((destructor))`

>update1:https://github.com/forthespada/InterviewGuide/issues/2 ,由`stanleyguo0207`提出 - 2021.03.22



> ### **补充**
>
> ### 栈指针
>
> - 本质上就是“给栈指针（%rsp 或 esp）一个栈顶地址”，以便栈可以正常使用。
> - 由**操作系统的程序加载器（loader）**完成
>
> ### 为什么要设置栈指针？
>
> - ### **栈**是用来**支持函数调用、参数传递、局部变量保存**等操作的关键内存区域。
>
> - CPU 在执行 `call`、`push`、`pop` 等指令时，默认会使用 **栈指针寄存器**（x86 上是 `esp` / `rsp`）来读写数据。
>
> - 如果没有正确设置栈指针，调用函数或使用局部变量时会导致**非法内存访问**。
>
> ### __attribute\_\_((constructor))
>
> 给一个函数加上 `__attribute__((constructor))`，这个函数会在 `main()` 函数 **之前** 自动调用，**不需要你手动调用它**。
>
> constructor---构造函数
>
> destructor---析构函数
>
> 不过不能以字面理解
>
> ```sql
> #include <stdio.h>
> 
> void __attribute__((constructor)) before_main() {
>     printf("before main\n");
> }
> 
> void __attribute__((destructor)) after_main() {
>     printf("after main\n");
> }
> 
> int main() {
>     printf("inside main\n");
>     return 0;
> }
> ```
>
> ```cpp
> before main
> inside main
> after main
> ```
>
> 





## 2、结构体内存对齐问题？

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）

c++11以后引入两个关键字 [alignas](https://zh.cppreference.com/w/cpp/language/alignas)与 [alignof](https://zh.cppreference.com/w/cpp/language/alignof)。其中`alignof`可以计算出类型的对齐方式，`alignas`可以指定结构体的对齐方式。

但是`alignas`在某些情况下是不能使用的，具体见下面的例子:

> [!tip]
>
> 结构体内存对齐---- 意思是 **最大的** 或者 **指定的**  **整数倍**!!!

```cpp
// alignas 生效的情况

struct Info {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl;   // 6  2 + 2 + 2
std::cout << alignof(Info) << std::endl;  // 2

struct alignas(4) Info2 {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl;   // 8  2 + 2 + 2 + 2
std::cout << alignof(Info2) << std::endl;  // 4
```

`alignas`将内存对齐调整为4个字节。所以`sizeof(Info2)`的值变为了8。

```cpp
// alignas 失效的情况

struct Info {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl;   // 12  4 + 4 + 4
std::cout << alignof(Info) << std::endl;  // 4

struct alignas(2) Info2 {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl;   // 12  4 + 4 + 4
std::cout << alignof(Info2) << std::endl;  // 4
```



> ### 失效情形
>
> 若`alignas`小于自然对齐的最小单位，则被忽略。

- 如果想使用单字节对齐的方式，使用`alignas`是无效的。应该使用`#pragma pack(push,1)`或者使用`__attribute__((packed))`。

  > ### 补充
  >
  > 如果你用 GCC 编译 C 文件，会定义 `__GNUC__`，但不会定义 `__GNUG__`。
  >
  > 如果你用 GCC 编译 C++ 文件，会定义 `__GNUC__` 和 `__GNUG__`。
  >
  > ### 为什么用两个宏判断？
  >
  > 为了**兼容性更强**：
  >
  > - 如果你只判断 `__GNUG__`，那只在编译 C++ 时生效；
  > - 如果你只判断 `__GNUC__`，那可能漏掉一些 C++ 特有场景；
  > - 所以 `||` 联合使用是最稳妥的写法。
  >
  > | 项目               | 描述                                          |
  > | ------------------ | --------------------------------------------- |
  > | 目的               | 实现结构体按 1 字节对齐，压缩内存布局         |
  > | GCC/Clang 实现方式 | `__attribute__((packed))`                     |
  > | MSVC 实现方式      | `#pragma pack(push,1)` 和 `#pragma pack(pop)` |
  > | 整洁性             | 使用 `#undef` 清理宏，防止污染后续代码        |
  > | 输出               | `sizeof(Info)` 是 6，`alignof(Info)` 是 1     |
  > |                    |                                               |
  >
  > ### 常见编译器类型与对应宏-了解
  >
  > | 编译器                                  | 平台                                 | 特征宏                         | 描述                                           |
  > | --------------------------------------- | ------------------------------------ | ------------------------------ | ---------------------------------------------- |
  > | **GCC**（GNU Compiler Collection）      | 跨平台（Linux、Windows、macOS）      | `__GNUC__`                     | 开源，广泛用于 Linux 与嵌入式开发              |
  > | **G++**（GCC for C++）                  | 同上                                 | `__GNUG__`                     | 表示当前是用 GCC 编译 **C++** 而不是 C         |
  > | **Clang / Apple Clang**                 | 跨平台（macOS、iOS、Linux、Windows） | `__clang__`                    | LLVM 项目的前端编译器，兼容 GCC 的属性和语法   |
  > | **MSVC**（Microsoft Visual C++）        | Windows                              | `_MSC_VER`                     | 微软官方 C/C++ 编译器，常用于 Windows 原生开发 |
  > | **Intel C++ Compiler (ICC)**            | Windows / Linux                      | `__INTEL_COMPILER`             | Intel 开发的高性能编译器，兼容 GCC 或 MSVC     |
  > | **MinGW**（Minimalist GNU for Windows） | Windows                              | `__GNUC__`, 有时 `__MINGW32__` | Windows 上的 GCC 包装                          |
  > | **TCC**（Tiny C Compiler）              | 多平台                               | `__TINYC__`                    | 轻量级快速 C 编译器，主要用于学习和实验        |
  >
  > 

  > ### pack
  >
  > **`#pragma pack(push, 1)`** 和 **`__attribute__((packed))`** 都是用来设置结构体为「紧凑对齐（packed）」的手段，作用相同，只是因为**不同编译器语法不同**，所以用法不同。
  >
  > | 方法                                           | 适用编译器                         | 写法位置                | 说明                       |
  > | ---------------------------------------------- | ---------------------------------- | ----------------------- | -------------------------- |
  > | `#pragma pack(push, 1)` 和 `#pragma pack(pop)` | MSVC（微软）为主，也支持 GCC/Clang | 写在结构体定义 **外部** | 控制后续所有结构的对齐方式 |
  > | `__attribute__((packed))`                      | GCC / Clang / MinGW                | 写在结构体定义 **结尾** | 只控制当前结构体对齐       |

  ```cpp
  #if defined(__GNUC__) || defined(__GNUG__)
    #define ONEBYTE_ALIGN __attribute__((packed))
  #elif defined(_MSC_VER)
    #define ONEBYTE_ALIGN   // MSVC 不能像 GCC 那样在结构体后加 __attribute__，所以这里先空着。
    #pragma pack(push,1)
  #endif
  
  struct Info {
    uint8_t a;
    uint32_t b;
    uint8_t c;
  } ONEBYTE_ALIGN;    // GUN 语法
  
  #if defined(__GNUC__) || defined(__GNUG__)
    #undef ONEBYTE_ALIGN
  #elif defined(_MSC_VER)
    #pragma pack(pop)
    #undef ONEBYTE_ALIGN
  #endif
  
  std::cout << sizeof(Info) << std::endl;   // 6 1 + 4 + 1
  std::cout << alignof(Info) << std::endl;  // 1
  ```

- 确定结构体中每个元素大小可以通过下面这种方法:

  > ### 补充
  >
  > ### 什么是「位域」（bit field）？
  >
  > 位域是 C/C++ 提供的一种**用于在结构体中以位（bit）为单位划分内存的语法机制**。
  >
  > ### 常规结构体是“字节（byte）为单位”：
  >
  > ```
  > struct Normal {
  >     uint8_t a;
  >     uint8_t b;
  > };
  > ```
  >
  > 上面每个成员都占 1 字节，共 2 字节。
  >
  > ------
  >
  > ### 位域结构体是“位（bit）为单位”：
  >
  > ```
  > struct BitField {
  >     uint8_t a : 1;
  >     uint8_t b : 2;
  >     uint8_t c : 5;
  > };
  > ```
  >
  > 这就表示：
  >
  > - `a` 占 1 位
  > - `b` 占 2 位
  > - `c` 占 5 位
  >    🟰 总共正好占 8 位（1 字节）
  >
  > ### 为什么 `alignas` 控制不了位域的内部分布？
  >
  > 因为：
  >
  > 1. `alignas(n)` 控制结构体在内存中的**起始地址对齐方式**；
  > 2. 位域的**打包与填充规则是由编译器定义的实现细节**，不能通过 `alignas` 精确控制；
  > 3. 如果你想精确控制位布局，还得依赖：
  >    - `#pragma pack(n)`
  >    - `__attribute__((packed))`
  >    - 使用 `uint8_t` + 手动位运算控制
  >
  > ### 可以用 `alignas`，但只能控制结构体本身的**起始地址对齐**，**不能影响位域内部的分布规则**。
  >
  > 例如：
  >
  > ```
  > struct alignas(4) BitField {
  >     uint8_t a : 1;
  >     uint8_t b : 2;
  >     uint8_t c : 5;
  > };
  > ```
  >
  > ### 这表示：
  >
  > - 整个结构体在内存中以 **4 字节对齐方式开始存放**
  > - **但位域成员的布局规则，仍然由编译器决定**
  >   - 可能放在 1 字节内（如 GCC 默认行为）
  >   - 也可能对齐到 4 字节边界（如某些特殊平台）
  
  ```cpp
  #if defined(__GNUC__) || defined(__GNUG__)
    #define ONEBYTE_ALIGN __attribute__((packed))
  #elif defined(_MSC_VER)
    #define ONEBYTE_ALIGN
    #pragma pack(push,1)
  #endif
  
  /**
  * 0 1   3     6   8 9            15
  * +-+---+-----+---+-+-------------+
  * | |   |     |   | |             |
  * |a| b |  c  | d |e|     pad     |
  * | |   |     |   | |             |
  * +-+---+-----+---+-+-------------+
  */
  struct Info {
    uint16_t a : 1;
    uint16_t b : 2;
    uint16_t c : 3;
    uint16_t d : 2;
    uint16_t e : 1;
    uint16_t pad : 7;
  } ONEBYTE_ALIGN;
  
  #if defined(__GNUC__) || defined(__GNUG__)
    #undef ONEBYTE_ALIGN
  #elif defined(_MSC_VER)
    #pragma pack(pop)
    #undef ONEBYTE_ALIGN
  #endif
  
  std::cout << sizeof(Info) << std::endl;   // 2
  std::cout << alignof(Info) << std::endl;  // 1
  ```
  
  这种处理方式是`alignas`处理不了的。

>update1:https://github.com/forthespada/InterviewGuide/issues/2 ,由`stanleyguo0207`提出 - 2021.03.22



## 3、指针和引用的区别

- **指针**是一个**变量**，存储的是一个地址，**引用**跟原来的变量实质上是同一个东西，是**原变量的别名**
- 指针可以有**多级**，引用只有一级
- 指针可以为空，**引用不能为NULL**且在定义时**必须初始化**
- 指针在初始化后可以改变指向，而**引用**在初始化之后**不可再改变**
- **sizeof**指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
- 当把指针作为参数进行传递时，也是将实参的一个**拷贝**传递给形参，两者指向的**地址相同**，**但不是同一个变量**，在函数中改变这个变量的指向不影响**实参**，而引用却可以。
- 在汇编层面，**一些编译器将引用当成指针操作**，因此引用会占用空间。**是否占用空间，应该结合编译器分析。**
- 引用在声明时必须初始化为另一变量，一旦出现必须为`typename &refname=varname`(类型名 &引用名 = 变量;)形式；**指针声明和定义可以分开**，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用在初始化之后就不能再更改绑定的对象（即引用不能重新指向其他变量），而指针变量则可以随时修改指向的地址。虽然多个引用可以绑定到同一个变量，但每个**引用**都只能绑定一个变量，且**一经绑定不可更改**。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

参考代码：

```cpp
void test(int *p)
{
　　int a=1;
　　p=&a;
　　cout<<p<<" "<<*p<<endl;
}

int main(void)
{
    int *p=NULL;
    test(p);
    if(p==NULL)
    cout<<"指针p为NULL"<<endl;
    return 0;
}
//运行结果为：
//0x22ff44 1
//指针p为NULL


void testPTR(int* p) {
	int a = 12;
	p = &a;

}

void testREFF(int& p) {
	int a = 12;
	p = a;

}
void main()
{
	int a = 10;
	int* b = &a;
	testPTR(b);//改变指针指向，但是没改变指针的所指的内容
	cout << a << endl;// 10
	cout << *b << endl;// 10

	a = 10;
	testREFF(a);
	cout << a << endl;//12
}
```

在编译器的角度来看，`int a = 10; int &b = a;` 实际上等价于 `int* const b = &a;`，也就是说引用在底层可以看作是一个**指向变量的常量指针**。-- 指针b的值不能改,  指针指向的内容 可以改-----也对应了 引用绑定后, 就不能指向别的地方了, 但是 可以改变内容
当我们写 `b = 20;` 时，实际上编译器会将其自动转化为 `*b = 20;`，即自动解引用。这也就是为什么引用看起来像是“变量的别名”，使用时无需显式地加 `*` 或 `&`，但本质上类似于指针的行为。





## 4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？

* 使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏,此时 需要**返回函数内 这个开辟的 局部变量的内存的时候用指针**。而返回局部变量的引用是没有意义的

* 对栈空间大小比较敏感（比如递归）的时候使用引用。使用**引用传递不需要创建临时变量**，开销要更小

* **类对象**作为**参数传递**的时候**使用引用**，这是**C++类对象传递的标准方式**

> hzh
>
> **只能返回堆内存的指针或引用，不能返回栈上局部变量的指针或引用。**
> 返回堆内存时要记得手动释放，避免内存泄漏。



## 5、堆和栈的区别

- 申请方式不同。

  - 栈由系统自动分配。

- 堆是自己申请和释放的。

- 申请大小限制不同。

  - 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。

    > 栈是向栈底扩展-- 这个表达 太变态了
    >
    > **沿着从栈底指向栈顶的方向在扩展**

    

  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。

- 申请效率不同。

  - 栈由系统分配，速度快，不会有碎片。

  - 堆由程序员分配，速度慢，且会有碎片。

  

 栈空间默认是4M, 堆区一般是 1G - 4G 

|                  | 堆                                                           | 栈                                                           |
| :--------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |
| **内存管理机制** | 系统有一个**记录空闲内存地址的链表**，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，**删除空闲结点链表中的该结点**，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将**多余的部分重新放入空闲链表**中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
| **空间大小**     | 堆是**不连续**的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit  系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在编译时确定，VC中可设置） |
| **碎片问题**     | 对于堆，**频繁的new/delete会造成大量碎片**，使程序效率降低   | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。`（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）` |
| **生长方向**     | 堆向上，向高地址方向增长。                                   | 栈向下，向低地址方向增长。                                   |
| **分配方式**     | 堆都是动态分配（没有静态分配的堆）                           | **栈有静态分配和动态分配**，**静态分配**由编译器完成（如局部变量分配），**动态分配**由`alloca`函数分配，但栈的动态分配的资源**由编译器进行释放**，无需程序员实现。 |
| **分配效率**     | 堆由C/C++函数库提供，机制很复杂。所以**堆的效率比栈低很多**。 | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。 |

**形象的比喻**

栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。



## 6、你觉得堆快一点还是栈快一点？

毫无疑问是**栈快一点**。

因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

> hzh
>
> 在大多数 CPU 架构中，确实会：
>
> **专门分配一个寄存器，用来指向当前的“栈顶”地址。**
>
> - 在 **x86 架构** 中，这个寄存器叫：`ESP`（32位）或 `RSP`（64位）--- 这不就是 施磊老师 编译原理 用的吗?
>
> 指令-不就是 push pop吗----老师也讲了

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。





## 7、区别以下指针类型？

```cpp
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- int *p[10]表示指针数组，**强调数组概念**，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的**指针变量**。

- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过**指向的是一个int类型的数组**，这个数组大小是10。

- int *p(int)是**函数声明**，函数名是p，参数是int类型的，返回值是int *类型的。

- int (*p)(int)是**函数指针**，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

  ```cpp
  #include <stdio.h>
  
  // 一个匹配的函数
  int square(int x) {
      return x * x;
  }
  
  int main() {
      // 声明函数指针
      int (*p)(int);
      
      // 指向 square 函数
      p = square;
      
      // 通过指针调用函数
      int result = p(5);  // 等同于 square(5)
      
      printf("Result: %d\n", result);  // 输出 25
      
      return 0;
  }
  ```

  

> hzh
>
> 名字---按照强调的,强调的放后面
>
> 意义---按照施磊老师的,谁近,修饰谁---这个是看 const int *---自己回顾





## 8、new / delete 与 malloc / free的异同

**相同点**

- 都可用于内存的动态申请和释放

**不同点**

- 前者是**C++运算符**，后者是**C/C++语言标准库函数**
- new自动计算要分配的空间大小，malloc需要手工计算
- new是类型安全的，malloc不是。例如：

```cpp
int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译无错误
```

*  #### new调用名为**operator new**的标准库函数**分配足够空间并调用相关对象的构造函数**，delete对**指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存**。后者均没有相关调用
*  后者需要**库文件支持** `<stdlib.h>`（C）或 `<cstdlib>`（C++），前者不用
*  new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象 



## 9、new和delete是如何实现的？

- new的实现过程是：首先调用名为**operator new**的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
- delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为**operator delete**的标准库函数释放该对象所用内存

> 施磊老师 讲的很透了, 可以手动实现



## 10、malloc和new的区别？

- **malloc和free是标准库函数，支持覆盖**；**new和delete是运算符，支持重载**。

  > ```cpp
  > class MyClass {
  > public:
  >     void* operator new(size_t size) {
  >         std::cout << "Custom new for MyClass\n";
  >         return ::operator new(size); // 调用全局 new
  >     }
  >     void operator delete(void* ptr) {
  >         std::cout << "Custom delete for MyClass\n";
  >         ::operator delete(ptr); // 调用全局 delete
  >     }
  > };
  > ```
  >
  > ```cpp
  > void* malloc(size_t size) {
  >     printf("Custom malloc!\n");
  >     return my_custom_alloc(size);
  > }
  > ```
  >
  > **混用会导致问题**
  >
  > ```
  > // 错误！用 malloc 分配但尝试用 delete 释放
  > int* p = (int*)malloc(sizeof(int));
  > delete p; // 未定义行为：可能漏掉析构调用
  > 
  > // 正确配对使用
  > int* p1 = new int;
  > delete p1;
  > 
  > void* p2 = malloc(sizeof(int));
  > free(p2);
  > ```

- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。

- malloc和free返回的是**void类型指针（必须进行类型转换）**，new和delete返回的是**具体类型指针**。

  >update1:感谢微信好友“猿六学算法”指出错误，已修正！

> **覆盖（Override）** 和 **重载（Overload）** 是两个不同的概念，而这里的“覆盖”特指对标准库函数（如 `malloc`/`free`）的**替换实现**。以下是详细解释：
>
> ------
>
> ### **1. 覆盖（Override）**
>
> #### **定义**：
>
> - **替换标准库函数**：通过提供自定义的实现，替换原有的库函数（如 `malloc`、`free`）。
> - **发生在链接阶段**：链接器会优先使用你提供的实现，而非标准库的实现。
> - **C 风格**：常见于 C 中，因为 C 不支持运算符重载（如 `new`/`delete`）。
>
> #### **示例：覆盖 `malloc`**
>
> ```
> #include <stdio.h>
> #include <stdlib.h>
> 
> // 自定义 malloc 实现
> void* malloc(size_t size) {
>     printf("Custom malloc: allocating %zu bytes\n", size);
>     return sbrk(size); // 简单示例：使用 sbrk 分配内存（实际中需更复杂实现）
> }
> 
> int main() {
>     int* p = (int*)malloc(100); // 调用的是自定义的 malloc
>     free(p);
>     return 0;
> }
> ```
>
> #### **关键点**：
>
> - 需与原函数**签名完全一致**（如 `malloc` 的返回类型和参数）。
> - 需处理所有原始功能（例如内存分配和释放的簿记）。
> - 通常用于：
>   - 内存池优化。
>   - 调试内存分配（如记录分配大小）。
>   - 替换为更高效的内存分配器（如 `jemalloc`、`tcmalloc`）。
>
> ------
>
> ### **2. 对比：重载（Overload）**
>
> #### **定义**：
>
> - **同一作用域内同名函数的不同版本**：通过参数列表区分（C++ 特性）。
> - **适用于运算符**：如重载 `new`/`delete`。
>
> #### **示例：重载 `new`**
>
> ```
> #include <iostream>
> 
> class MyClass {
> public:
>     // 重载类的 new 运算符
>     void* operator new(size_t size) {
>         std::cout << "Custom new: allocating " << size << " bytes\n";
>         return ::operator new(size); // 调用全局 new
>     }
> };
> 
> int main() {
>     MyClass* obj = new MyClass(); // 调用重载的 new
>     delete obj;
>     return 0;
> }
> ```
>
> #### **关键点**：
>
> - 是 C++ 的语法特性，依赖编译器支持。
> - 可以针对**特定类**或**全局**重载。
>
> ### **覆盖 vs 重载**
>
> | 特性               | 覆盖（Override）          | 重载（Overload）         |
> | :----------------- | :------------------------ | :----------------------- |
> | **作用对象**       | 已有库函数（如 `malloc`） | 函数/运算符（如 `new`）  |
> | **语言支持**       | C/C++（通过链接替换）     | C++ 独有                 |
> | **实现方式**       | 提供同名函数实现          | 定义同名但参数不同的函数 |
> | **是否需匹配签名** | 必须完全一致              | 只需参数列表不同         |
> | **典型用途**       | 替换内存管理、调试        | 定制类对象的内存分配     |

## 11、既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？

* malloc/free和new/delete都是用来申请内存和回收内存的。
* 在对**非基本数据类型的**对象使用的时候，对象创建的时候**还需要执行构造函数**，销毁的时候**要执行析构函数**。而malloc/free是库函数，是**已经编译的代码**，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。



## 12、被free回收的内存是立即返还给操作系统吗？

**不是的**，被free回收的内存会**首先被`ptmalloc`使用双链表保存起来**，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就**避免了频繁的系统调用**，占用过多的系统资源。同时ptmalloc也会尝试对**小块内存进行合并**，**避免过多的内存碎片**。

> ### 补充
>
> ### ptmalloc 简述与工作机制--pthread malloc
>
> `ptmalloc`（pthreads malloc）是 Linux 中 glibc 默认使用的堆内存分配器，基于 `dlmalloc` 改进，支持多线程。其核心目标是：**高效分配内存、减少碎片、提升并发性能**。
>
> ------
>
> ### 1. 内存分配机制概览
>
> #### (1) 空闲块复用（双向链表管理）
>
> - `free` 后的内存不会立即归还操作系统，而是存入按大小分类的 **空闲链表（bin）** 中（双向链表结构）。
> - 下次 `malloc` 优先从链表中复用，避免频繁系统调用。
>
> #### (2) 小块内存合并，降低碎片
>
> - 如果多个相邻的小块被释放，`ptmalloc` 会尝试将它们合并为一个大块，减少碎片。
>
> #### (3) 多 arena 机制（多线程优化）
>
> - 多线程下，每个线程可使用不同的 **arena（独立堆区域）**，避免锁竞争，提升并发性能。
>
> ------
>
> ### 2. 系统内存申请方式：brk 与 mmap
>
> | 方法   | 说明                       | 特点                                 | 使用场景                     |
> | ------ | -------------------------- | ------------------------------------ | ---------------------------- |
> | `brk`  | 调整进程的主堆（heap）顶端 | 分配连续内存、性能高，但线程间竞争大 | 小块内存（<128KB）           |
> | `mmap` | 映射独立内存区域           | 支持并发、释放灵活、非连续           | 大块内存（≥128KB）或特殊情况 |
>
> 
>
> - `ptmalloc` 会**根据请求大小**自动选择使用 `brk` 或 `mmap`。
> - `mmap` 分配的区域更适合大内存或多线程环境。
>
> ------
>
> ### 3. 内存分配与释放流程简述
>
> #### 🔹 malloc（申请内存）：
>
> 1. 查找空闲链表是否有合适块。
> 2. 没有则使用 `brk` 或 `mmap` 向操作系统申请。
>
> #### 🔹 free（释放内存）：
>
> 1. 被释放的内存插入空闲链表。
> 2. 若与相邻内存块连续，则尝试合并。
> 3. 在特定条件下才真正归还给系统。
>
> ------
>
> ### 总结
>
> - `ptmalloc` 是 glibc 的默认分配器，适用于多线程程序。
> - 通过 **双向链表管理空闲块**、**brk/mmap 分级内存申请**、**多 arena 减少锁竞争**，实现了高效、可复用的内存分配机制。
> - 重点优化方向：**性能、碎片控制、并发支持**。

> ### brk
>
> `brk` 和 `sbrk` 是低级内存管理函数，直接操作程序的堆空间。
>
> ```cpp
> #include <unistd.h>
> #include <stdio.h>
> 
> int main() {
>     // 获取当前程序的堆顶地址
>     void *initial_brk = sbrk(0);
>     printf("初始堆顶地址: %p\n", initial_brk);
> 
>     // 向堆中分配 1024 字节
>     void *new_brk = sbrk(1024);
>     if (new_brk == (void *)-1) {
>         perror("sbrk 分配失败");
>         return 1;
>     }
>     printf("分配 1024 字节后堆顶地址: %p\n", sbrk(0));
> 
>     // 释放分配的 1024 字节
>     if (sbrk(-1024) == (void *)-1) {
>         perror("sbrk 释放失败");
>         return 1;
>     }
>     printf("释放 1024 字节后堆顶地址: %p\n", sbrk(0));
> 
>     return 0;
> }
> ```
>
> 

## 13、宏定义和函数有何区别？

- 宏在**预处理阶段完成替换**，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。

- 宏定义属于在结构中插入代码，没有**返回值**；函数调用具有返回值。

- ### 宏定义参数没有类型，不进行**类型检查**；函数参数具有类型，需要检查类型。

- 宏定义不要在最后加**分号**。

> 函数: 调用时只是**跳转到代码段中对应的指令地址**并开始执行
>
> 宏没有 函数调用的开销, 调试无法看到 宏的作用
>
> 可能会问到 内联函数`inline`
>
> `inline` 函数既有函数的类型安全性，又能避免函数调用的开销。
>
> 发生在 编译阶段, 而不是 预处理阶段

## 14、宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。

- 宏替换发生在编译阶段之前，属于文本插入替换；**typedef是编译的一部分**。

- 宏不检查类型；**typedef会检查数据类型**。

- 宏不是语句，不在在最后加分号；**typedef是语句**，要**加分号**标识结束。

- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

> **`typedef char * p_char`**
>
> - `typedef` 是编译器处理的，用于为类型定义别名。
> - 它定义了 `p_char` 是 `char *` 的别名
>
> **`#define p_char char *`**
>
> - `#define` 是预处理器指令，用于简单的文本替换。
> - 它将 `p_char` 替换为 `char *`。
>
> #### 关键区别
>
> | 特性         | `typedef`                  | `#define`                                |
> | ------------ | -------------------------- | ---------------------------------------- |
> | **作用**     | 定义类型别名               | 文本替换                                 |
> | **语义清晰** | 更清晰，避免歧义           | 可能导致意外行为                         |
> | **作用范围** | 编译器处理，作用于类型系统 | 预处理器处理，简单替换                   |
> | **示例行为** | `p_char a, b;` -> 两个指针 | `p_char a, b;` -> 一个指针和一个普通变量 |
>
> #### 注意
>
> `#define` 可以用来为类型创建别名，但它本质上是**简单的文本替换**，并不是真正的类型别名
>
> #### 重点
>
> **`typedef` 定义的是“类型”，而 `#define` 是“纯文本替换”**。--- 慢慢理解
>
> ### 使用 `typedef`
>
> ```
> typedef char* p_char;
> p_char a, b;
> ```
>
> 等价于：
>
> ```
> char* a;
> char* b;
> ```
>
> 因为 `p_char` 是一个完整的类型别名，相当于 `char*`，所以 `a` 和 `b` 都是 `char*` 类型，即**两个指针**。
>
> 编译器会认为 这是 定义 类型变量 
>
> ------
>
> #### 使用 `#define`
>
> ```
> #define p_char char*
> p_char a, b;
> ```
>
> 等价于：
>
> ```
> char* a, b;
> ```
>
> 在 C 中声明多个变量时，**只有紧贴 `*` 的变量是指针**，所以这行代码实际是：
>
> - `a` 是 `char*`
> - `b` 是 `char`
>
> 也就是说：**一个是指针，一个是普通变量**，这是很多人犯错的地方。
>
> 编译器 不把char* 作为类型



> #### 补充-在语法树----想了解, 可以做一个 编译器项目
>
> 在语法树上, typedef 是作为一个整体 放到节点上
>
> define 不会进入语法树
>
> **"`typedef` 是一个整体，而 `#define` 不会作为一个整体"** 
>
> - `typedef` 是**编译器级别的类型定义**，会完整地融入语法树和符号表。
> - `#define` 是**预处理器的文本替换**，在语法树中不留痕迹，编译器看不到它的存在。
>
> 

## 15、变量声明和定义区别？

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。

- 相同变量可以在多处声明（外部变量extern），但**只能在一处定义**。



## 16、strlen和sizeof区别？

- sizeof是**运算符**，并不是函数，结果**在编译时得到**而非运行中获得；strlen是**字符处理的库函数**。

- sizeof参数可以是任何数据的类型或者数据(`静态类型和变量`)（sizeof参数不退化）；strlen的参数**只能是字符指针且结尾是'\0'的字符串**。

- 因为**sizeof**值在编译时确定，所以**不能用来得到动态分配（运行时分配）**存储空间的大小。

~~~cpp
  int main(int argc, char const *argv[]){
      
      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8 
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
~~~

> #### 不能用来得到动态分配（运行时分配）
>
> - 其实就是 不能用 sizeof(指针) 这得到的是指针大小
>
> #### 如何拿到 动态分配内存大小?
>
> - 某些平台或库（如 `glibc`）提供了非标准函数（如 `malloc_usable_size`）来获取动态分配内存的实际大小
>
>   ```cpp
>   #include <stdio.h>
>   #include <stdlib.h>
>   #include <malloc.h> // 需要包含 malloc.h
>   
>   int main() {
>       int *ptr = (int *)malloc(10 * sizeof(int));
>       if (ptr == NULL) {
>           printf("Memory allocation failed\n");
>           return 1;
>       }
>   
>       printf("Usable size: %zu bytes\n", malloc_usable_size(ptr)); // 获取实际分配大小
>   
>       free(ptr);
>       return 0;
>   }
>   ```
>
>   `%z`对应  **`size_t`** 类型
>
> #### 参数退化?
>
> - **`sizeof` 的参数不退化**：当 `sizeof` 的参数是**数组**时，数组不会退化为指针，`sizeof` 会返回整个数组的大小。
> - **其他场景的退化**：在函数参数或普通表达式中，数组名通常会退化为指针。
> - **注意函数参数**：数组作为函数参数传递时，总是退化为指针，因此在函数中无法通过 `sizeof` 获取数组的大小。



## 16.2、（补充题）一个指针占多少字节？

在16题中有提到sizeof（str）的值为**8**，是在**64位**的编译环境下的，指针的占用大小为8字节；

而在**32位**环境下，指针占用大小为**4字节**。

一个指针占内存的大小**跟编译环境有关**，而**与机器的位数无关**。

还有疑问的，可以自行打开Visual Studio编译器自己实验一番。

>感谢微信好友“轻与重”提出补充，已采纳！-2021.07.01

> 这个意思是: 虽然机器的位数（32 位或 64 位）通常决定了编译器默认的指针大小，但编译器可以**在 64 位机器上生成 32 位代码**（即 32 位编译环境），此时指针大小仍然是 4 字节
>







## 17、常量指针和指针常量区别？

- 指针常量是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。

- 常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。

  >update1:https://www.nowcoder.com/discuss/597948   ，网友“ 牛客191489444号 ”指出笔误，感谢！
  >
  >update2:《C++ Primer 5th》 P56页有明确说明常量指针和指针常量，阿秀特意去确认了-20210521。
  >
  >多说一句，网上关于指针常量和常量指针的说法很多跟书本上都不一致，甚至百度百科上跟《C++ Primer 5th》书上在指针常量和常量指针的说法刚好相反，鉴于百度百科是人人都可以去编辑，因此我信书。
  >
  >也希望各位遇到问题时要多去查阅资料，多去确认，不要因为某些博客或者文章说了就确认无疑。

> plus第六版 错误 挺多的, 建议看 《C++ Primer 5th》英文版  明确说了
>
> 英文好理解
>
> `const int *p`  是 pointer to const  指针常量
>
> const pointer 常量指针                                                                                                                                               
>
> 施磊老师讲过, 跟谁进 修饰谁 (int 和 * ), 先看 const 在* 左边还是右边, 再看跟谁近, 中间的话按左边处理                                                                                                                                                                                       

## 18、a和&a有什么区别？

假设数组int a[10]; int (*p)[10] = &a;其中：

- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。***(a + 1) = a[1]**。
- &a是数组的指针，其类型为**int (*)[10]**（就是前面提到的数组指针），**其加1时**，系统会认为是数组首地址**加上整个数组的偏移**（10个int型变量），值为**数组a尾元素后一个元素的地址**。
- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。





## 19、C++和Python的区别

包括但不限于：

- Python是一种**脚本语言，是解释执行**的，而C\+\+是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C\+\+高。
- Python使用**缩进来区分不同的代码块**，C\+\+使用**花括号来区分**
- C\+\+中需要**事先定义变量的类型**，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
- Python的**库函数比C\+\+的多**，调用起来很方便
- python内存无需手动管理



## 20、C++和C语言的区别

- C++中**new和delete**是对内存分配的运算符，取代了C中的malloc和free。
- 标准C++中的**字符串类**取代了标准C函数库头文件中的**字符数组**处理函数（C中没有字符串类型）。
- C++中用来做控制态**输入输出的iostream类库**替代了标准C中的**stdio函数库**。
- C++中的**try/catch/throw异常处理机制**取代了标准C中的**setjmp()和longjmp()函数。**
- 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是**C++可以重载**，C语言不允许。
- C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，`必须要在函数开头部分`。而且C++**不允许重复定义变量**，C语言**也是做不到**这一点的
- 在C++中，除了值和指针之外，**新增了引用**。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。
- C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等

>感谢微信好友“铁锤哥哥”勘误：C++允许重复定义变量->不允许-2021.06.28

> C语言中，`必须要在函数开头部分`-----C98之前,  C99之后已经允许了

> 是的，C++ 中的 **`try`/`catch`/`throw` 异常处理机制** 提供了一种更高级、更安全的方式来处理异常，取代了标准 C 中的 **`setjmp()` 和 `longjmp()`** 函数。以下是两者的对比和解释：
>
> ---
>
> 1. ### **C++ 的异常处理机制**
>
> C++ 提供了内置的异常处理机制，通过 `try`、`catch` 和 `throw` 来捕获和处理运行时的异常。
>
> #### 工作原理：
>
> - **`throw`**：用于抛出异常。
> - **`try`**：用于定义可能抛出异常的代码块。
> - **`catch`**：用于捕获和处理异常。
>
> #### 示例：
>
> ```cpp
> #include <iostream>
> using namespace std;
> 
> void divide(int a, int b) {
>     if (b == 0) {
>         throw runtime_error("除数不能为零"); // 抛出异常
>     }
>     cout << "结果: " << a / b << endl;
> }
> 
> int main() {
>     try {
>         divide(10, 0); // 可能抛出异常
>     } catch (const runtime_error &e) { // 捕获异常
>         cout << "捕获异常: " << e.what() << endl;
>     }
>     return 0;
> }
> ```
>
> #### 输出：
> ```plaintext
> 捕获异常: 除数不能为零
> ```
>
> ---
>
> ### 2. **C 中的 `setjmp()` 和 `longjmp()`**
> 在标准 C 中，没有内置的异常处理机制，通常使用 **`setjmp()` 和 `longjmp()`** 来实现类似的功能。
>
> #### 工作原理：
> - **`setjmp()`**：保存当前的程序状态（如寄存器、栈指针等），用于后续恢复。
> - **`longjmp()`**：跳转回之前保存的状态，类似于异常的抛出。
>
> #### 示例：
> ```c
> #include <stdio.h>
> #include <setjmp.h>
> 
> jmp_buf env;
> 
> void divide(int a, int b) {
>     if (b == 0) {
>         longjmp(env, 1); // 跳转到 setjmp 保存的状态
>     }
>     printf("结果: %d\n", a / b);
> }
> 
> int main() {
>     if (setjmp(env) == 0) {
>         divide(10, 0); // 可能导致跳转
>     } else {
>         printf("捕获异常: 除数不能为零\n");
>     }
>     return 0;
> }
> ```
>
> #### 输出：
> ```plaintext
> 捕获异常: 除数不能为零
> ```
>
> ---
>
> ### 3. **C++ 异常处理 vs C 的 `setjmp()` 和 `longjmp()`**
>
> | 特性           | C++ 异常处理 (`try/catch/throw`)   | C (`setjmp()` 和 `longjmp()`) |
> | -------------- | ---------------------------------- | ----------------------------- |
> | **语法简洁性** | 更简洁，语义清晰                   | 语法复杂，容易出错            |
> | **类型安全**   | 支持类型安全，能捕获特定类型的异常 | 无类型安全，所有跳转都一样    |
> | **可读性**     | 更高，可明确区分正常逻辑和异常逻辑 | 可读性较差                    |
> | **资源管理**   | 支持 RAII（如自动释放资源）        | 无法自动管理资源              |
> | **性能**       | 有一定开销，但更灵活               | 性能较高，但功能有限          |
> | **适用场景**   | 适合复杂的异常处理                 | 适合简单的错误跳转            |
>
> ---
>
> ### 4. **为什么 C++ 异常处理更优？**
> - **类型安全**：C++ 的异常处理机制可以捕获特定类型的异常，而 `setjmp()` 和 `longjmp()` 只是简单的跳转，没有类型信息。
> - **自动资源管理**：C++ 支持 RAII（资源获取即初始化），在异常发生时会自动调用析构函数释放资源，而 C 的 `setjmp()` 和 `longjmp()` 无法做到这一点。
> - **代码可读性**：C++ 的 `try/catch` 语法更直观，便于理解和维护。
>
> ---
>
> ### 5. **总结**
> - C++ 的 **`try/catch/throw`** 提供了更高级的异常处理机制，取代了 C 中的 **`setjmp()` 和 `longjmp()`**。
> - C++ 的异常处理更安全、灵活，适合复杂的程序逻辑。
> - 在现代开发中，推荐使用 C++ 的异常处理机制，而不是依赖 C 的低级跳转方法。



## c++异常

> 在 C++ 中，`try-catch-throw` 是异常处理机制的核心关键字，用于捕捉和处理运行时错误，使程序具备更好的健壮性。下面是对这三个关键字的简要说明和使用方式：
>
> ------
>
> ### 一、`throw` —— 抛出异常
>
> 用于在函数或语句中抛出异常，可以是基本类型、对象，甚至是自定义类型。
>
> ```cpp
> void divide(int a, int b) {
>     if (b == 0) {
>         throw std::runtime_error("Divide by zero");
>     }
>     std::cout << "Result: " << a / b << std::endl;
> }
> ```
>
> ------
>
> ### 二、`try` —— 尝试捕获异常
>
> 用来包裹一段可能抛出异常的代码。
>
> ```cpp
> try {
>     divide(10, 0);  // 这里可能抛出异常
> }
> ```
>
> ------
>
> ### 三、`catch` —— 捕获异常
>
> 紧跟在 `try` 之后，用来捕捉异常并进行处理。支持多个 `catch` 分支，按从上到下匹配。
>
> 需要定义 `const std::runtime_error& e` ,  在使用 `e.what()`
>
> ```cpp
> catch (const std::runtime_error& e) {
>     std::cerr << "Runtime error: " << e.what() << std::endl;
> }
> catch (...) {
>     std::cerr << "Unknown exception caught." << std::endl;
> }
> ```
>
> ------
>
> ### 四、完整示例
>
> ```cpp
> #include <iostream>
> #include <stdexcept>
> 
> void divide(int a, int b) {
>     if (b == 0) {
>         throw std::runtime_error("Divide by zero error");
>     }
>     std::cout << "Result: " << a / b << std::endl;
> }
> 
> int main() {
>     try {
>         divide(10, 0);
>     } catch (const std::runtime_error& e) {
>         std::cerr << "Caught exception: " << e.what() << std::endl;
>     } catch (...) {
>         std::cerr << "Caught unknown exception" << std::endl;
>     }
>     return 0;
> }
> ```
>
> ------
>
> ### 五、注意事项
>
> - 异常抛出成本较高，应避免用于控制逻辑。
> - 可抛出任意类型，但建议抛出标准异常类（如 `std::runtime_error`）。
> - 异常类型的匹配是 **从上到下**，优先匹配具体类型。
> - 可以使用 `throw;` 重新抛出当前异常（仅在 catch 内有效）。
